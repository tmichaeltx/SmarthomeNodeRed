[{"id":"2b2a4010.a6b5e","type":"tab","label":"Triggerable Flows","disabled":false,"info":""},{"id":"98a6e865.a02ea8","type":"tab","label":"Automation Flows","disabled":false,"info":""},{"id":"1a0aa13a.9d7b8f","type":"tab","label":"Fake Radar","disabled":false,"info":""},{"id":"54cae49c.6ee04c","type":"tab","label":"Recurring Flow Triggers","disabled":false,"info":""},{"id":"ba901384.9c229","type":"tab","label":"Flow 1","disabled":true,"info":""},{"id":"1c496d2.90bb093","type":"tab","label":"Flow 2","disabled":true,"info":""},{"id":"592962b2.a94e1c","type":"tab","label":"Flow 3","disabled":false,"info":""},{"id":"d866934c.b2cbc","type":"tab","label":"All readings startup","disabled":false,"info":""},{"id":"27566e75.091d22","type":"tab","label":"Flow 7","disabled":false,"info":""},{"id":"db3a486d.c20478","type":"subflow","name":"Dimmer Settings","info":"","category":"","in":[{"x":400,"y":80,"wires":[{"id":"f2650446.2a56d8"}]}],"out":[{"x":620,"y":80,"wires":[{"id":"f2650446.2a56d8","port":0}]}],"env":[{"name":"Step","type":"num","value":"30"}],"color":"#3FADB5","icon":"node-red/cog.svg"},{"id":"250ecbce.340264","type":"subflow","name":"Read Spreadsheet For Details","info":"","category":"","in":[{"x":40,"y":20,"wires":[{"id":"7115886d.01af18"}]}],"out":[{"x":960,"y":60,"wires":[{"id":"33cf6aac.eabb16","port":0}]},{"x":960,"y":140,"wires":[{"id":"d91779c2.896ea8","port":0}]},{"x":960,"y":220,"wires":[{"id":"46c25d0f.563a44","port":0}]},{"x":960,"y":300,"wires":[{"id":"893d102e.47b92","port":0}]},{"x":960,"y":380,"wires":[{"id":"c62b3213.e206a","port":0}]},{"x":960,"y":460,"wires":[{"id":"c9c7210d.d881f","port":0}]},{"x":960,"y":540,"wires":[{"id":"9cabee41.a056b","port":0}]},{"x":960,"y":620,"wires":[{"id":"be5dfe12.c99f2","port":0}]}],"env":[{"name":"Spreadsheet ID","type":"str","value":"","ui":{"icon":"font-awesome/fa-file-excel-o","type":"input","opts":{"types":["str"]}}},{"name":"TabName","type":"str","value":"","ui":{"icon":"font-awesome/fa-table","label":{"en-US":"Tab"},"type":"input","opts":{"types":["str"]}}},{"name":"ColStart","type":"str","value":"A","ui":{"icon":"font-awesome/fa-columns","type":"input","opts":{"types":["str"]}}},{"name":"ColEnd","type":"str","value":"Z","ui":{"icon":"font-awesome/fa-columns","type":"input","opts":{"types":["str"]}}},{"name":"MinRow","type":"num","value":"1","ui":{"icon":"font-awesome/fa-window-minimize","type":"input","opts":{"types":["num"]}}},{"name":"MaxRow","type":"num","value":"1000","ui":{"icon":"font-awesome/fa-window-maximize","type":"input","opts":{"types":["num"]}}},{"name":"OverrideEnvVariables","type":"bool","value":"false"}],"color":"#0cad0c","outputLabels":["Error","Last Populated Row","First Empty Row","Last Populated Column","First Empty Column","Spreadsheet Array","Full Data","Full Data with Inputs"],"icon":"font-awesome/fa-file-excel-o"},{"id":"711cdb94.5b9a04","type":"subflow","name":"Decide Quality of Ping","info":"","category":"Abandoned Subflows","in":[{"x":40,"y":100,"wires":[{"id":"5117f3ab.9484cc"}]}],"out":[],"env":[],"color":"#FDF0C2"},{"id":"76e3605b.0e6e7","type":"subflow","name":"Process Ping Results To Local Files","info":"","category":"","in":[{"x":20,"y":140,"wires":[{"id":"7c6b7df4.a02714"}]}],"out":[],"env":[],"color":"#0cad0c"},{"id":"aba876af.3a45e8","type":"subflow","name":"Ping, Write Down to Google and send Result to Process Ping Results","info":"","category":"","in":[{"x":20,"y":100,"wires":[{"id":"81b5485a.3abc58"}]}],"out":[],"env":[],"color":"#C7E9C0","status":{"x":1220,"y":520,"wires":[{"id":"ffcbe690.d32758","port":0}]}},{"id":"c3686304.f6d31","type":"subflow","name":"Backup all 4 Hubitats using Bash Script","info":"","category":"","in":[{"x":60,"y":80,"wires":[{"id":"dae3700e.3752"}]}],"out":[],"env":[],"color":"#0cad0c"},{"id":"b2524cfd.8c346","type":"subflow","name":"Monitor Lennox Thermotat","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"f902dc8c.c0f5"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1600,"y":60,"wires":[{"id":"c72595c7.770458","port":0}]}},{"id":"1e603513.011bdb","type":"subflow","name":"Monitor Game Room Floor Lamp","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":520,"wires":[{"id":"26ca9d2e.33c5d2"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1720,"y":460,"wires":[{"id":"5ac581c6.58c4","port":0}]}},{"id":"89f52889.bf1478","type":"subflow","name":"Monitor Aqara Button","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":60,"y":80,"wires":[{"id":"6ccdb89c.8350f8"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1620,"y":60,"wires":[{"id":"83a32fad.6930f","port":0}]}},{"id":"4e2f0c22.b816c4","type":"subflow","name":"Monitor Corner Light","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":20,"y":80,"wires":[{"id":"427dc421.8d781c"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1580,"y":60,"wires":[{"id":"b75b2fa.6ca99d","port":0}]}},{"id":"5364e86b.44e3a8","type":"subflow","name":"Montitor Office Echo","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"c2484670.ff6178"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1620,"y":60,"wires":[{"id":"14631d22.b13213","port":0}]}},{"id":"ae851807.40c0e8","type":"subflow","name":"Monitor Mike's Bedside Lamp","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"c7c61ee1.9dfe9"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1620,"y":60,"wires":[{"id":"9b8f6dcd.fae7e","port":0}]}},{"id":"92d72719.56bd38","type":"subflow","name":"Monitor Mike's Credenza Light","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"8bb21bf9.9058f8"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1580,"y":60,"wires":[{"id":"1e943c1a.24d994","port":0}]}},{"id":"fd34e084.87e19","type":"subflow","name":"Monitor Table Lamp","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"c4868b86.653628"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1580,"y":60,"wires":[{"id":"4079ef1a.ff235","port":0}]}},{"id":"e58eb536.40cf18","type":"subflow","name":"Monitor Mike's iPad","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"e52e72d9.77dbd"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1580,"y":60,"wires":[{"id":"a079c786.6808f8","port":0}]}},{"id":"390b8414.317d5c","type":"subflow","name":"Monitor Watch Uverse","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"85febe11.1b0c4"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1580,"y":60,"wires":[{"id":"1f0266a0.281ff9","port":0}]}},{"id":"9d03767a.9b0288","type":"subflow","name":"Monitor Master Fan","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"2cf48409.d5206c"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1560,"y":60,"wires":[{"id":"3d6e8f0c.8aaad","port":0}]}},{"id":"f6aca0d2.59336","type":"subflow","name":"Monitor Light Overhead","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"5170d88d.798268"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1560,"y":60,"wires":[{"id":"d89c84bb.66d498","port":0}]}},{"id":"d2615560.b868a8","type":"subflow","name":"Monitor Cube 1","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"bec0b04e.e9c99"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1560,"y":60,"wires":[{"id":"eef7f9d4.4eaf48","port":0}]}},{"id":"a73af62e.c418b8","type":"subflow","name":"Monitor All Hubitat Devices","info":"","category":"","in":[{"x":40,"y":40,"wires":[{"id":"7ec6233c.30bd0c"}]}],"out":[],"env":[],"color":"#DDAA99","status":{"x":1560,"y":180,"wires":[{"id":"377f4ebf.3750b2","port":0}]}},{"id":"bb5b26fe.1fc278","type":"gauth","z":""},{"id":"2f23f49.924a10c","type":"ui_base","theme":{"name":"theme-light","lightTheme":{"default":"#0094CE","baseColor":"#0094CE","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif","edited":true,"reset":false},"darkTheme":{"default":"#097479","baseColor":"#097479","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif","edited":false},"customTheme":{"name":"Untitled Theme 1","default":"#4B7930","baseColor":"#4B7930","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"},"themeState":{"base-color":{"default":"#0094CE","value":"#0094CE","edited":false},"page-titlebar-backgroundColor":{"value":"#0094CE","edited":false},"page-backgroundColor":{"value":"#fafafa","edited":false},"page-sidebar-backgroundColor":{"value":"#ffffff","edited":false},"group-textColor":{"value":"#1bbfff","edited":false},"group-borderColor":{"value":"#ffffff","edited":false},"group-backgroundColor":{"value":"#ffffff","edited":false},"widget-textColor":{"value":"#111111","edited":false},"widget-backgroundColor":{"value":"#0094ce","edited":false},"widget-borderColor":{"value":"#ffffff","edited":false},"base-font":{"value":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"}},"angularTheme":{"primary":"indigo","accents":"blue","warn":"red","background":"grey"}},"site":{"name":"Mike's Production Node-RED Dashboard","hideToolbar":"false","allowSwipe":"false","lockMenu":"true","allowTempTheme":"true","dateFormat":"DD/MM/YYYY","sizes":{"sx":48,"sy":48,"gx":6,"gy":6,"cx":6,"cy":6,"px":0,"py":0}}},{"id":"3ce7ceed.69be02","type":"homekit-bridge","z":"","bridgeName":"Mike","pinCode":"121-01-707","port":"","allowInsecureRequest":false,"manufacturer":"TMS Industries","model":"1","serialNo":"1","customMdnsConfig":false,"mdnsMulticast":true,"mdnsInterface":"","mdnsPort":"","mdnsIp":"","mdnsTtl":"","mdnsLoopback":true,"mdnsReuseAddr":true,"allowMessagePassthrough":true},{"id":"a5bf81ee.27852","type":"mqtt-broker","z":"","name":"MQTT Docker","broker":"192.168.86.3","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"d417815c.8097e","type":"hb-conf","z":"","username":"121-01-707"},{"id":"adb4e9b8.8beee8","type":"gauth","z":""},{"id":"430b7850.44c1a8","type":"influxdb","z":"","hostname":"127.0.0.1","port":"8086","protocol":"http","database":"MikeTestFromNR","name":"","usetls":false,"tls":""},{"id":"55e4481a.722098","type":"hubitat config","z":"","name":"Main Hub (110) Maker Production Node Red","usetls":false,"host":"192.168.86.110","port":"80","token":"79eb990f-05f6-4f92-b9ee-ff39db572caf","appId":"646","nodeRedServer":"http://192.168.86.3:1980","webhookPath":"/hubitat/prodwebhook/"},{"id":"b862b36a.1a11d","type":"influxdb","z":"","hostname":"127.0.0.1","port":"8086","protocol":"http","database":"MikeTestFromNR","name":"","usetls":false,"tls":""},{"id":"18f340fe.a70a3f","type":"ui_group","z":"","name":"Control","tab":"429e5ab.771c5a4","order":1,"disp":false,"width":"27","collapse":false},{"id":"8abf2e02.5fe9f","type":"ui_group","name":"Group 5","tab":"d5ea0f3.4753bf","order":4,"disp":true,"width":6},{"id":"60c16cd3.e9d974","type":"ui_spacer","name":"spacer","group":"8abf2e02.5fe9f","order":2,"width":1,"height":1},{"id":"9e60bee8.9eb17","type":"ui_spacer","name":"spacer","group":"8abf2e02.5fe9f","order":3,"width":1,"height":1},{"id":"429e5ab.771c5a4","type":"ui_tab","z":"","name":"Radar","icon":"dashboard","order":1,"disabled":false,"hidden":false},{"id":"4baf1468.abb01c","type":"ui_group","z":"","name":"Airport Filters","tab":"429e5ab.771c5a4","order":4,"disp":true,"width":"6","collapse":true},{"id":"9cbb54f5.392db8","type":"ui_group","z":"","name":"Aircraft Filters","tab":"429e5ab.771c5a4","order":5,"disp":true,"width":"6","collapse":true},{"id":"c7810244.5e40a","type":"ui_group","z":"","name":"Map","tab":"429e5ab.771c5a4","order":2,"disp":false,"width":"17","collapse":false},{"id":"a68c0105.e9c7e","type":"ui_tab","z":"","name":"Table Holder","icon":"dashboard","order":6,"disabled":false,"hidden":false},{"id":"e298b809.c3c2f8","type":"ui_group","z":"","name":"Before/After Modification","tab":"a68c0105.e9c7e","order":2,"disp":true,"width":"22","collapse":true},{"id":"1a94010f.a3b71f","type":"ui_tab","z":"","name":"Home","icon":"dashboard","disabled":false,"hidden":false},{"id":"2a128af6.d72c46","type":"ui_group","z":"","name":"After Modification","tab":"a68c0105.e9c7e","order":3,"disp":false,"width":"22","collapse":false},{"id":"602d7c75.e52ed4","type":"ui_group","z":"","name":"Radar Console","tab":"429e5ab.771c5a4","order":3,"disp":true,"width":"6","collapse":false},{"id":"a4570963.5547f8","type":"ui_group","z":"","name":"Group 3","tab":"a68c0105.e9c7e","order":1,"disp":false,"width":"3","collapse":false},{"id":"820d7886.9debb8","type":"ui_spacer","name":"spacer","group":"a4570963.5547f8","order":6,"width":"3","height":"6"},{"id":"5455b6b3.8080f8","type":"ui_spacer","name":"spacer","group":"602d7c75.e52ed4","order":3,"width":"6","height":1},{"id":"f2650446.2a56d8","type":"function","z":"db3a486d.c20478","name":"Step","func":"var x = env.get(\"Step\"); \nflow.set(\"$parent.Step\", x);\n\nmsg.payload = \"Your brightness increment has been set to: \" + x;\n\nreturn msg;","outputs":1,"noerr":0,"x":510,"y":80,"wires":[[]]},{"id":"7115886d.01af18","type":"function","z":"250ecbce.340264","name":"Set Read Col","func":"//Read subflow input variables\nif (env.get(\"OverrideEnvVariables\")){\n    //Put inputs and read values into msg properties to be visible downstream\n    msg.sheet = msg.SpreadsheetID;\n    msg.tab = msg.Tab;\n    msg.cellstart = msg.ColStart + msg.MinRow;\n    msg.cellend = msg.ColEnd + msg.MaxRow;\n    msg.targetrange = msg.tab+\"!\"+msg.cellstart+\":\"+msg.cellend\n    msg.topic = msg.targetrange\n    delete msg.Tab\n    delete msg.SpreadsheetID\n    delete msg.ColStart\n    delete msg.ColEnd\n    delete msg.MinRow\n    delete msg.MaxRow\n    delete msg.IgnoreEnvVar\n}else if (msg.IgnoreEnvVar) {\n    //Put inputs and read values into msg properties to be visible downstream\n    msg.sheet = msg.SpreadsheetID;\n    msg.tab = msg.Tab;\n    msg.cellstart = msg.ColStart + msg.MinRow;\n    msg.cellend = msg.ColEnd + msg.MaxRow;\n    msg.targetrange = msg.tab+\"!\"+msg.cellstart+\":\"+msg.cellend\n    msg.topic = msg.targetrange\n    delete msg.Tab\n    delete msg.SpreadsheetID\n    delete msg.ColStart\n    delete msg.ColEnd\n    delete msg.MinRow\n    delete msg.MaxRow\n    delete msg.IgnoreEnvVar\n}else{\n    var ColStart = env.get(\"ColStart\");\n    var ColEnd = env.get(\"ColEnd\");\n    var FirstRow = env.get(\"MinRow\");\n    var LastRow = env.get(\"MaxRow\");\n    //Put inputs and read values into msg properties to be visible downstream\n    msg.sheet = env.get(\"Spreadsheet ID\");\n    msg.tab = env.get(\"TabName\");\n    msg.cellstart = ColStart + FirstRow\n    msg.cellend = ColEnd + LastRow\n    msg.targetrange = msg.tab+\"!\"+msg.cellstart+\":\"+msg.cellend\n    msg.topic = msg.targetrange\n}\nreturn msg;","outputs":1,"noerr":0,"x":150,"y":20,"wires":[["f19af657.19fe88","cdae2d80.8d615"]]},{"id":"f19af657.19fe88","type":"GSheet","z":"250ecbce.340264","creds":"bb5b26fe.1fc278","method":"get","action":"","sheet":"","cells":"","name":"Read Input from GSheet","x":410,"y":20,"wires":[["b11f8aff.9aee68"]]},{"id":"8740490b.77e458","type":"comment","z":"250ecbce.340264","name":"Error","info":"","x":990,"y":20,"wires":[]},{"id":"6af56d08.1ec794","type":"comment","z":"250ecbce.340264","name":"Last Populated Row","info":"","x":1030,"y":100,"wires":[]},{"id":"be5dfe12.c99f2","type":"function","z":"250ecbce.340264","name":"Work In Progress","func":"\n/*\n * Actual good responses\n */\nmsg.LastPopulatedRow = msg.payload.length + env.get(\"MinRow\") - 1\nmsg.FirstEmptyRow = msg.LastPopulatedRow + 1\n/*\n * Placeholder/Fake Testing variables\n */\nvar colCount = 1 //number of columns wide from the data retrieved. This will eventually be replace by logic that loops through array find the max width for any given row\nvar sheetdata = msg.payload //this is the data that is returned from Google that will then be examined\n\n\n// Deletable msg.arraysize = msg.payload.length\nfor (index = 0; index < sheetdata.length; index++) {\n    if (Array.isArray(sheetdata[index])){\n        colCount = Math.max(colCount, sheetdata[index].length)\n        // Deletable msg.arrayfound = sheetdata[index].length\n    }\n    // Deletable msg.arrayfound = sheetdata[1].length\n} \n//deletable var fCol = \"aa\" // Test input column that will later be removed leaving in place\n/*\n *Column response calculation variables\n */\nvar fCol = env.get(\"ColStart\")\nvar fColTotal = 0 //to hold the column number\nvar nCol = \"\"   //nCol is new column\nvar lCol = \"\"   //lCol is last column in the range (to be populated from the actual Gsheet calls data)\n// Deletable var fCharFCol = fCol.charCodeAt(fCol.length - 1)   // fCharFCol is the final character of the first column in the range  \n// Deletable var fCol = env.get(\"ColStart\")     //fCol is the first column moved into a shorter local variable \n// Deletable var fColNum = fCol.charCodeAt(fCol.length - 1) //thecchar number of the last character of the column\n// Deletable var replacementNum = fColNum + colCount - 1 //the char of the replacement letter that will turn the first populated column in to the last column\n// Deletable var excess = 0 //this will be used to figure out how far beyond the Z or z the char num is\nfCol = fCol.toUpperCase()\n\n/*\n * validate fCol (done)\n */\nvar validStartCol = false\nvalidStartCol = ((fCol.length == 1) ||\n                ((fCol.substr(0, 1).charCodeAt(0) - 64) < 9) ||\n                (((fCol.substr(0, 1).charCodeAt(0) - 64) == 9) && ((fCol.substr(1, 1).charCodeAt(0) - 64) <= 22)))\n/*\n *Column response calculations\n */\nswitch (fCol.length) {\n    case 1:\n        fColTotal = (fCol.substr(0, 1).charCodeAt(0) - 64)\n        fColTotal += colCount - 1\n        break\n    case 2:\n        fColTotal = (fCol.substr(1, 1).charCodeAt(0) - 64) + 26 * (fCol.substr(0, 1).charCodeAt(0) - 64)\n        fColTotal += colCount - 1\n        break\n    default:\n        fColTotal = -1\n}\n//Last Populated Column and First Empty Column calculation\nif ((fColTotal <= 25) && (fColTotal >= 1)) {\n    lCol = String.fromCharCode(fColTotal+64)\n    nCol = String.fromCharCode(fColTotal+65)\n} else if (fColTotal == 26) {\n    lCol = \"Z\"\n    nCol = \"AA\"\n} else if (fColTotal >= 27) {\n    lCol = String.fromCharCode((Math.floor(fColTotal / 26)) + 64) + String.fromCharCode((fColTotal % 26) + 64)\n    nCol = String.fromCharCode((Math.floor(fColTotal / 26)) + 64) + String.fromCharCode((fColTotal % 26) + 65)\n} else if (fColTotal == -1) {\n    lCol = \"Error\"\n    nCol = \"Error\"\n    //Probably worth putting real error here, but deferred\n} else if (fColTotal == 256) {\n    lCol = \"IV\"\n    nCol = \"None\"\n}\nmsg.LastPopulatedCol = lCol\nmsg.FirstEmptyCol = nCol\nmsg.SpreadsheetArray = msg.payload\nreturn msg;","outputs":1,"noerr":0,"x":370,"y":560,"wires":[["9cabee41.a056b","d91779c2.896ea8","46c25d0f.563a44","893d102e.47b92","c62b3213.e206a","c9c7210d.d881f"]]},{"id":"95b7965d.e4b428","type":"comment","z":"250ecbce.340264","name":"First Empty Row","info":"","x":1020,"y":180,"wires":[]},{"id":"a57014a2.3e04b8","type":"comment","z":"250ecbce.340264","name":"Last Populated Column","info":"","x":1040,"y":260,"wires":[]},{"id":"485298fb.4f6858","type":"comment","z":"250ecbce.340264","name":"First Empty Column","info":"","x":1030,"y":340,"wires":[]},{"id":"a7b5845f.22c4d8","type":"comment","z":"250ecbce.340264","name":"Spreadsheet Array","info":"","x":1030,"y":420,"wires":[]},{"id":"17f3bcf9.9a03e3","type":"comment","z":"250ecbce.340264","name":"Full Data","info":"","x":1000,"y":500,"wires":[]},{"id":"ad16bbb.aa68a48","type":"comment","z":"250ecbce.340264","name":"Full Data with Inputs","info":"","x":1030,"y":580,"wires":[]},{"id":"9cabee41.a056b","type":"change","z":"250ecbce.340264","name":"Leave Outputs","rules":[{"t":"delete","p":"topic","pt":"msg"},{"t":"delete","p":"tab","pt":"msg"},{"t":"delete","p":"sheet","pt":"msg"},{"t":"delete","p":"cellstart","pt":"msg"},{"t":"delete","p":"cellend","pt":"msg"},{"t":"delete","p":"targetrange","pt":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":740,"y":540,"wires":[[]]},{"id":"d91779c2.896ea8","type":"change","z":"250ecbce.340264","name":"Leave Last Populated Row","rules":[{"t":"delete","p":"topic","pt":"msg"},{"t":"delete","p":"tab","pt":"msg"},{"t":"delete","p":"sheet","pt":"msg"},{"t":"delete","p":"cellstart","pt":"msg"},{"t":"delete","p":"cellend","pt":"msg"},{"t":"delete","p":"targetrange","pt":"msg"},{"t":"delete","p":"FirstEmptyRow","pt":"msg"},{"t":"delete","p":"LastPopulatedCol","pt":"msg"},{"t":"delete","p":"FirstEmptyCol","pt":"msg"},{"t":"delete","p":"SpreadsheetArray","pt":"msg"},{"t":"set","p":"payload","pt":"msg","to":"LastPopulatedRow","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":780,"y":140,"wires":[[]]},{"id":"46c25d0f.563a44","type":"change","z":"250ecbce.340264","name":"Leave First Empty Row","rules":[{"t":"delete","p":"topic","pt":"msg"},{"t":"delete","p":"tab","pt":"msg"},{"t":"delete","p":"sheet","pt":"msg"},{"t":"delete","p":"cellstart","pt":"msg"},{"t":"delete","p":"cellend","pt":"msg"},{"t":"delete","p":"targetrange","pt":"msg"},{"t":"delete","p":"LastPopulatedRow","pt":"msg"},{"t":"delete","p":"LastPopulatedCol","pt":"msg"},{"t":"delete","p":"FirstEmptyCol","pt":"msg"},{"t":"delete","p":"SpreadsheetArray","pt":"msg"},{"t":"set","p":"payload","pt":"msg","to":"FirstEmptyRow","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":770,"y":220,"wires":[[]]},{"id":"893d102e.47b92","type":"change","z":"250ecbce.340264","name":"Leave Last Populated Column","rules":[{"t":"delete","p":"topic","pt":"msg"},{"t":"delete","p":"tab","pt":"msg"},{"t":"delete","p":"sheet","pt":"msg"},{"t":"delete","p":"cellstart","pt":"msg"},{"t":"delete","p":"cellend","pt":"msg"},{"t":"delete","p":"targetrange","pt":"msg"},{"t":"delete","p":"LastPopulatedRow","pt":"msg"},{"t":"delete","p":"FirstEmptyRow","pt":"msg"},{"t":"delete","p":"FirstEmptyCol","pt":"msg"},{"t":"delete","p":"SpreadsheetArray","pt":"msg"},{"t":"set","p":"payload","pt":"msg","to":"LastPopulatedCol","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":790,"y":300,"wires":[[]]},{"id":"c62b3213.e206a","type":"change","z":"250ecbce.340264","name":"Leave First Empty Column","rules":[{"t":"delete","p":"topic","pt":"msg"},{"t":"delete","p":"tab","pt":"msg"},{"t":"delete","p":"sheet","pt":"msg"},{"t":"delete","p":"cellstart","pt":"msg"},{"t":"delete","p":"cellend","pt":"msg"},{"t":"delete","p":"targetrange","pt":"msg"},{"t":"delete","p":"LastPopulatedRow","pt":"msg"},{"t":"delete","p":"FirstEmptyRow","pt":"msg"},{"t":"delete","p":"LastPopulatedCol","pt":"msg"},{"t":"delete","p":"SpreadsheetArray","pt":"msg"},{"t":"set","p":"payload","pt":"msg","to":"FirstEmptyCol","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":780,"y":380,"wires":[[]]},{"id":"c9c7210d.d881f","type":"change","z":"250ecbce.340264","name":"Leave Spreadsheet Array","rules":[{"t":"delete","p":"topic","pt":"msg"},{"t":"delete","p":"tab","pt":"msg"},{"t":"delete","p":"sheet","pt":"msg"},{"t":"delete","p":"cellstart","pt":"msg"},{"t":"delete","p":"cellend","pt":"msg"},{"t":"delete","p":"targetrange","pt":"msg"},{"t":"delete","p":"LastPopulatedRow","pt":"msg"},{"t":"delete","p":"FirstEmptyRow","pt":"msg"},{"t":"delete","p":"LastPopulatedCol","pt":"msg"},{"t":"delete","p":"FirstEmptyCol","pt":"msg"},{"t":"set","p":"payload","pt":"msg","to":"SpreadsheetArray","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":770,"y":460,"wires":[[]]},{"id":"b11f8aff.9aee68","type":"function","z":"250ecbce.340264","name":"Cancel Timeout?","func":"msg.reset = true\nreturn msg;","outputs":1,"noerr":0,"x":170,"y":140,"wires":[["fa582a24.4565e8","eb587bd4.e05c58"]]},{"id":"fa582a24.4565e8","type":"trigger","z":"250ecbce.340264","op1":"","op2":"timeout","op1type":"nul","op2type":"str","duration":"10","extend":true,"units":"s","reset":"","bytopic":"all","name":"Watchdog","x":480,"y":140,"wires":[["893d102e.47b92","d91779c2.896ea8","c62b3213.e206a","c9c7210d.d881f","9cabee41.a056b"]]},{"id":"cdae2d80.8d615","type":"change","z":"250ecbce.340264","name":"","rules":[{"t":"set","p":"timeout","pt":"msg","to":"true","tot":"bool"}],"action":"","property":"","from":"","to":"","reg":false,"x":460,"y":100,"wires":[["fa582a24.4565e8"]]},{"id":"eb587bd4.e05c58","type":"change","z":"250ecbce.340264","name":"","rules":[{"t":"delete","p":"reset","pt":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":370,"y":500,"wires":[["be5dfe12.c99f2"]]},{"id":"33cf6aac.eabb16","type":"catch","z":"250ecbce.340264","name":"Catch and Relay Errors","scope":null,"uncaught":false,"x":760,"y":60,"wires":[[]]},{"id":"f9ce45cd.70d568","type":"rbe","z":"76e3605b.0e6e7","name":"Changing Ping?","func":"rbe","gap":"","start":"","inout":"out","property":"PingStatus","x":860,"y":100,"wires":[["23c83a68.f57316"]]},{"id":"54bcf469.64fc1c","type":"file","z":"76e3605b.0e6e7","name":"Append to NetUpPerpetual","filename":"","appendNewline":true,"createDir":false,"overwriteFile":"false","encoding":"none","x":940,"y":220,"wires":[[]]},{"id":"800cd2f0.7e6fc","type":"simpletime","z":"76e3605b.0e6e7","name":"Populate Time Messages","x":150,"y":240,"wires":[["2224f154.3db68e"]]},{"id":"2224f154.3db68e","type":"change","z":"76e3605b.0e6e7","name":"Create Log Start line with Formated Date","rules":[{"t":"set","p":"payload","pt":"msg","to":"myyear\t&\"-\"&\tmymonthn\t&\"-\"&\tmydom\t&\" \"&\tmyhourpm\t&\":\"&\tmyminute\t&\":\"&\tmysecond\t&\".\"&\tmymillis\t&\" \"&\tmypm\t&\"          Log Start\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":440,"y":240,"wires":[["54bcf469.64fc1c","b832f02e.6f68d"]]},{"id":"7b2187a9.5139d8","type":"change","z":"76e3605b.0e6e7","name":"Get dir/file destination from Flow context","rules":[{"t":"set","p":"filename","pt":"msg","to":"$flowContext('OutputDirectory') &\tpingtarget & \".txt\"","tot":"jsonata"},{"t":"set","p":"pingtime","pt":"msg","to":"payload","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":580,"y":140,"wires":[["833fda41.17b198","41c7aa38.91a0b4"]]},{"id":"f1a77239.f0493","type":"comment","z":"76e3605b.0e6e7","name":"JSONata Flow context","info":"myyear&\"-\"&mymonthn&\"-\"&mydom&\" \"&myhourpm &\":\"&myminute&\":\"&mysecond&\n\".\"&mymillis\n","x":500,"y":100,"wires":[]},{"id":"38e74b76.ec65d4","type":"change","z":"76e3605b.0e6e7","name":"Failure Start time","rules":[{"t":"set","p":"payload","pt":"msg","to":"","tot":"date"}],"action":"","property":"","from":"","to":"","reg":false,"x":150,"y":960,"wires":[["b89a96f9.f64b88","f6326890.3b8ae8","148d89ae.8a8376"]]},{"id":"c2fdf835.927178","type":"change","z":"76e3605b.0e6e7","name":"Failure End time","rules":[{"t":"set","p":"payload","pt":"msg","to":"","tot":"date"}],"action":"","property":"","from":"","to":"","reg":false,"x":580,"y":1000,"wires":[["b89a96f9.f64b88"]]},{"id":"6b07ffa.4eb28","type":"calculator","z":"76e3605b.0e6e7","name":"Calculate the difference","inputMsgField":"payload","outputMsgField":"payload","operation":"sub","constant":"","x":610,"y":1040,"wires":[["94dfb9b5.59e1a8"]]},{"id":"b89a96f9.f64b88","type":"join","z":"76e3605b.0e6e7","name":"Get start and end times","mode":"custom","build":"array","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":170,"y":1040,"wires":[["6b07ffa.4eb28"]]},{"id":"f6326890.3b8ae8","type":"delay","z":"76e3605b.0e6e7","name":"","pauseType":"random","timeout":"1300","timeoutUnits":"milliseconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"milliseconds","drop":false,"x":400,"y":1000,"wires":[["c2fdf835.927178"]]},{"id":"94dfb9b5.59e1a8","type":"calculator","z":"76e3605b.0e6e7","name":"Multiply by -1 to get positive duration","inputMsgField":"payload","outputMsgField":"payload","operation":"mult","constant":"-1","x":210,"y":1080,"wires":[["2ea97499.5a805c"]]},{"id":"2ea97499.5a805c","type":"function","z":"76e3605b.0e6e7","name":"Translate Duration Function","func":"/* \n * Create Variables\n * \n */\n        var milliseconds = msg.payload;\n        var years, weeks, days, hours, minutes, seconds, millis;\n    //creating 2 string versions of each of the durations that can be in the middle of a 1:01:01.001 duration \n    //minstr is the always 2 character one\n    //lminstr is the version that can be 1 or more characers that will be used when that part is the portion of the duration\n        var minstr, secstr, millistr, lminstr, lsecstr, lmillistr;\n        var whichcomponents, readableduration;\n\n/*\n * Calculate the numbers for the subcomponents\n * \n */\n    //by getting the remainder when dividing by 1000\n    //it leaves just the fraction of milliseconds\n        millis = milliseconds % 1000;\n    //the floor function drops the decimal portion\n    //returning the non fractional seconds\n        seconds = Math.floor(milliseconds / 1000);\n    //the floor function drops the decimal portion\n    //returning the non fractional minutes\n        minutes = Math.floor(seconds / 60);\n    //Once the minutes have been calculated, then\n    //the seconds is replaced with those seconds not\n    //accounted for by the minutes\n        seconds = seconds % 60;\n    //The same sequence as used for minutes/seconds\n    //then used to calulate minutes, hours, dayss, weeks, years\n\n        hours = Math.floor(minutes / 60);\n        minutes = minutes % 60;\n        days = Math.floor(hours / 24);\n        hours = hours % 24;\n        weeks = Math.floor(days / 7)\n        days = days % 7;\n        years = Math.floor(days / 365.25)\n        weeks = weeks % 52;\n\n/*\n * Put the subcomponents into msg payloads for easy access by later nodes\n *\n */\n        msg.years = years\n        msg.weeks = weeks\n        msg.days = days\n        msg.hours = hours\n        msg.minutes = minutes\n        msg.seconds = seconds\n        msg.millis = millis\n \n\n/*\n * create the string verssion for the subcomponents\n */\n    //milliseconds\n        lmillistr = millis.toString();\n        //put padding on the milliseconds so that 1 ms shows as .001 and not .1 when concatenated after a decimal\n            millistr = millis.toString().padStart(3, \"0\");\n    //seconds\n        lsecstr = seconds.toString();\n        //put padding on the seconds so that 1 s shows as :01.000 and not :1.000 when concatenated after a dividing :\n            secstr = lsecstr.padStart(2, \"0\");\n    //minutes\n        lminstr = minutes.toString();\n        //put padding on the minutes so that 1 m shows as :01:00.000 and not :1:00.000 when concatenated after a dividing :\n            minstr = lminstr.padStart(2, \"0\");\n\n/*\n * Build output based on largest significant populated unit\n * The general rule is to include in the output the largest unit (years, weeks, days, etc) followed by the next 2\n * smaller units if the happen to be populated\n */\n    readableduration =\"\"\n//years populated\n    if (years !== 0) { \n        if (days !== 0) {\n            if (days === 1) {\n                readableduration = \" \".concat(days.toString(), \" Day\", readableduration)\n            } else {\n                readableduration = \" \".concat(days.toString(), \" Days\", readableduration)\n            }\n        }\n        if (weeks !== 0) {\n            if (weeks === 1) {\n                readableduration = \" \".concat(weeks.toString(), \" Week\", readableduration)\n            } else {\n                readableduration = \" \".concat(weeks.toString(), \" Weeks\", readableduration)\n            }\n        }\n        if (years === 1) {\n            readableduration = years.toString().concat(\" Year\", readableduration)\n        } else {\n            readableduration = years.toString().concat(\" Years\", readableduration)\n        }\n//weeks populated\n    } else if (weeks !== 0) {\n        if (hours !== 0) {\n            if (hours === 1) {\n                readableduration = \" \".concat(hours.toString(), \" Hour\", readableduration)\n            } else {\n                readableduration = \" \".concat(hours.toString(), \" Hours\", readableduration)\n            }\n        }\n        if (days !== 0) {\n            if (weeks === 1) {\n                readableduration = \" \".concat(days.toString(), \" Day\", readableduration)\n            } else {\n                readableduration = \" \".concat(days.toString(), \" Days\", readableduration)\n            }\n        }\n        if (weeks === 1) {\n            readableduration = weeks.toString().concat(\" Week\", readableduration)\n        } else {\n            readableduration = weeks.toString().concat(\" Weeks\", readableduration)\n        }\n//days populated\n    } else if (days !== 0) {\n        if ((minutes !== 0) && (hours !== 0)) { //If both are non-zero then 1:01 format. If only 1 then either 2 hours or 1 minute\n            if (minutes !== 0) {\n                readableduration = \":\".concat(minstr, readableduration)\n            }\n            if (hours !== 0) {\n                readableduration = \" \".concat(hours.toString(), readableduration)\n            } else {\n                readableduration = \" 0\".concat(readableduration)\n            }\n        } else {\n            if (minutes === 1) {\n                readableduration = \" 1 Minute\".concat(readableduration)\n            } else if (minutes > 1) {\n                readableduration = \" \".concat(lminstr,\" Minutes\", readableduration)\n            } else if (hours === 1) {\n                readableduration = \" 1 Hour\".concat(readableduration)\n            } else {\n                if (hours >1) {\n                    readableduration = \" \".concat(hours.toString(),\" Hours\", readableduration)\n                }\n            }\n        }\n        if (days === 1) {\n            readableduration = days.toString().concat(\" Day\", readableduration)\n        } else {\n            readableduration = days.toString().concat(\" Days\", readableduration)\n        }\n//hours populated\n    } else if (hours !== 0) {\n        if ((minutes !== 0) || (seconds !== 0)) { //End result h Hours or h:mm:ss\n            readableduration = hours.toString().concat(\":\", minstr, \":\", secstr, readableduration)\n        } else {\n            if (hours === 1) {\n                readableduration = \"1 Hour\"\n            } else {\n                readableduration = hours.toString().concat(\" Hours\", readableduration)\n            }\n        }\n//minutes populated\n    } else if (minutes !== 0) { //End result m Minutes or mm:ss.MMM\n        if (seconds !== 0 || millis !== 0) { //End result h Hours or h:mm:ss\n            readableduration = lminstr.concat(\":\", secstr, \".\", millistr, readableduration)\n        } else {\n            if (minutes === 1) {\n                readableduration = \"1 Minute\".concat( readableduration)\n            } else {\n                readableduration = lminstr.concat(\" Minutes\", readableduration)\n            }\n        }\n//seconds populated\n    } else if (seconds !== 0) {\n        if (millis !== 0) { //End result s Seconds or s.MMM\n            readableduration = lsecstr.concat(\".\", millistr, \" Seconds\", readableduration)\n        } else {\n            if (seconds === 1) {\n                readableduration = \"1 Second\".concat( readableduration)\n            } else {\n                readableduration = lsecstr.concat(\" Seconds\", readableduration)\n            }\n        }\n//milliseconds populated\n    } else if (millis !== 0) {\n        if (millis !== 1) {\n            readableduration = lmillistr.concat(\" Milliseconds\", readableduration)\n        } else {\n            readableduration = \"1 Millisecond\".concat( readableduration)\n        }\n    } else {\n        readableduration = \"0\"\n    }\n    msg.years = years\n    msg.weeks = weeks\n    msg.days = days\n    msg.hours = hours\n    msg.minutes = minutes\n    msg.seconds = seconds\n    msg.millis = millis\n    msg.payload = readableduration\n    return msg;","outputs":1,"noerr":0,"x":500,"y":1080,"wires":[["82c9edda.537d7"]]},{"id":"408b8df6.b9b044","type":"join","z":"76e3605b.0e6e7","name":"Join the failure start time with the duration for output","mode":"custom","build":"string","property":"payload","propertyType":"msg","key":"topic","joiner":"","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1070,"y":960,"wires":[[]]},{"id":"82c9edda.537d7","type":"function","z":"76e3605b.0e6e7","name":"Pad the text duration to 24 characters","func":"msg.payload = msg.payload.padStart(24)\nreturn msg;","outputs":1,"noerr":0,"x":801,"y":1080,"wires":[["408b8df6.b9b044"]]},{"id":"148d89ae.8a8376","type":"change","z":"76e3605b.0e6e7","name":"Create Log Start line with Formated Date","rules":[{"t":"set","p":"payload","pt":"msg","to":"myyear\t&\"-\"&\tmymonthn\t&\"-\"&\tmydom\t&\" \"&\tmyhourpm\t&\":\"&\tmyminute\t&\":\"&\tmysecond\t&\".\"&\tmymillis\t&\" \"&\tmypm","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":660,"y":960,"wires":[["408b8df6.b9b044"]]},{"id":"6e44be2e.917c7","type":"function","z":"76e3605b.0e6e7","name":"Include Ping Time if Successful","func":"if (isNaN(msg.pingtime)) {\n    msg.payload = msg.CurrentTime.padEnd(28,\" \") + msg.PingStatus.padEnd(20, \" \")\n} else {\nmsg.payload = msg.CurrentTime.padEnd(28,\" \") + msg.PingStatus.padEnd(9, \" \") + msg.pingtime.toString().padEnd(11,\" \") + msg.Min.toString().padEnd(11,\" \") + msg.Max.toString().padEnd(11,\" \") + msg.RollingAverage.toString().padEnd(11,\" \")\n}\nreturn msg;","outputs":1,"noerr":0,"x":950,"y":460,"wires":[["54bcf469.64fc1c"]]},{"id":"23c83a68.f57316","type":"simpletime","z":"76e3605b.0e6e7","name":"Populate Time Messages","x":1070,"y":60,"wires":[["8ac84738.ad8f18"]]},{"id":"8ac84738.ad8f18","type":"change","z":"76e3605b.0e6e7","name":"Formated Date for ping log entry","rules":[{"t":"set","p":"CurrentTime","pt":"msg","to":"myyear\t&\"-\"&\tmymonthn\t&\"-\"&\tmydom\t&\" \"&\tmyhourpm\t&\":\"&\tmyminute\t&\":\"&\tmysecond\t&\".\"&\tmymillis\t&\" \"&\tmypm","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":1050,"y":160,"wires":[["6e44be2e.917c7"]]},{"id":"833fda41.17b198","type":"rbe","z":"76e3605b.0e6e7","name":"Only write headers first time process is initiated","func":"rbe","gap":"","start":"","inout":"out","property":"filename","x":220,"y":200,"wires":[["3a6e32fc.4a089e"]]},{"id":"41c7aa38.91a0b4","type":"delay","z":"76e3605b.0e6e7","name":"","pauseType":"delay","timeout":"1","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":700,"y":60,"wires":[["f9ce45cd.70d568","48434c5b.387c44","e6f86ef9.f3af6"]]},{"id":"7c6b7df4.a02714","type":"function","z":"76e3605b.0e6e7","name":"Update Flow Results Based on Latest Input","func":"var CurrentCount = flow.get(\"Count\")\nif (!isNaN(msg.payload)) {\n    var next = Number(msg.payload)\n    if (next === 0) {\n    } else {\n        var CurrentAvg = flow.get(\"RollingAverage\")\n        var CurrentMax = flow.get(\"Max\")\n        var CurrentMin = flow.get(\"Min\")\n        var OldMax = CurrentMax\n        var OldMin = CurrentMin\n        if (CurrentCount === 0) {\n            CurrentAvg = next;\n            CurrentMin = next;\n            CurrentMax = next;\n            CurrentCount = CurrentCount + 1\n        } else {\n            oldtotal = CurrentAvg * CurrentCount\n            newtotal = next + oldtotal\n            CurrentCount = CurrentCount + 1\n            CurrentAvg = newtotal / CurrentCount\n            CurrentMax = Math.max(next, CurrentMax)\n            if (CurrentMax != OldMax) {\n                msg.NewMax = true\n            }\n            CurrentMin = Math.min(next, CurrentMin)\n            if (CurrentMin != OldMin) {\n                msg.NewMin = true\n            }\n        }\n        flow.set(\"RollingAverage\", CurrentAvg);\n        flow.set(\"Max\", CurrentMax);\n        flow.set(\"Min\", CurrentMin);\n        flow.set(\"Count\", CurrentCount);\n        msg.next = next\n        msg.RollingAverage = CurrentAvg;\n        msg.Max = CurrentMax;\n        msg.Min = CurrentMin;\n        msg.Count = CurrentCount;\n        return msg;\n    }\n}\n","outputs":1,"noerr":0,"x":230,"y":140,"wires":[["7b2187a9.5139d8"]]},{"id":"b832f02e.6f68d","type":"function","z":"76e3605b.0e6e7","name":"--Divider","func":"var a=\"-\"\na=a.padEnd(81,\"-\")\nmsg.payload = a\nreturn msg;","outputs":1,"noerr":0,"x":540,"y":280,"wires":[["54bcf469.64fc1c","11aeda74.2913e6"]]},{"id":"11aeda74.2913e6","type":"function","z":"76e3605b.0e6e7","name":"Send Header","func":"var a=\"\"\na = a + \"Date\".padEnd(28,\" \")+ \"Status\".padEnd(9,\" \")+ \"Roundtrip\".padEnd(11,\" \")+ \"Min\".padEnd(11,\" \")+ \"Max\".padEnd(11,\" \")+ \"Average\".padEnd(11,\" \")\nmsg.payload = a\nreturn msg;","outputs":1,"noerr":0,"x":530,"y":320,"wires":[["54bcf469.64fc1c"]]},{"id":"3a6e32fc.4a089e","type":"function","z":"76e3605b.0e6e7","name":"===Divider","func":"var a=\"=\"\na=a.padEnd(81,\"=\")\nmsg.payload = a\nreturn msg;","outputs":1,"noerr":0,"x":510,"y":200,"wires":[["800cd2f0.7e6fc","54bcf469.64fc1c"]]},{"id":"f97e59e9.764a98","type":"config","z":"76e3605b.0e6e7","name":"Config output directory","properties":[{"p":"OutputDirectory","pt":"flow","to":"/CS/Uptime/","tot":"str"},{"p":"Count","pt":"flow","to":"0","tot":"num"},{"p":"Min","pt":"flow","to":"None","tot":"str"},{"p":"Max","pt":"flow","to":"None","tot":"str"},{"p":"RollingAverage","pt":"flow","to":"None","tot":"str"}],"active":true,"x":140,"y":80,"wires":[],"info":"Note: by having a config node in a subflow, this sets the flow variables for when the subflow is activated. There is no way to use the click ability of a config node in a subflow, but it does do the initial population of the variable each time the subflow is triggered. In this case because the subflow is triggered via 12 different outputs, each of the 12 is a different set of the same variables."},{"id":"81c7815c.892cd","type":"config","z":"711cdb94.5b9a04","name":"Config output directory","properties":[{"p":"OutputDirectory","pt":"flow","to":"/CS/Uptime/","tot":"str"},{"p":"Count","pt":"flow","to":"0","tot":"num"},{"p":"Min","pt":"flow","to":"None","tot":"str"},{"p":"Max","pt":"flow","to":"None","tot":"str"},{"p":"RollingAverage","pt":"flow","to":"None","tot":"str"},{"p":"downcount","pt":"flow","to":"0","tot":"str"},{"p":"calculateandwriteoutage","pt":"flow","to":"false","tot":"bool"}],"active":true,"x":140,"y":240,"wires":[],"info":" * CS 192.168.86.3\r\n * G Wifi 192.168.86.1\r\n * Emby laptop 192.168.86.2\r\n * Lennox 192.168.86.101\r\n * ATT router 192.168.1.254\r\n * Cloudflare 1.1.1.1\r\n * Level 3 4.2.2.2\r\n * Google 8.8.8.8\r\n * OpenDNS 208.67.222.222\r\n * dfw25s26-in-f19.1e100.net 172.217.9.147\r\n * ghs.googlehosted.com 172.217.9.147\r\n * "},{"id":"159589d9.1135c6","type":"GSheet","z":"711cdb94.5b9a04","creds":"adb4e9b8.8beee8","method":"append","action":"","sheet":"1ZKNZWvcBqLcxkkFSrV9JN-BAeXiGoGrDjepUyD-S5Cs","cells":"Sheet1!A2:J1000","name":"","x":1137,"y":500,"wires":[[]]},{"id":"c77a0cee.02f32","type":"function","z":"711cdb94.5b9a04","name":"Examine messages for Internet vs host down","func":"if (msg.internettarget){\n    var downCount = flow.get(\"downcount\")\n    if(!isNaN(downCount)){\n        if(downCount<6){ //it would be better and more elegant to have something count the number of internet targets and pass that in, but for now it is just hardcoded to 6\n            downCount++\n            if(downCount == 6) {\n                flow.set(\"wentdownat\",Date.now())\n                flow.set(\"internetdown\", true)\n            }\n        }\n        \n    }\n    flow.set(\"downcount\", downCount);\n    return msg;}","outputs":1,"noerr":0,"x":710,"y":53,"wires":[[]],"info":"This Node is triggered by a ping response of false (i.e. more than 5 seconds to respond and thus either the network or the target host is offline)\n\n * gets how many consecutive times the ping has shown as down\n * sets internet down as true\n * Makes sure the down count is a number (belt and suspenders that could almost certainly be removed\n * If it is not a number than nothing happens\n * If it is, the it checks to see if the number of down responses has reached 6. The 6 is how many internet hosts are being examined. I assume that if we reach 6 then it is the internet and not just one or more of the total hosts that are down. If it is already at 6 then the system is treating the internet as down aleady and no further action is required.\n * If it is less than 6, then the count is incremented\n * If incrementing it has now made the count 6, it then records (in epoch time) the time the count went from 5 to 6.\n * Finally it saves the count back into a flow variable.\n"},{"id":"2286604.c0f71a","type":"function","z":"711cdb94.5b9a04","name":"Time to report outage?","func":"if (msg.internettarget){\n    var downCount = flow.get(\"downcount\")\n    var originalDownCount = downCount\n    flow.set(\"calculateandwriteoutage\",false)\n    if(!isNaN(downCount)){\n        if(downCount > 0){\n            downCount--\n            if(downCount === 0 && flow.get(\"internetdown\")) {\n                flow.set(\"internetdown\", false)\n                flow.set(\"cameupat\",Date.now())\n                flow.set(\"calculateandwriteoutage\",true)\n            }\n        }\n    }\n    flow.set(\"downcount\", downCount);\n    if(flow.get(\"calculateandwriteoutage\")){\n        return msg;\n        \n    }\n}","outputs":1,"noerr":0,"x":760,"y":100,"wires":[["8a0a15c8.5a92d8"]],"info":"This Node is triggered by a ping response of a number (i.e. between 1 and 4999 milliseconds for a ping response)\n\n * get how many nodes are down\n * save a copy of how many nodes are down\n * Set flow variable for whether to do a calculation and output to false by default\n * Makes sure the down count is a number (belt and suspenders that could almost certainly be removed)\n * Check if the count is greater than zero\n * If it is then decrement the count\n * check if the decremented count is 0 now and that the internetdown flag is true (this flag means the down count reached 6)\n * If it is, then the internet is up enough to then this record this as the time the internet came up and set the internetdown back to false and change the flag for whether to calculated and write the outage to Gsheet to true\n * Record the down count to the flow variable"},{"id":"cfec0785.b80348","type":"switch","z":"711cdb94.5b9a04","name":"","property":"pingtargetnum","propertyType":"msg","rules":[{"t":"eq","v":"1","vt":"str"},{"t":"eq","v":"2","vt":"str"},{"t":"eq","v":"3","vt":"str"},{"t":"eq","v":"4","vt":"str"},{"t":"eq","v":"5","vt":"str"},{"t":"eq","v":"6","vt":"str"},{"t":"eq","v":"7","vt":"str"},{"t":"eq","v":"8","vt":"str"},{"t":"eq","v":"9","vt":"str"},{"t":"eq","v":"10","vt":"str"},{"t":"eq","v":"11","vt":"str"},{"t":"eq","v":"12","vt":"str"}],"checkall":"false","repair":false,"outputs":12,"x":930,"y":240,"wires":[["625ab66.59d0b48"],["c5d470b0.da92f"],["469f91ba.58236"],["6caf4611.732b98"],["59014ce7.0a1b44"],["83e3d76d.17aad8"],["25747400.0795cc"],["2c8b7f98.87f3e"],["8f9ccce1.dd365"],["c8251ad6.9dcaf8"],["f54e3165.fa3b4"],["84a64174.16425"]]},{"id":"2a8bf2f.e6a000e","type":"function","z":"711cdb94.5b9a04","name":"Calculate Duration of Outage","func":"if(flow.get(\"calculateandwriteoutage\")){\n    var duration = flow.get(\"cameupat\") - flow.get(\"wentdownat\")\n    flow.set(\"calculateandwriteoutage\",false)\n    msg.payload = duration\n    return msg;\n} \n","outputs":1,"noerr":0,"x":160,"y":580,"wires":[["9a5ed7f0.5f0c68"]]},{"id":"cd0652f2.24c1b","type":"change","z":"711cdb94.5b9a04","name":"Set Ping Status Down","rules":[{"t":"set","p":"PingStatus","pt":"msg","to":"Down","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":340,"y":53,"wires":[["cfec0785.b80348","c77a0cee.02f32"]]},{"id":"625ab66.59d0b48","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","x":1150,"y":20,"wires":[]},{"id":"c5d470b0.da92f","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":60,"wires":[]},{"id":"469f91ba.58236","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":100,"wires":[]},{"id":"6caf4611.732b98","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":140,"wires":[]},{"id":"59014ce7.0a1b44","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":180,"wires":[]},{"id":"83e3d76d.17aad8","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":220,"wires":[]},{"id":"25747400.0795cc","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":260,"wires":[]},{"id":"2c8b7f98.87f3e","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":300,"wires":[]},{"id":"8f9ccce1.dd365","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":340,"wires":[]},{"id":"c8251ad6.9dcaf8","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":380,"wires":[]},{"id":"f54e3165.fa3b4","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":420,"wires":[]},{"id":"84a64174.16425","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1149,"y":460,"wires":[]},{"id":"286de803.dcf568","type":"change","z":"711cdb94.5b9a04","name":"Set Ping Status Good","rules":[{"t":"set","p":"PingStatus","pt":"msg","to":"Good","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":340,"y":100,"wires":[["cfec0785.b80348","2286604.c0f71a"]]},{"id":"3716f3a5.c360dc","type":"change","z":"711cdb94.5b9a04","name":"Set Ping Status Slow","rules":[{"t":"set","p":"PingStatus","pt":"msg","to":"Slow","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":340,"y":140,"wires":[["cfec0785.b80348","2286604.c0f71a"]]},{"id":"9a5ed7f0.5f0c68","type":"function","z":"711cdb94.5b9a04","name":"Translate Duration Function","func":"/* \n * Create Variables\n * \n */\n        var milliseconds = msg.payload;\n        var years, weeks, days, hours, minutes, seconds, millis;\n    //creating 2 string versions of each of the durations that can be in the middle of a 1:01:01.001 duration \n    //minstr is the always 2 character one\n    //lminstr is the version that can be 1 or more characers that will be used when that part is the portion of the duration\n        var minstr, secstr, millistr, lminstr, lsecstr, lmillistr;\n        var whichcomponents, readableduration;\n\n/*\n * Calculate the numbers for the subcomponents\n * \n */\n    //by getting the remainder when dividing by 1000\n    //it leaves just the fraction of milliseconds\n        millis = milliseconds % 1000;\n    //the floor function drops the decimal portion\n    //returning the non fractional seconds\n        seconds = Math.floor(milliseconds / 1000);\n    //the floor function drops the decimal portion\n    //returning the non fractional minutes\n        minutes = Math.floor(seconds / 60);\n    //Once the minutes have been calculated, then\n    //the seconds is replaced with those seconds not\n    //accounted for by the minutes\n        seconds = seconds % 60;\n    //The same sequence as used for minutes/seconds\n    //then used to calulate minutes, hours, dayss, weeks, years\n\n        hours = Math.floor(minutes / 60);\n        minutes = minutes % 60;\n        days = Math.floor(hours / 24);\n        hours = hours % 24;\n        weeks = Math.floor(days / 7)\n        days = days % 7;\n        years = Math.floor(days / 365.25)\n        weeks = weeks % 52;\n\n/*\n * Put the subcomponents into msg payloads for easy access by later nodes\n *\n */\n        msg.years = years\n        msg.weeks = weeks\n        msg.days = days\n        msg.hours = hours\n        msg.minutes = minutes\n        msg.seconds = seconds\n        msg.millis = millis\n \n\n/*\n * create the string verssion for the subcomponents\n */\n    //milliseconds\n        lmillistr = millis.toString();\n        //put padding on the milliseconds so that 1 ms shows as .001 and not .1 when concatenated after a decimal\n            millistr = millis.toString().padStart(3, \"0\");\n    //seconds\n        lsecstr = seconds.toString();\n        //put padding on the seconds so that 1 s shows as :01.000 and not :1.000 when concatenated after a dividing :\n            secstr = lsecstr.padStart(2, \"0\");\n    //minutes\n        lminstr = minutes.toString();\n        //put padding on the minutes so that 1 m shows as :01:00.000 and not :1:00.000 when concatenated after a dividing :\n            minstr = lminstr.padStart(2, \"0\");\n\n/*\n * Build output based on largest significant populated unit\n * The general rule is to include in the output the largest unit (years, weeks, days, etc) followed by the next 2\n * smaller units if the happen to be populated\n */\n    readableduration =\"\"\n//years populated\n    if (years !== 0) { \n        if (days !== 0) {\n            if (days === 1) {\n                readableduration = \" \".concat(days.toString(), \" Day\", readableduration)\n            } else {\n                readableduration = \" \".concat(days.toString(), \" Days\", readableduration)\n            }\n        }\n        if (weeks !== 0) {\n            if (weeks === 1) {\n                readableduration = \" \".concat(weeks.toString(), \" Week\", readableduration)\n            } else {\n                readableduration = \" \".concat(weeks.toString(), \" Weeks\", readableduration)\n            }\n        }\n        if (years === 1) {\n            readableduration = years.toString().concat(\" Year\", readableduration)\n        } else {\n            readableduration = years.toString().concat(\" Years\", readableduration)\n        }\n//weeks populated\n    } else if (weeks !== 0) {\n        if (hours !== 0) {\n            if (hours === 1) {\n                readableduration = \" \".concat(hours.toString(), \" Hour\", readableduration)\n            } else {\n                readableduration = \" \".concat(hours.toString(), \" Hours\", readableduration)\n            }\n        }\n        if (days !== 0) {\n            if (weeks === 1) {\n                readableduration = \" \".concat(days.toString(), \" Day\", readableduration)\n            } else {\n                readableduration = \" \".concat(days.toString(), \" Days\", readableduration)\n            }\n        }\n        if (weeks === 1) {\n            readableduration = weeks.toString().concat(\" Week\", readableduration)\n        } else {\n            readableduration = weeks.toString().concat(\" Weeks\", readableduration)\n        }\n//days populated\n    } else if (days !== 0) {\n        if ((minutes !== 0) && (hours !== 0)) { //If both are non-zero then 1:01 format. If only 1 then either 2 hours or 1 minute\n            if (minutes !== 0) {\n                readableduration = \":\".concat(minstr, readableduration)\n            }\n            if (hours !== 0) {\n                readableduration = \" \".concat(hours.toString(), readableduration)\n            } else {\n                readableduration = \" 0\".concat(readableduration)\n            }\n        } else {\n            if (minutes === 1) {\n                readableduration = \" 1 Minute\".concat(readableduration)\n            } else if (minutes > 1) {\n                readableduration = \" \".concat(lminstr,\" Minutes\", readableduration)\n            } else if (hours === 1) {\n                readableduration = \" 1 Hour\".concat(readableduration)\n            } else {\n                if (hours >1) {\n                    readableduration = \" \".concat(hours.toString(),\" Hours\", readableduration)\n                }\n            }\n        }\n        if (days === 1) {\n            readableduration = days.toString().concat(\" Day\", readableduration)\n        } else {\n            readableduration = days.toString().concat(\" Days\", readableduration)\n        }\n//hours populated\n    } else if (hours !== 0) {\n        if ((minutes !== 0) || (seconds !== 0)) { //End result h Hours or h:mm:ss\n            readableduration = hours.toString().concat(\":\", minstr, \":\", secstr, readableduration)\n        } else {\n            if (hours === 1) {\n                readableduration = \"1 Hour\"\n            } else {\n                readableduration = hours.toString().concat(\" Hours\", readableduration)\n            }\n        }\n//minutes populated\n    } else if (minutes !== 0) { //End result m Minutes or mm:ss.MMM\n        if (seconds !== 0 || millis !== 0) { //End result h Hours or h:mm:ss\n            readableduration = lminstr.concat(\":\", secstr, \".\", millistr, readableduration)\n        } else {\n            if (minutes === 1) {\n                readableduration = \"1 Minute\".concat( readableduration)\n            } else {\n                readableduration = lminstr.concat(\" Minutes\", readableduration)\n            }\n        }\n//seconds populated\n    } else if (seconds !== 0) {\n        if (millis !== 0) { //End result s Seconds or s.MMM\n            readableduration = lsecstr.concat(\".\", millistr, \" Seconds\", readableduration)\n        } else {\n            if (seconds === 1) {\n                readableduration = \"1 Second\".concat( readableduration)\n            } else {\n                readableduration = lsecstr.concat(\" Seconds\", readableduration)\n            }\n        }\n//milliseconds populated\n    } else if (millis !== 0) {\n        if (millis !== 1) {\n            readableduration = lmillistr.concat(\" Milliseconds\", readableduration)\n        } else {\n            readableduration = \"1 Millisecond\".concat( readableduration)\n        }\n    } else {\n        readableduration = \"0\"\n    }\n    msg.years = years\n    msg.weeks = weeks\n    msg.days = days\n    msg.hours = hours\n    msg.minutes = minutes\n    msg.seconds = seconds\n    msg.millis = millis\n    msg.payload = readableduration\n    return msg;","outputs":1,"noerr":0,"x":420,"y":580,"wires":[["533989e6.19aa38"]]},{"id":"5117f3ab.9484cc","type":"switch","z":"711cdb94.5b9a04","name":"Ping Status","property":"payload","propertyType":"msg","rules":[{"t":"false"},{"t":"lt","v":"goodbad","vt":"msg"},{"t":"gte","v":"goodbad","vt":"msg"}],"checkall":"false","repair":false,"outputs":3,"x":150,"y":100,"wires":[["cd0652f2.24c1b"],["286de803.dcf568"],["3716f3a5.c360dc"]]},{"id":"45d73ffd.6779d","type":"join","z":"711cdb94.5b9a04","name":"Assemble all columns and then send to Gsheet","mode":"custom","build":"array","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"num","reduceFixup":"","x":847,"y":500,"wires":[["159589d9.1135c6"]]},{"id":"8a0a15c8.5a92d8","type":"change","z":"711cdb94.5b9a04","name":"Build Column A data","rules":[{"t":"set","p":"payload","pt":"msg","to":"Outage","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":360,"y":500,"wires":[["45d73ffd.6779d","faa029b5.b65c28"]]},{"id":"faa029b5.b65c28","type":"simpletime","z":"711cdb94.5b9a04","name":"Populate Time Messages","x":150,"y":540,"wires":[["88071c08.c524"]]},{"id":"88071c08.c524","type":"change","z":"711cdb94.5b9a04","name":"Build Date/Time for Column B","rules":[{"t":"set","p":"payload","pt":"msg","to":"myyear\t&\"-\"&\tmymonthn\t&\"-\"&\tmydom\t&\" \"&\tmyhourpm\t&\":\"&\tmyminute\t&\":\"&\tmysecond\t&\".\"&\tmymillis\t&\" \"&\tmypm","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":410,"y":540,"wires":[["45d73ffd.6779d","2a8bf2f.e6a000e"]]},{"id":"533989e6.19aa38","type":"change","z":"711cdb94.5b9a04","name":"Pass Duration for Column C and send complet to Join","rules":[{"t":"set","p":"complete","pt":"msg","to":"true","tot":"bool"}],"action":"","property":"","from":"","to":"","reg":false,"x":340,"y":620,"wires":[["45d73ffd.6779d"]]},{"id":"e6f86ef9.f3af6","type":"rbe","z":"76e3605b.0e6e7","name":"New Max?","func":"rbei","gap":"","start":"","inout":"out","property":"Max","x":850,"y":20,"wires":[["23c83a68.f57316"]]},{"id":"48434c5b.387c44","type":"rbe","z":"76e3605b.0e6e7","name":"New Min?","func":"rbei","gap":"","start":"","inout":"out","property":"Min","x":850,"y":60,"wires":[["23c83a68.f57316"]]},{"id":"f6c04470.d3df38","type":"inject","z":"2b2a4010.a6b5e","name":"Start Backup of All 4 Hubitat Hubs","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":220,"y":80,"wires":[["79bd7f0.4778b8"]]},{"id":"dae3700e.3752","type":"exec","z":"c3686304.f6d31","command":"/data/bashscripts/backup4hubitats.sh","addpay":false,"append":"","useSpawn":"false","timer":"","oldrc":false,"name":"","x":290,"y":80,"wires":[["8061cf59.05783"],["8061cf59.05783"],["8061cf59.05783"]]},{"id":"8061cf59.05783","type":"debug","z":"c3686304.f6d31","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":250,"y":20,"wires":[]},{"id":"2808c99d.c92d26","type":"adv ping","z":"aba876af.3a45e8","name":"Ping the passed Host","host":"","x":360,"y":100,"wires":[["5992611c.d72ca","34f3f319.96490c"]]},{"id":"67721e37.f8a89","type":"inject","z":"54cae49c.6ee04c","name":"Turn Off Pinging","topic":"","payload":"stop","payloadType":"str","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":140,"y":100,"wires":[["385c5512.c9ac4a"]]},{"id":"9d8367a6.55abe8","type":"inject","z":"54cae49c.6ee04c","name":"Start Pinging","topic":"","payload":"Ping","payloadType":"str","repeat":"","crontab":"","once":true,"onceDelay":"0","x":130,"y":60,"wires":[["385c5512.c9ac4a"]]},{"id":"81b5485a.3abc58","type":"function","z":"aba876af.3a45e8","name":"Start currentNum","func":"// check to see if the current number (currentNum is equal to the number of hosts being pinged (totalNum)\n    //when it is, reset the current number (currentNum) to the startinng number (startNum)\n    //when it is not, then increment the current number (currentNum)\n    //in both cases record the new value of the current number (currentNum) to the new value (flow.set.....)\nif (flow.get(\"currentNum\") == flow.get(\"totalNum\")){\n    flow.set(\"currentNum\", flow.get(\"startNum\"))\n}else {\n    flow.set(\"currentNum\", Number(flow.get(\"currentNum\"))+1)\n}\n/*\n*   Use the current number (cNum) as the index to get the other data for this round of pings\n*/\nvar cNum = flow.get(\"currentNum\")\n    //set ip address to be used by downstream\nmsg.host = flow.get(\"PT\"+cNum)\n    //set name to be used by downstream\nmsg.pingtarget = flow.get(\"PT\"+cNum+\"Name\")\n    //set target number to be used by downstream\nmsg.pingtargetnum = cNum\n    //set the dividing line between good and bad for the host to be pinged for use by downstream\nmsg.goodbad = flow.get(\"GoodBadPT\"+cNum)\n    //set a boolean for downstream to identify if the current target is an internet host or LAN host to be used by downstream\nmsg.internettarget = flow.get(\"InternetPT\"+cNum)\n    //show via status node which host will be pinged based on the latest output from this node\nnode.status({fill:\"green\",shape:\"dot\",text:\"Ping \"+ flow.get(\"PT\"+flow.get(\"currentNum\")+\"Name\")});\nreturn msg;\n\n/* Before refactoring\n\nif (flow.get(\"currentNum\") == flow.get(\"totalNum\")){\n    flow.set(\"currentNum\", flow.get(\"startNum\"))\n}else {\n    flow.set(\"currentNum\", Number(flow.get(\"currentNum\"))+1)\n}\nmsg.host = flow.get(\"PT\"+flow.get(\"currentNum\"))\nmsg.payload = flow.get(\"currentNum\")\nnode.status({fill:\"green\",shape:\"dot\",text:\"Ping \"+ flow.get(\"PT\"+flow.get(\"currentNum\")+\"Name\")});\nmsg.pingtarget = flow.get(\"PT\"+flow.get(\"currentNum\")+\"Name\")\nmsg.pingtargetnum = flow.get(\"currentNum\")\nmsg.goodbad = flow.get(\"GoodBadPT\"+flow.get(\"currentNum\"))\nmsg.internettarget = flow.get(\"InternetPT\"+flow.get(\"currentNum\"))\nreturn msg;\n*/","outputs":1,"noerr":0,"x":150,"y":100,"wires":[["2808c99d.c92d26"]]},{"id":"385c5512.c9ac4a","type":"trigger","z":"54cae49c.6ee04c","op1":"","op2":"0","op1type":"pay","op2type":"str","duration":"-1","extend":false,"units":"s","reset":"stop","bytopic":"all","name":"Send request every 1s unless turned off","x":460,"y":60,"wires":[["eb8fea44.7fab68"]]},{"id":"eb8fea44.7fab68","type":"subflow:aba876af.3a45e8","z":"54cae49c.6ee04c","name":"","env":[],"x":550,"y":120,"wires":[]},{"id":"3ab1249d.86543c","type":"config","z":"aba876af.3a45e8","name":"Config ping targets","properties":[{"p":"PT1Name","pt":"flow","to":"Central Services","tot":"str"},{"p":"PT1","pt":"flow","to":"192.168.86.3","tot":"str"},{"p":"PT2Name","pt":"flow","to":"Google Wifi","tot":"str"},{"p":"PT2","pt":"flow","to":"192.168.86.1","tot":"str"},{"p":"PT3Name","pt":"flow","to":"Emby","tot":"str"},{"p":"PT3","pt":"flow","to":"192.168.86.2","tot":"str"},{"p":"PT4Name","pt":"flow","to":"Lennox Themostat","tot":"str"},{"p":"PT4","pt":"flow","to":"192.168.86.101","tot":"str"},{"p":"PT5Name","pt":"flow","to":"AT&T router ","tot":"str"},{"p":"PT5","pt":"flow","to":"192.168.1.254","tot":"str"},{"p":"PT6Name","pt":"flow","to":"Cloudflare ","tot":"str"},{"p":"PT6","pt":"flow","to":"1.1.1.1","tot":"str"},{"p":"PT7Name","pt":"flow","to":"Level 3","tot":"str"},{"p":"PT7","pt":"flow","to":"4.2.2.2","tot":"str"},{"p":"PT8Name","pt":"flow","to":"Google","tot":"str"},{"p":"PT8","pt":"flow","to":"8.8.8.8","tot":"str"},{"p":"PT9Name","pt":"flow","to":"OpenDNS","tot":"str"},{"p":"PT9","pt":"flow","to":"208.67.222.222","tot":"str"},{"p":"PT10Name","pt":"flow","to":"dfw25 (near google hosted)","tot":"str"},{"p":"PT10","pt":"flow","to":"172.217.9.147","tot":"str"},{"p":"PT11Name","pt":"flow","to":"ghs.googlehosted.com","tot":"str"},{"p":"PT11","pt":"flow","to":"172.217.9.179","tot":"str"},{"p":"startNum","pt":"flow","to":"1","tot":"str"},{"p":"totalNum","pt":"flow","to":"11","tot":"str"},{"p":"currentNum","pt":"flow","to":"","tot":"str"}],"active":true,"x":110,"y":140,"wires":[],"info":"Note: by having a config node in a subflow, this sets the flow variables for when the subflow is activated. There is no way to use the click ability of a config node in a subflow, but it does do the initial population of the variable each time the subflow is triggered. In this case because the subflow is triggered via 12 different outputs, each of the 12 is a different set of the same variables."},{"id":"ae97e491.065718","type":"config","z":"aba876af.3a45e8","name":"Config Good/Bad Dividing Lines by Ping Target","properties":[{"p":"GoodBadPT1","pt":"flow","to":"1","tot":"num"},{"p":"GoodBadPT2","pt":"flow","to":"500","tot":"num"},{"p":"GoodBadPT3","pt":"flow","to":"500","tot":"num"},{"p":"GoodBadPT4","pt":"flow","to":"4500","tot":"num"},{"p":"GoodBadPT5","pt":"flow","to":"2000","tot":"num"},{"p":"GoodBadPT6","pt":"flow","to":"1000","tot":"num"},{"p":"GoodBadPT7","pt":"flow","to":"1000","tot":"num"},{"p":"GoodBadPT8","pt":"flow","to":"1000","tot":"num"},{"p":"GoodBadPT9","pt":"flow","to":"1000","tot":"num"},{"p":"GoodBadPT10","pt":"flow","to":"1000","tot":"num"},{"p":"GoodBadPT11","pt":"flow","to":"1000","tot":"num"}],"active":true,"x":200,"y":180,"wires":[],"info":"Note: by having a config node in a subflow, this sets the flow variables for when the subflow is activated. There is no way to use the click ability of a config node in a subflow, but it does do the initial population of the variable each time the subflow is triggered. In this case because the subflow is triggered via 12 different outputs, each of the 12 is a different set of the same variables."},{"id":"cc5cceb1.282c3","type":"config","z":"aba876af.3a45e8","name":"Config If Target Counts toward down Internet Tracking","properties":[{"p":"InternetPT1","pt":"flow","to":"false","tot":"bool"},{"p":"InternetPT2","pt":"flow","to":"false","tot":"bool"},{"p":"InternetPT3","pt":"flow","to":"false","tot":"bool"},{"p":"InternetPT4","pt":"flow","to":"false","tot":"bool"},{"p":"InternetPT5","pt":"flow","to":"false","tot":"bool"},{"p":"InternetPT6","pt":"flow","to":"true","tot":"bool"},{"p":"InternetPT7","pt":"flow","to":"true","tot":"bool"},{"p":"InternetPT8","pt":"flow","to":"true","tot":"bool"},{"p":"InternetPT9","pt":"flow","to":"true","tot":"bool"},{"p":"InternetPT10","pt":"flow","to":"true","tot":"bool"},{"p":"InternetPT11","pt":"flow","to":"true","tot":"bool"}],"active":true,"x":220,"y":220,"wires":[],"info":"Note: by having a config node in a subflow, this sets the flow variables for when the subflow is activated. There is no way to use the click ability of a config node in a subflow, but it does do the initial population of the variable each time the subflow is triggered. In this case because the subflow is triggered via 12 different outputs, each of the 12 is a different set of the same variables."},{"id":"8c5abc2f.833c4","type":"GSheet","z":"aba876af.3a45e8","creds":"adb4e9b8.8beee8","method":"append","action":"","sheet":"1ZKNZWvcBqLcxkkFSrV9JN-BAeXiGoGrDjepUyD-S5Cs","cells":"Sheet1!A2:J1000","name":"","x":890,"y":340,"wires":[[]]},{"id":"36301876.b0d678","type":"function","z":"aba876af.3a45e8","name":"Examine messages for Internet vs host down","func":"// Conceptually the flow is keeping track of how many down internet hosts there are per the ping results.\n// This function does 2/3rds of that process whenever it is triggered. It is triggered when the ping status node recieves a false instead of a numeric quantity from the ping result.\n// The 3 things this funtion does are:\n//      1. increment the down count\n//      2. record the time/date the down count reached 6 (which indicates that all of the internet hosts did not reply to a ping)\n//      3. set the flow variable that the internet is down\n\nif (msg.internettarget){\n    var downCount = flow.get(\"downcount\")\n    if(!isNaN(downCount)){\n        if(downCount<6){ //it would be better and more elegant to have something count the number of internet targets and pass that in, but for now it is just hardcoded to 6\n            downCount++\n            if(downCount == 6) {\n                flow.set(\"wentdownat\",Date.now())\n                flow.set(\"internetdown\", true)\n            }\n        }\n    }\n    flow.set(\"downcount\", downCount);\n    return msg;}\n    \n    /* Before refactor\n    if (msg.internettarget){\n    var downCount = flow.get(\"downcount\")\n    if(!isNaN(downCount)){\n        if(downCount<6){ //it would be better and more elegant to have something count the number of internet targets and pass that in, but for now it is just hardcoded to 6\n            downCount++\n            if(downCount == 6) {\n                flow.set(\"wentdownat\",Date.now())\n                flow.set(\"internetdown\", true)\n            }\n        }\n        \n    }\n    flow.set(\"downcount\", downCount);\n    return msg;}\n    */","outputs":1,"noerr":0,"x":670,"y":20,"wires":[[]],"info":"This Node is triggered by a ping response of false (i.e. more than 5 seconds to respond and thus either the network or the target host is offline)\n\n * gets how many consecutive times the ping has shown as down\n * sets internet down as true\n * Makes sure the down count is a number (belt and suspenders that could almost certainly be removed\n * If it is not a number than nothing happens\n * If it is, the it checks to see if the number of down responses has reached 6. The 6 is how many internet hosts are being examined. I assume that if we reach 6 then it is the internet and not just one or more of the total hosts that are down. If it is already at 6 then the system is treating the internet as down aleady and no further action is required.\n * If it is less than 6, then the count is incremented\n * If incrementing it has now made the count 6, it then records (in epoch time) the time the count went from 5 to 6.\n * Finally it saves the count back into a flow variable.\n"},{"id":"a8e0ea25.6b4598","type":"function","z":"aba876af.3a45e8","name":"Time to report outage?","func":"// Conceptually the flow is keeping track of how many down internet hosts there are per the ping results.\n// This function does 1/4th of that process whenever it is triggered. It is triggered when the ping status node recieves a  numeric quantity from the ping result.\n// The 3 things this funtion does are:\n//      1. decrement the down count\n//      2. whenever the down count reaches 0 and the internet down boolean is true, then this means the internet is back up so then:\n//          a. set internet down boolean back to false\n//          b. record the time/date it came back up\n//          c. set the boolean that it is time to write the outage (to google sheet) to true\n//      3. set the flow variable that the internet is down\n\nif (msg.internettarget){\n    var downCount = flow.get(\"downcount\")\n    var originalDownCount = downCount\n    flow.set(\"calculateandwriteoutage\",false)\n    if(!isNaN(downCount)){\n        if(downCount > 0){\n            downCount--\n            if(downCount === 0 && flow.get(\"internetdown\")) {\n                flow.set(\"internetdown\", false)\n                flow.set(\"cameupat\",Date.now())\n                flow.set(\"calculateandwriteoutage\",true)\n            }\n        }\n    }\n    flow.set(\"downcount\", downCount);\n//note a msg is passed along to the write to google portion of the flow only if the calculate and write outage boolean is true\n//by note returning a msg, that portion of the flow is otherwise not triggered\n    if(flow.get(\"calculateandwriteoutage\")){\n        return msg;\n    }\n}\n\n\n/*Before refactor\nif (msg.internettarget){\n    var downCount = flow.get(\"downcount\")\n    var originalDownCount = downCount\n    flow.set(\"calculateandwriteoutage\",false)\n    if(!isNaN(downCount)){\n        if(downCount > 0){\n            downCount--\n            if(downCount === 0 && flow.get(\"internetdown\")) {\n                flow.set(\"internetdown\", false)\n                flow.set(\"cameupat\",Date.now())\n                flow.set(\"calculateandwriteoutage\",true)\n            }\n        }\n    }\n    flow.set(\"downcount\", downCount);\n    if(flow.get(\"calculateandwriteoutage\")){\n        return msg;\n        \n    }\n}\n*/","outputs":1,"noerr":0,"x":740,"y":200,"wires":[["49386f9d.e406"]],"info":"This Node is triggered by a ping response of a number (i.e. between 1 and 4999 milliseconds for a ping response)\n\n * get how many nodes are down\n * save a copy of how many nodes are down\n * Set flow variable for whether to do a calculation and output to false by default\n * Makes sure the down count is a number (belt and suspenders that could almost certainly be removed)\n * Check if the count is greater than zero\n * If it is then decrement the count\n * check if the decremented count is 0 now and that the internetdown flag is true (this flag means the down count reached 6)\n * If it is, then the internet is up enough to then this record this as the time the internet came up and set the internetdown back to false and change the flag for whether to calculated and write the outage to Gsheet to true\n * Record the down count to the flow variable"},{"id":"e23234f9.e2e198","type":"switch","z":"aba876af.3a45e8","name":"","property":"pingtargetnum","propertyType":"msg","rules":[{"t":"eq","v":"1","vt":"str"},{"t":"eq","v":"2","vt":"str"},{"t":"eq","v":"3","vt":"str"},{"t":"eq","v":"4","vt":"str"},{"t":"eq","v":"5","vt":"str"},{"t":"eq","v":"6","vt":"str"},{"t":"eq","v":"7","vt":"str"},{"t":"eq","v":"8","vt":"str"},{"t":"eq","v":"9","vt":"str"},{"t":"eq","v":"10","vt":"str"},{"t":"eq","v":"11","vt":"str"},{"t":"eq","v":"12","vt":"str"}],"checkall":"false","repair":false,"outputs":12,"x":970,"y":100,"wires":[["3838a30d.96e3ec"],["fe23a693.782e18"],["1c3e1fb5.2eb41"],["2aa59192.460dde"],["86a51f60.f66ee"],["f5b3dcb3.7054e"],["1b3bd6d1.3f1d89"],["4192675e.f2a288"],["77eed45b.16a24c"],["f527a986.c0db98"],["7d4621ff.a0f4d"],["12c58136.35d53f"]]},{"id":"31ff04f7.29ffec","type":"function","z":"aba876af.3a45e8","name":"Calculate Duration of Outage","func":"//This function makes sure it should be doing the calculate, then calculates the duration of the outage turns of the calculate flag and sends on the duration\n//This calculation could probably be moved back to the Time to report outage? node\nif(flow.get(\"calculateandwriteoutage\")){\n    var duration = flow.get(\"cameupat\") - flow.get(\"wentdownat\")\n    flow.set(\"calculateandwriteoutage\",false)\n    msg.payload = duration\n    return msg;\n}","outputs":1,"noerr":0,"x":160,"y":380,"wires":[["a927b98b.7807d8"]]},{"id":"8fa076b9.4abe38","type":"change","z":"aba876af.3a45e8","name":"Set Ping Status Down","rules":[{"t":"set","p":"PingStatus","pt":"msg","to":"Down","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":740,"y":60,"wires":[["e23234f9.e2e198","36301876.b0d678","ffcbe690.d32758"]]},{"id":"3838a30d.96e3ec","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","x":1190,"y":20,"wires":[]},{"id":"fe23a693.782e18","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":60,"wires":[]},{"id":"1c3e1fb5.2eb41","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":100,"wires":[]},{"id":"2aa59192.460dde","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":140,"wires":[]},{"id":"86a51f60.f66ee","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":180,"wires":[]},{"id":"f5b3dcb3.7054e","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":220,"wires":[]},{"id":"1b3bd6d1.3f1d89","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":260,"wires":[]},{"id":"4192675e.f2a288","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":300,"wires":[]},{"id":"77eed45b.16a24c","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":340,"wires":[]},{"id":"f527a986.c0db98","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":380,"wires":[]},{"id":"7d4621ff.a0f4d","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":420,"wires":[]},{"id":"12c58136.35d53f","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1189,"y":460,"wires":[]},{"id":"121af4fc.20aceb","type":"change","z":"aba876af.3a45e8","name":"Set Ping Status Good","rules":[{"t":"set","p":"PingStatus","pt":"msg","to":"Good","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":740,"y":100,"wires":[["e23234f9.e2e198","a8e0ea25.6b4598","d9ed9f5c.50725","ffcbe690.d32758"]]},{"id":"7eadecfd.6684c4","type":"change","z":"aba876af.3a45e8","name":"Set Ping Status Slow","rules":[{"t":"set","p":"PingStatus","pt":"msg","to":"Slow","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":740,"y":140,"wires":[["e23234f9.e2e198","a8e0ea25.6b4598","d9ed9f5c.50725","ffcbe690.d32758"]]},{"id":"a927b98b.7807d8","type":"function","z":"aba876af.3a45e8","name":"Translate Duration Function","func":"//This function translates a duration into a friendly person readable format\n/* \n * Create Variables\n * \n */\n        var milliseconds = msg.payload;\n        var years, weeks, days, hours, minutes, seconds, millis;\n    //creating 2 string versions of each of the durations that can be in the middle of a 1:01:01.001 duration \n    //minstr is the always 2 character one\n    //lminstr is the version that can be 1 or more characers that will be used when that part is the portion of the duration\n        var minstr, secstr, millistr, lminstr, lsecstr, lmillistr;\n        var whichcomponents, readableduration;\n\n/*\n * Calculate the numbers for the subcomponents\n * \n */\n    //by getting the remainder when dividing by 1000\n    //it leaves just the fraction of milliseconds\n        millis = milliseconds % 1000;\n    //the floor function drops the decimal portion\n    //returning the non fractional seconds\n        seconds = Math.floor(milliseconds / 1000);\n    //the floor function drops the decimal portion\n    //returning the non fractional minutes\n        minutes = Math.floor(seconds / 60);\n    //Once the minutes have been calculated, then\n    //the seconds is replaced with those seconds not\n    //accounted for by the minutes\n        seconds = seconds % 60;\n    //The same sequence as used for minutes/seconds\n    //then used to calulate minutes, hours, dayss, weeks, years\n\n        hours = Math.floor(minutes / 60);\n        minutes = minutes % 60;\n        days = Math.floor(hours / 24);\n        hours = hours % 24;\n        weeks = Math.floor(days / 7)\n        days = days % 7;\n        years = Math.floor(days / 365.25)\n        weeks = weeks % 52;\n\n/*\n * Put the subcomponents into msg payloads for easy access by later nodes\n *\n */\n        msg.years = years\n        msg.weeks = weeks\n        msg.days = days\n        msg.hours = hours\n        msg.minutes = minutes\n        msg.seconds = seconds\n        msg.millis = millis\n \n\n/*\n * create the string verssion for the subcomponents\n */\n    //milliseconds\n        lmillistr = millis.toString();\n        //put padding on the milliseconds so that 1 ms shows as .001 and not .1 when concatenated after a decimal\n            millistr = millis.toString().padStart(3, \"0\");\n    //seconds\n        lsecstr = seconds.toString();\n        //put padding on the seconds so that 1 s shows as :01.000 and not :1.000 when concatenated after a dividing :\n            secstr = lsecstr.padStart(2, \"0\");\n    //minutes\n        lminstr = minutes.toString();\n        //put padding on the minutes so that 1 m shows as :01:00.000 and not :1:00.000 when concatenated after a dividing :\n            minstr = lminstr.padStart(2, \"0\");\n\n/*\n * Build output based on largest significant populated unit\n * The general rule is to include in the output the largest unit (years, weeks, days, etc) followed by the next 2\n * smaller units if the happen to be populated\n */\n    readableduration =\"\"\n//years populated\n    if (years !== 0) { \n        if (days !== 0) {\n            if (days === 1) {\n                readableduration = \" \".concat(days.toString(), \" Day\", readableduration)\n            } else {\n                readableduration = \" \".concat(days.toString(), \" Days\", readableduration)\n            }\n        }\n        if (weeks !== 0) {\n            if (weeks === 1) {\n                readableduration = \" \".concat(weeks.toString(), \" Week\", readableduration)\n            } else {\n                readableduration = \" \".concat(weeks.toString(), \" Weeks\", readableduration)\n            }\n        }\n        if (years === 1) {\n            readableduration = years.toString().concat(\" Year\", readableduration)\n        } else {\n            readableduration = years.toString().concat(\" Years\", readableduration)\n        }\n//weeks populated\n    } else if (weeks !== 0) {\n        if (hours !== 0) {\n            if (hours === 1) {\n                readableduration = \" \".concat(hours.toString(), \" Hour\", readableduration)\n            } else {\n                readableduration = \" \".concat(hours.toString(), \" Hours\", readableduration)\n            }\n        }\n        if (days !== 0) {\n            if (weeks === 1) {\n                readableduration = \" \".concat(days.toString(), \" Day\", readableduration)\n            } else {\n                readableduration = \" \".concat(days.toString(), \" Days\", readableduration)\n            }\n        }\n        if (weeks === 1) {\n            readableduration = weeks.toString().concat(\" Week\", readableduration)\n        } else {\n            readableduration = weeks.toString().concat(\" Weeks\", readableduration)\n        }\n//days populated\n    } else if (days !== 0) {\n        if ((minutes !== 0) && (hours !== 0)) { //If both are non-zero then 1:01 format. If only 1 then either 2 hours or 1 minute\n            if (minutes !== 0) {\n                readableduration = \":\".concat(minstr, readableduration)\n            }\n            if (hours !== 0) {\n                readableduration = \" \".concat(hours.toString(), readableduration)\n            } else {\n                readableduration = \" 0\".concat(readableduration)\n            }\n        } else {\n            if (minutes === 1) {\n                readableduration = \" 1 Minute\".concat(readableduration)\n            } else if (minutes > 1) {\n                readableduration = \" \".concat(lminstr,\" Minutes\", readableduration)\n            } else if (hours === 1) {\n                readableduration = \" 1 Hour\".concat(readableduration)\n            } else {\n                if (hours >1) {\n                    readableduration = \" \".concat(hours.toString(),\" Hours\", readableduration)\n                }\n            }\n        }\n        if (days === 1) {\n            readableduration = days.toString().concat(\" Day\", readableduration)\n        } else {\n            readableduration = days.toString().concat(\" Days\", readableduration)\n        }\n//hours populated\n    } else if (hours !== 0) {\n        if ((minutes !== 0) || (seconds !== 0)) { //End result h Hours or h:mm:ss\n            readableduration = hours.toString().concat(\":\", minstr, \":\", secstr, readableduration)\n        } else {\n            if (hours === 1) {\n                readableduration = \"1 Hour\"\n            } else {\n                readableduration = hours.toString().concat(\" Hours\", readableduration)\n            }\n        }\n//minutes populated\n    } else if (minutes !== 0) { //End result m Minutes or mm:ss.MMM\n        if (seconds !== 0 || millis !== 0) { //End result h Hours or h:mm:ss\n            readableduration = lminstr.concat(\":\", secstr, \".\", millistr, readableduration)\n        } else {\n            if (minutes === 1) {\n                readableduration = \"1 Minute\".concat( readableduration)\n            } else {\n                readableduration = lminstr.concat(\" Minutes\", readableduration)\n            }\n        }\n//seconds populated\n    } else if (seconds !== 0) {\n        if (millis !== 0) { //End result s Seconds or s.MMM\n            readableduration = lsecstr.concat(\".\", millistr, \" Seconds\", readableduration)\n        } else {\n            if (seconds === 1) {\n                readableduration = \"1 Second\".concat( readableduration)\n            } else {\n                readableduration = lsecstr.concat(\" Seconds\", readableduration)\n            }\n        }\n//milliseconds populated\n    } else if (millis !== 0) {\n        if (millis !== 1) {\n            readableduration = lmillistr.concat(\" Milliseconds\", readableduration)\n        } else {\n            readableduration = \"1 Millisecond\".concat( readableduration)\n        }\n    } else {\n        readableduration = \"0\"\n    }\n    msg.years = years\n    msg.weeks = weeks\n    msg.days = days\n    msg.hours = hours\n    msg.minutes = minutes\n    msg.seconds = seconds\n    msg.millis = millis\n    msg.payload = readableduration\n    return msg;","outputs":1,"noerr":0,"x":420,"y":380,"wires":[["10b233e9.17db8c"]]},{"id":"5992611c.d72ca","type":"switch","z":"aba876af.3a45e8","name":"Ping Status","property":"payload","propertyType":"msg","rules":[{"t":"false"},{"t":"lt","v":"goodbad","vt":"msg"},{"t":"gte","v":"goodbad","vt":"msg"}],"checkall":"false","repair":false,"outputs":3,"x":550,"y":100,"wires":[["8fa076b9.4abe38"],["121af4fc.20aceb"],["7eadecfd.6684c4"]]},{"id":"de3cd25d.34a83","type":"join","z":"aba876af.3a45e8","name":"Assemble all columns and then send to Gsheet","mode":"custom","build":"array","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"num","reduceFixup":"","x":800,"y":280,"wires":[["8c5abc2f.833c4"]]},{"id":"49386f9d.e406","type":"change","z":"aba876af.3a45e8","name":"Build Column A data","rules":[{"t":"set","p":"payload","pt":"msg","to":"Outage","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":140,"y":280,"wires":[["de3cd25d.34a83","9aa9821b.c03f1"]]},{"id":"9aa9821b.c03f1","type":"simpletime","z":"aba876af.3a45e8","name":"Populate Time Messages","x":150,"y":340,"wires":[["7e0f855b.bdf2dc"]]},{"id":"7e0f855b.bdf2dc","type":"change","z":"aba876af.3a45e8","name":"Build Date/Time for Column B","rules":[{"t":"set","p":"payload","pt":"msg","to":"myyear\t&\"-\"&\tmymonthn\t&\"-\"&\tmydom\t&\" \"&\tmyhourpm\t&\":\"&\tmyminute\t&\":\"&\tmysecond\t&\".\"&\tmymillis\t&\" \"&\tmypm","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":410,"y":340,"wires":[["de3cd25d.34a83","31ff04f7.29ffec"]]},{"id":"10b233e9.17db8c","type":"change","z":"aba876af.3a45e8","name":"Pass Duration for Column C and send complet to Join","rules":[{"t":"set","p":"complete","pt":"msg","to":"true","tot":"bool"}],"action":"","property":"","from":"","to":"","reg":false,"x":340,"y":420,"wires":[["de3cd25d.34a83"]]},{"id":"79bd7f0.4778b8","type":"subflow:c3686304.f6d31","z":"2b2a4010.a6b5e","name":"","env":[],"x":560,"y":80,"wires":[]},{"id":"4ba5918f.c183f","type":"comment","z":"54cae49c.6ee04c","name":"Ping 11 IP addresses","info":"This starts automatically but can be stopped via the Turn Off Pinging injection node.","x":140,"y":20,"wires":[]},{"id":"34f3f319.96490c","type":"function","z":"aba876af.3a45e8","name":"Format Internet UpDown for InfluxDB","func":"//This function checks if the pinged target is an internet host of local to the LAN host and then only does something for internet hosts\n//Assuming it is an internet host it creates input to be sent to the InfluxDB. This includes the hostname, IP address and 2 indicators of if the pinged target responded or not\n//At least for now both a boolean and numeric are sent as Chronograf doesn't seem to know how to handle boolean, but hopefully Grafana with discrete plugin will\nvar targetIP = msg.topic\nvar targetName = msg.pingtarget\nvar pingresult = msg.payload\nif (msg.internettarget) {\n    if (pingresult) {\n        combinedObj = [\n            {\n                Connected: true,\n                ConnectedNumeric: 1\n            },\n            {\n                TargetName: targetName,\n                TargetIPAddress: targetIP\n            }\n        ];\n    } else {\n        combinedObj = [\n            {\n                Connected: false,\n                ConnectedNumeric: 0\n            },\n            {\n                TargetName: targetName,\n                TargetIPAddress: targetIP\n            }\n        ];\n    }\n    msg.payload = combinedObj\n    return msg;\n}","outputs":1,"noerr":0,"x":430,"y":600,"wires":[["eda2c0bf.ab20c"]]},{"id":"d9ed9f5c.50725","type":"function","z":"aba876af.3a45e8","name":"Prepare Ping Duration for InfluxDB","func":"//This function creates input to be sent to the InfluxDB. This includes the hostname, IP address and the roundtrip time of the ping\nvar targetIP = msg.topic\nvar duration = msg.payload\nvar targetName = msg.pingtarget\nvar combinedObj;\ncombinedObj = [\n    {\n        RountripDuration: duration\n    },\n    {\n        TargetName: targetName,\n        TargetIPAddress: targetIP\n    }\n];\nmsg.payload = combinedObj\nreturn msg;","outputs":1,"noerr":0,"x":720,"y":520,"wires":[["eda2c0bf.ab20c"]]},{"id":"eda2c0bf.ab20c","type":"influxdb out","z":"aba876af.3a45e8","influxdb":"430b7850.44c1a8","name":"","measurement":"NetworkUptime","precision":"","retentionPolicy":"","x":1030,"y":600,"wires":[]},{"id":"d783e91.39a8b18","type":"config","z":"b2524cfd.8c346","name":"Lennox Thermostat Config","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"Narrow Hall","tot":"str"},{"p":"Room","pt":"flow","to":"","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Thermostat","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Lennox","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"WiFi","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Lennox Thermostat","tot":"str"}],"active":true,"x":180,"y":40,"wires":[]},{"id":"7c8124df.c050dc","type":"influxdb out","z":"b2524cfd.8c346","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1310,"y":20,"wires":[]},{"id":"c8be3f1a.40f2c","type":"function","z":"b2524cfd.8c346","name":"Format for InfluxDB & MQTT","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node via output 1 which will in turn write to the InfluxDB\n * It also formats an MQTT topic and the data sending that to output 2 which in turn can be used by an MQTT node to send to \n * MQTT\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n/* MQTT section \n * \n * \n * \n */\n\n//create the placeholder object\nvar msg2 = {}\n//add the MQTT topic\nmsg2.topic = \"Hubitat/\" + flow.get(\"MQTTDeviceTopic\") + \"/\" + typeOfMeasurement\n//add the data to be recorded to MQTT\nmsg2.payload = theData\n\n\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return [msg, msg2]\n}","outputs":2,"noerr":0,"x":940,"y":80,"wires":[["7c8124df.c050dc","c72595c7.770458"],["70bd2141.f8cb7"]]},{"id":"c72595c7.770458","type":"change","z":"b2524cfd.8c346","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1350,"y":60,"wires":[[]]},{"id":"910eb892.e04458","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring the Lennox Thermostat","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":210,"y":180,"wires":[[]]},{"id":"11cd7e59.f48b12","type":"subflow:b2524cfd.8c346","z":"54cae49c.6ee04c","name":"","env":[],"x":540,"y":180,"wires":[]},{"id":"88b0711.887869","type":"comment","z":"54cae49c.6ee04c","name":"Start Device Monitoring","info":"This starts automatically but can be stopped via the Turn Off Pinging injection node.","x":140,"y":140,"wires":[]},{"id":"ffcbe690.d32758","type":"function","z":"aba876af.3a45e8","name":"Populate Status Details","func":"msg.payload = \"Latest Ping Quality: \" + msg.PingStatus + \" (\"+ msg.payload+\")\"\nreturn msg;","outputs":1,"noerr":0,"x":1070,"y":520,"wires":[[]]},{"id":"d39fcb30.32dae8","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring the Game Room Floor Lamp","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":230,"y":240,"wires":[[]]},{"id":"4234bd83.16c3e4","type":"subflow:1e603513.011bdb","z":"54cae49c.6ee04c","name":"","env":[],"x":560,"y":240,"wires":[]},{"id":"4273cad9.ac63d4","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring the Aqara Button","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":190,"y":300,"wires":[[]]},{"id":"a0794888.ae50c8","type":"subflow:89f52889.bf1478","z":"54cae49c.6ee04c","name":"","env":[],"x":520,"y":300,"wires":[]},{"id":"6018b0dd.77aff","type":"config","z":"89f52889.bf1478","name":"Aqara Button Config","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"Mike Bedside","tot":"str"},{"p":"Room","pt":"flow","to":"Maste rBedroom","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Button","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Aqara","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Aqara button","tot":"str"}],"active":true,"x":200,"y":40,"wires":[]},{"id":"4b143d5a.e11b54","type":"hubitat command","z":"98a6e865.a02ea8","name":"Mike Bedside","server":"55e4481a.722098","deviceId":"257","command":"","commandArgs":"","x":820,"y":60,"wires":[[]]},{"id":"53de30cb.5a905","type":"hubitat device","z":"98a6e865.a02ea8","name":"Mike Bedside Currently?","server":"55e4481a.722098","deviceId":"257","attribute":"switch","sendEvent":false,"x":370,"y":60,"wires":[["8c38df2a.5984b"]]},{"id":"8c38df2a.5984b","type":"switch","z":"98a6e865.a02ea8","name":"Off/On","property":"payload.value","propertyType":"msg","rules":[{"t":"eq","v":"off","vt":"str"},{"t":"eq","v":"on","vt":"str"}],"checkall":"true","repair":false,"outputs":2,"x":550,"y":60,"wires":[["91cf3e9c.c1ae1"],["349ff253.9b9a7e"]]},{"id":"91cf3e9c.c1ae1","type":"change","z":"98a6e865.a02ea8","name":"On","rules":[{"t":"set","p":"command","pt":"msg","to":"on","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":670,"y":40,"wires":[["4b143d5a.e11b54"]]},{"id":"349ff253.9b9a7e","type":"change","z":"98a6e865.a02ea8","name":"Off","rules":[{"t":"set","p":"command","pt":"msg","to":"off","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":670,"y":80,"wires":[["4b143d5a.e11b54"]]},{"id":"323994d.e2eaa6c","type":"hubitat device","z":"98a6e865.a02ea8","name":"Aqara button pushed","server":"55e4481a.722098","deviceId":"356","attribute":"pushed","sendEvent":true,"x":120,"y":60,"wires":[["53de30cb.5a905"]]},{"id":"d430a9c7.458158","type":"comment","z":"98a6e865.a02ea8","name":"Push of Aqara button toggles the switch controlling Mike's beside lamp","info":"","x":270,"y":20,"wires":[]},{"id":"a4714ecb.018c9","type":"config","z":"4e2f0c22.b816c4","name":"Corner Lamp IKEA Switch Config","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"Northeast Corner","tot":"str"},{"p":"Room","pt":"flow","to":"Living Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"IKEA","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Corner Light","tot":"str"}],"active":true,"x":180,"y":40,"wires":[]},{"id":"e4b7ca11.ec1708","type":"subflow:4e2f0c22.b816c4","z":"54cae49c.6ee04c","name":"","env":[],"x":510,"y":360,"wires":[]},{"id":"5dab24aa.6e314c","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring the Corner Lamp","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":190,"y":360,"wires":[[]]},{"id":"5afc38b5.219b88","type":"config","z":"5364e86b.44e3a8","name":"Office Echo Config","properties":[{"p":"Floor","pt":"flow","to":"2","tot":"str"},{"p":"Location","pt":"flow","to":"Mike's Desk","tot":"str"},{"p":"Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Echo","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Amazon","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Office Echo","tot":"str"}],"active":true,"x":130,"y":40,"wires":[]},{"id":"48244b14.f15d04","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring the Office Echo","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":190,"y":420,"wires":[[]]},{"id":"7b090cc0.2299f4","type":"subflow:5364e86b.44e3a8","z":"54cae49c.6ee04c","name":"","env":[],"x":510,"y":420,"wires":[]},{"id":"c2484670.ff6178","type":"link out","z":"5364e86b.44e3a8","name":"Passthrough to enable subflow","links":["694310aa.24b6e","b88e99f7.bf3308","d6ea4559.a9e278","92f18ff9.97d71","da26393c.a17d28","67e8465f.17c138","327fcb20.315534"],"x":210,"y":80,"wires":[],"l":true},{"id":"694310aa.24b6e","type":"link in","z":"5364e86b.44e3a8","name":"From Input","links":["c2484670.ff6178"],"x":120,"y":160,"wires":[[]],"l":true},{"id":"d6ea4559.a9e278","type":"link in","z":"5364e86b.44e3a8","name":"From Input","links":["c2484670.ff6178"],"x":120,"y":640,"wires":[[]],"l":true},{"id":"67e8465f.17c138","type":"link in","z":"5364e86b.44e3a8","name":"From Input","links":["c2484670.ff6178"],"x":120,"y":1240,"wires":[[]],"l":true},{"id":"adb2bdd.7f92f4","type":"link in","z":"5364e86b.44e3a8","name":"Send to InfluxDB","links":["c11947fb.7455d8","ebcb834.d2a3a8","6027de94.3da19","afde47f8.f056d8","3506c761.e6a318","31262558.ccab2a","f82d697d.2c2fa8"],"x":520,"y":80,"wires":[["276d7462.8ad96c"]],"l":true},{"id":"c11947fb.7455d8","type":"link out","z":"5364e86b.44e3a8","name":"Gather to Send to InfluxDB","links":["adb2bdd.7f92f4"],"x":800,"y":1160,"wires":[],"l":true},{"id":"ebcb834.d2a3a8","type":"link out","z":"5364e86b.44e3a8","name":"Gather to Send to InfluxDB","links":["adb2bdd.7f92f4"],"x":800,"y":680,"wires":[],"l":true},{"id":"6027de94.3da19","type":"link out","z":"5364e86b.44e3a8","name":"Gather to Send to InfluxDB","links":["adb2bdd.7f92f4"],"x":800,"y":280,"wires":[],"l":true},{"id":"e7028df7.05f37","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Mike's Bedside Lamp","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":210,"y":480,"wires":[[]]},{"id":"eb0c463e.de05b8","type":"config","z":"ae851807.40c0e8","name":"Mike Bedside Config","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"Southeast Corner","tot":"str"},{"p":"Room","pt":"flow","to":"Master Bedroom","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Wemo","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Mike's Bedside Light","tot":"str"}],"active":true,"x":160,"y":40,"wires":[]},{"id":"c7c61ee1.9dfe9","type":"link out","z":"ae851807.40c0e8","name":"Passthrough to enable subflow","links":["f7a5cb73.bf0668","b319e707.413b48","87b30f86.964ff","b5d38503.3d1c58","af17333b.402a1","bca1623.11908a","1396a56f.840d8b"],"x":230,"y":80,"wires":[],"l":true},{"id":"f7a5cb73.bf0668","type":"link in","z":"ae851807.40c0e8","name":"From Input","links":["c7c61ee1.9dfe9"],"x":120,"y":180,"wires":[[]],"l":true},{"id":"9f6b0d0e.cff9c","type":"link in","z":"ae851807.40c0e8","name":"Send to InfluxDB","links":["436be19f.e8b36","5955230b.51edec","64b0a2fd.b82a1c"],"x":480,"y":40,"wires":[["e0cf241e.5c4588"]],"l":true},{"id":"64b0a2fd.b82a1c","type":"link out","z":"ae851807.40c0e8","name":"Gather to Send to InfluxDB","links":["9f6b0d0e.cff9c"],"x":540,"y":180,"wires":[],"l":true},{"id":"3e399597.2a03ca","type":"subflow:ae851807.40c0e8","z":"54cae49c.6ee04c","name":"","env":[],"x":540,"y":480,"wires":[]},{"id":"9f7a8094.d603f","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Mike's Credenza Light","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":210,"y":540,"wires":[[]]},{"id":"e6762905.751918","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Table Lamp","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":180,"y":600,"wires":[[]]},{"id":"725c13ac.01ad5c","type":"config","z":"92d72719.56bd38","name":"Mike Credenza Light Config","properties":[{"p":"Floor","pt":"flow","to":"2","tot":"str"},{"p":"Location","pt":"flow","to":"Mike's Desk","tot":"str"},{"p":"Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"IKEA","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Mike's Credenza Light","tot":"str"}],"active":true,"x":160,"y":40,"wires":[]},{"id":"8bb21bf9.9058f8","type":"link out","z":"92d72719.56bd38","name":"Passthrough to enable subflow","links":["fe56b81c.45a158"],"x":210,"y":80,"wires":[],"l":true},{"id":"fe56b81c.45a158","type":"link in","z":"92d72719.56bd38","name":"From Input","links":["8bb21bf9.9058f8"],"x":120,"y":240,"wires":[[]],"l":true},{"id":"b0bc3d8b.008d","type":"link in","z":"92d72719.56bd38","name":"Send to InfluxDB","links":["54bbce35.4e1e2"],"x":460,"y":40,"wires":[["5e0f03d2.a6dbfc"]],"l":true},{"id":"54bbce35.4e1e2","type":"link out","z":"92d72719.56bd38","name":"Gather to Send to InfluxDB","links":["b0bc3d8b.008d"],"x":620,"y":240,"wires":[],"l":true},{"id":"a0381fce.df712","type":"subflow:92d72719.56bd38","z":"54cae49c.6ee04c","name":"","env":[],"x":540,"y":540,"wires":[]},{"id":"3bdac541.4f5bfa","type":"config","z":"fd34e084.87e19","name":"Table Lamp Config","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"North Side","tot":"str"},{"p":"Room","pt":"flow","to":"Living Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Bulb","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"TP-Link","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Table Lamp","tot":"str"}],"active":true,"x":130,"y":40,"wires":[]},{"id":"c4868b86.653628","type":"link out","z":"fd34e084.87e19","name":"Passthrough to enable subflow","links":["739a3338.a0857c"],"x":210,"y":80,"wires":[],"l":true},{"id":"739a3338.a0857c","type":"link in","z":"fd34e084.87e19","name":"From Input","links":["c4868b86.653628"],"x":120,"y":240,"wires":[[]],"l":true},{"id":"45137fe4.da261","type":"link in","z":"fd34e084.87e19","name":"Send to InfluxDB","links":["b83bc91d.ad0158"],"x":460,"y":40,"wires":[["8ccd32e5.c587f"]],"l":true},{"id":"b83bc91d.ad0158","type":"link out","z":"fd34e084.87e19","name":"Gather to Send to InfluxDB","links":["45137fe4.da261"],"x":640,"y":240,"wires":[],"l":true},{"id":"3d6974e2.28673c","type":"subflow:fd34e084.87e19","z":"54cae49c.6ee04c","name":"","env":[],"x":510,"y":600,"wires":[]},{"id":"afde47f8.f056d8","type":"link out","z":"5364e86b.44e3a8","name":"Gather to Send to InfluxDB","links":["adb2bdd.7f92f4"],"x":800,"y":160,"wires":[],"l":true},{"id":"3506c761.e6a318","type":"link out","z":"5364e86b.44e3a8","name":"Gather to Send to InfluxDB","links":["adb2bdd.7f92f4"],"x":800,"y":840,"wires":[],"l":true},{"id":"31262558.ccab2a","type":"link out","z":"5364e86b.44e3a8","name":"Gather to Send to InfluxDB","links":["adb2bdd.7f92f4"],"x":780,"y":1360,"wires":[],"l":true},{"id":"427dc421.8d781c","type":"link out","z":"4e2f0c22.b816c4","name":"Passthrough to enable subflow","links":["e7935525.398708"],"x":190,"y":80,"wires":[],"l":true},{"id":"377e26bc.c06f7a","type":"link out","z":"4e2f0c22.b816c4","name":"Gather to Send to InfluxDB","links":["adeebefa.595b9"],"x":840,"y":140,"wires":[],"l":true},{"id":"e7935525.398708","type":"link in","z":"4e2f0c22.b816c4","name":"From Input","links":["427dc421.8d781c"],"x":160,"y":140,"wires":[[]],"l":true},{"id":"adeebefa.595b9","type":"link in","z":"4e2f0c22.b816c4","name":"Send to InfluxDB","links":["377e26bc.c06f7a"],"x":463,"y":40,"wires":[["6f819c50.8d9204"]],"l":true},{"id":"6ccdb89c.8350f8","type":"link out","z":"89f52889.bf1478","name":"Passthrough to enable subflow","links":["1fe20b58.99d435","98e0ed70.2f8a2"],"x":230,"y":80,"wires":[],"l":true},{"id":"1fe20b58.99d435","type":"link in","z":"89f52889.bf1478","name":"From Input","links":["6ccdb89c.8350f8"],"x":120,"y":140,"wires":[[]],"l":true},{"id":"591d8855.0ae688","type":"link in","z":"89f52889.bf1478","name":"Send to InfluxDB","links":["28f992dc.e36bce","aaa9e5fe.be54c8","2501a22f.6c65ce"],"x":500,"y":40,"wires":[["805045fa.94f318"]],"l":true},{"id":"28f992dc.e36bce","type":"link out","z":"89f52889.bf1478","name":"Gather to Send to InfluxDB","links":["591d8855.0ae688"],"x":860,"y":140,"wires":[],"l":true},{"id":"aaa9e5fe.be54c8","type":"link out","z":"89f52889.bf1478","name":"Gather to Send to InfluxDB","links":["591d8855.0ae688"],"x":860,"y":620,"wires":[],"l":true},{"id":"98e0ed70.2f8a2","type":"link in","z":"89f52889.bf1478","name":"From Input","links":["6ccdb89c.8350f8"],"x":140,"y":800,"wires":[[]],"l":true},{"id":"2501a22f.6c65ce","type":"link out","z":"89f52889.bf1478","name":"Gather to Send to InfluxDB","links":["591d8855.0ae688"],"x":860,"y":920,"wires":[],"l":true},{"id":"f902dc8c.c0f5","type":"link out","z":"b2524cfd.8c346","name":"Passthrough to enable subflow","links":["74ab94b8.e95e8c"],"x":210,"y":80,"wires":[],"l":true},{"id":"74ab94b8.e95e8c","type":"link in","z":"b2524cfd.8c346","name":"From Input","links":["f902dc8c.c0f5"],"x":120,"y":180,"wires":[[]],"l":true},{"id":"61c33dd9.72a304","type":"link in","z":"b2524cfd.8c346","name":"Send to InfluxDB","links":["a3c4416d.b601"],"x":460,"y":80,"wires":[["431b4185.0978a"]],"l":true},{"id":"a3c4416d.b601","type":"link out","z":"b2524cfd.8c346","name":"Gather to Send to InfluxDB","links":["61c33dd9.72a304"],"x":1000,"y":180,"wires":[],"l":true},{"id":"f5d8d551.ede008","type":"config","z":"e58eb536.40cf18","name":"Mike iPad Config","properties":[{"p":"Floor","pt":"flow","to":"","tot":"str"},{"p":"Location","pt":"flow","to":"","tot":"str"},{"p":"Room","pt":"flow","to":"","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Tablet","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Apple","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Mike's iPad","tot":"str"}],"active":true,"x":130,"y":40,"wires":[]},{"id":"e52e72d9.77dbd","type":"link out","z":"e58eb536.40cf18","name":"Passthrough to enable subflow","links":["c370db50.96a6a8"],"x":210,"y":80,"wires":[],"l":true},{"id":"c370db50.96a6a8","type":"link in","z":"e58eb536.40cf18","name":"From Input","links":["e52e72d9.77dbd"],"x":120,"y":240,"wires":[[]],"l":true},{"id":"7ad30ab9.a08d44","type":"link in","z":"e58eb536.40cf18","name":"Send to InfluxDB","links":["b1aa9e10.607bc"],"x":460,"y":40,"wires":[["e517bc6f.c6b07"]],"l":true},{"id":"b1aa9e10.607bc","type":"link out","z":"e58eb536.40cf18","name":"Gather to Send to InfluxDB","links":["7ad30ab9.a08d44"],"x":660,"y":240,"wires":[],"l":true},{"id":"21dc7bb1.3018c4","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Mike's iPad","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":180,"y":660,"wires":[[]]},{"id":"4382ab65.32d5c4","type":"subflow:e58eb536.40cf18","z":"54cae49c.6ee04c","name":"","env":[],"x":510,"y":660,"wires":[]},{"id":"b220b27f.74863","type":"config","z":"390b8414.317d5c","name":"Mike Watch Uverse","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"TV Cabinet","tot":"str"},{"p":"Room","pt":"flow","to":"Living Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Harmony Activity","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Logitech","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Virtual","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Watch Uverse","tot":"str"}],"active":true,"x":130,"y":40,"wires":[]},{"id":"85febe11.1b0c4","type":"link out","z":"390b8414.317d5c","name":"Passthrough to enable subflow","links":["2e04bd85.69eeb2"],"x":210,"y":80,"wires":[],"l":true},{"id":"2e04bd85.69eeb2","type":"link in","z":"390b8414.317d5c","name":"From Input","links":["85febe11.1b0c4"],"x":120,"y":240,"wires":[[]],"l":true},{"id":"ddca54d.4009aa8","type":"link in","z":"390b8414.317d5c","name":"Send to InfluxDB","links":["5b1f1ef2.33108"],"x":460,"y":40,"wires":[["1a8414e7.a2d95b"]],"l":true},{"id":"5b1f1ef2.33108","type":"link out","z":"390b8414.317d5c","name":"Gather to Send to InfluxDB","links":["ddca54d.4009aa8"],"x":660,"y":240,"wires":[],"l":true},{"id":"4cda22a0.3e144c","type":"config","z":"9d03767a.9b0288","name":"Master Fan Config","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"North","tot":"str"},{"p":"Room","pt":"flow","to":"Master Bedroom","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"GE/Jasco","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Z-Wave","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Master Fan","tot":"str"}],"active":true,"x":130,"y":40,"wires":[]},{"id":"2cf48409.d5206c","type":"link out","z":"9d03767a.9b0288","name":"Passthrough to enable subflow","links":["85367e55.91cef"],"x":210,"y":80,"wires":[],"l":true},{"id":"85367e55.91cef","type":"link in","z":"9d03767a.9b0288","name":"From Input","links":["2cf48409.d5206c"],"x":120,"y":240,"wires":[[]],"l":true},{"id":"e17fce91.99404","type":"link in","z":"9d03767a.9b0288","name":"Send to InfluxDB","links":["a77c2f86.c3de8","a4b882d4.0cdf1"],"x":460,"y":40,"wires":[["880f4eef.b124"]],"l":true},{"id":"a77c2f86.c3de8","type":"link out","z":"9d03767a.9b0288","name":"Gather to Send to InfluxDB","links":["e17fce91.99404"],"x":660,"y":240,"wires":[],"l":true},{"id":"a4b882d4.0cdf1","type":"link out","z":"9d03767a.9b0288","name":"Gather to Send to InfluxDB","links":["e17fce91.99404"],"x":660,"y":360,"wires":[],"l":true},{"id":"3358554c.1795aa","type":"config","z":"f6aca0d2.59336","name":"Master Light Config","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"North","tot":"str"},{"p":"Room","pt":"flow","to":"Master Bedroom","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"GE/Jasco","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Z-Wave","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Master Overhead Light","tot":"str"}],"active":true,"x":130,"y":40,"wires":[]},{"id":"5170d88d.798268","type":"link out","z":"f6aca0d2.59336","name":"Passthrough to enable subflow","links":["b8b14809.3ad568"],"x":210,"y":80,"wires":[],"l":true},{"id":"b8b14809.3ad568","type":"link in","z":"f6aca0d2.59336","name":"From Input","links":["5170d88d.798268"],"x":120,"y":240,"wires":[[]],"l":true},{"id":"6e6e650f.f0941c","type":"link in","z":"f6aca0d2.59336","name":"Send to InfluxDB","links":["c119142f.cb8b98","84a32ed6.63e07"],"x":460,"y":40,"wires":[["82225621.d06838"]],"l":true},{"id":"c119142f.cb8b98","type":"link out","z":"f6aca0d2.59336","name":"Gather to Send to InfluxDB","links":["6e6e650f.f0941c"],"x":740,"y":240,"wires":[],"l":true},{"id":"84a32ed6.63e07","type":"link out","z":"f6aca0d2.59336","name":"Gather to Send to InfluxDB","links":["6e6e650f.f0941c"],"x":740,"y":320,"wires":[],"l":true},{"id":"2a26cc26.73d424","type":"config","z":"d2615560.b868a8","name":"Cube 1 Config","properties":[{"p":"Floor","pt":"flow","to":"2","tot":"str"},{"p":"Location","pt":"flow","to":"Mike's Desk","tot":"str"},{"p":"Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Cube","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Aqara","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Cube 1","tot":"str"}],"active":true,"x":120,"y":40,"wires":[]},{"id":"bec0b04e.e9c99","type":"link out","z":"d2615560.b868a8","name":"Passthrough to enable subflow","links":["fbb03213.7fb68"],"x":210,"y":80,"wires":[],"l":true},{"id":"fbb03213.7fb68","type":"link in","z":"d2615560.b868a8","name":"From Input","links":["bec0b04e.e9c99"],"x":120,"y":160,"wires":[[]],"l":true},{"id":"59292639.59e498","type":"link in","z":"d2615560.b868a8","name":"Send to InfluxDB","links":["826a0842.643058","cab50e7b.3eeb2","abf5b2a7.c1a6d"],"x":460,"y":40,"wires":[["eaa835c1.1fa838"]],"l":true},{"id":"826a0842.643058","type":"link out","z":"d2615560.b868a8","name":"Gather to Send to InfluxDB","links":["59292639.59e498"],"x":740,"y":160,"wires":[],"l":true},{"id":"cab50e7b.3eeb2","type":"link out","z":"d2615560.b868a8","name":"Gather to Send to InfluxDB","links":["59292639.59e498"],"x":740,"y":280,"wires":[],"l":true},{"id":"abf5b2a7.c1a6d","type":"link out","z":"d2615560.b868a8","name":"Gather to Send to InfluxDB","links":["59292639.59e498"],"x":740,"y":440,"wires":[],"l":true},{"id":"4a287e32.ab679","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Watch Uverse","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":180,"y":720,"wires":[[]]},{"id":"6420300d.1687a","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Master Fan","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":180,"y":780,"wires":[[]]},{"id":"59cc8cf0.2fdf04","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Light Overhead","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":190,"y":840,"wires":[[]]},{"id":"9a75b54f.97b8d8","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Cube 1","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":160,"y":900,"wires":[[]]},{"id":"aab73ad2.720dd8","type":"subflow:390b8414.317d5c","z":"54cae49c.6ee04c","name":"","env":[],"x":520,"y":720,"wires":[]},{"id":"36caa5b4.f40baa","type":"subflow:9d03767a.9b0288","z":"54cae49c.6ee04c","name":"","env":[],"x":510,"y":780,"wires":[]},{"id":"c5668637.28d518","type":"subflow:f6aca0d2.59336","z":"54cae49c.6ee04c","name":"","env":[],"x":520,"y":840,"wires":[]},{"id":"bacfddc1.92e44","type":"subflow:d2615560.b868a8","z":"54cae49c.6ee04c","name":"","env":[],"x":500,"y":900,"wires":[]},{"id":"f82d697d.2c2fa8","type":"link out","z":"5364e86b.44e3a8","name":"Gather to Send to InfluxDB","links":["adb2bdd.7f92f4"],"x":780,"y":1520,"wires":[],"l":true},{"id":"431b4185.0978a","type":"function","z":"b2524cfd.8c346","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":700,"y":80,"wires":[["c8be3f1a.40f2c"]]},{"id":"805045fa.94f318","type":"function","z":"89f52889.bf1478","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":700,"y":40,"wires":[["5a07a5bc.19bd4c"]]},{"id":"6f819c50.8d9204","type":"function","z":"4e2f0c22.b816c4","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":663,"y":40,"wires":[["1c9129b5.ebcec6"]]},{"id":"e0cf241e.5c4588","type":"function","z":"ae851807.40c0e8","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":680,"y":40,"wires":[["c8105a83.108b58"]]},{"id":"5e0f03d2.a6dbfc","type":"function","z":"92d72719.56bd38","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":660,"y":40,"wires":[["8763437a.22844"]]},{"id":"8ccd32e5.c587f","type":"function","z":"fd34e084.87e19","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":660,"y":40,"wires":[["e180fc6a.c43cf"]]},{"id":"e517bc6f.c6b07","type":"function","z":"e58eb536.40cf18","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":660,"y":40,"wires":[["f00d5586.4300c8"]]},{"id":"1a8414e7.a2d95b","type":"function","z":"390b8414.317d5c","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":660,"y":40,"wires":[["3c2795d.5d10d6a"]]},{"id":"880f4eef.b124","type":"function","z":"9d03767a.9b0288","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":660,"y":40,"wires":[["4b52a2a3.15145c"]]},{"id":"82225621.d06838","type":"function","z":"f6aca0d2.59336","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":660,"y":40,"wires":[["1a11f17b.d7527f"]]},{"id":"eaa835c1.1fa838","type":"function","z":"d2615560.b868a8","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":660,"y":40,"wires":[["a9acec0f.71f8f"]]},{"id":"48280e6.4b5f8f","type":"hubitat command","z":"ba901384.9c229","name":"Gtest G means Off","server":"55e4481a.722098","deviceId":"643","command":"on","commandArgs":"","x":290,"y":480,"wires":[[]]},{"id":"c9f6059f.e379f8","type":"hubitat command","z":"ba901384.9c229","name":"Mike Credenza Light","server":"55e4481a.722098","deviceId":"388","command":"on","commandArgs":"","x":300,"y":540,"wires":[[]]},{"id":"e8b687a1.a42138","type":"hubitat command","z":"ba901384.9c229","name":"Game Room Floor Lamp","server":"55e4481a.722098","deviceId":"357","command":"on","commandArgs":"","x":310,"y":600,"wires":[[]]},{"id":"500c0a87.ae1054","type":"hubitat command","z":"ba901384.9c229","name":"Office Desk Lamp","server":"55e4481a.722098","deviceId":"550","command":"on","commandArgs":"","x":290,"y":660,"wires":[[]]},{"id":"b6b2303f.101b","type":"hubitat command","z":"ba901384.9c229","name":"Gtest Gdev Means On","server":"55e4481a.722098","deviceId":"642","command":"on","commandArgs":"","x":300,"y":420,"wires":[[]]},{"id":"aaa0339f.cdded","type":"hubitat command","z":"ba901384.9c229","name":"Gtest No GDev","server":"55e4481a.722098","deviceId":"641","command":"on","commandArgs":"","x":280,"y":360,"wires":[[]]},{"id":"f87d4745.b81a38","type":"inject","z":"ba901384.9c229","name":"On","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":90,"y":360,"wires":[["aaa0339f.cdded"]]},{"id":"9df82d1c.36624","type":"inject","z":"ba901384.9c229","name":"On","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":90,"y":420,"wires":[["b6b2303f.101b"]]},{"id":"9c9af3ef.6f736","type":"inject","z":"ba901384.9c229","name":"On","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":90,"y":480,"wires":[["48280e6.4b5f8f"]]},{"id":"56aab2b0.3a2edc","type":"inject","z":"ba901384.9c229","name":"On","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":90,"y":540,"wires":[["c9f6059f.e379f8"]]},{"id":"93590ab3.3f04e8","type":"inject","z":"ba901384.9c229","name":"On","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":90,"y":600,"wires":[["e8b687a1.a42138"]]},{"id":"18ad49bb.a479a6","type":"inject","z":"ba901384.9c229","name":"On","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":90,"y":660,"wires":[["500c0a87.ae1054"]]},{"id":"200f6f58.d6c3d","type":"hubitat device","z":"ba901384.9c229","name":"Gtest No GDev","server":"55e4481a.722098","deviceId":"641","attribute":"switch","sendEvent":true,"x":1080,"y":360,"wires":[["212b934f.1dc90c"]]},{"id":"147578c5.a0eea7","type":"hubitat device","z":"ba901384.9c229","name":"Gtest Gdev Means On","server":"55e4481a.722098","deviceId":"642","attribute":"switch","sendEvent":true,"x":1100,"y":420,"wires":[["212b934f.1dc90c"]]},{"id":"866808c.99164f8","type":"hubitat device","z":"ba901384.9c229","name":"Gtest G means Off","server":"55e4481a.722098","deviceId":"643","attribute":"switch","sendEvent":true,"x":1090,"y":480,"wires":[["212b934f.1dc90c"]]},{"id":"5188f00d.25866","type":"hubitat device","z":"ba901384.9c229","name":"Mike Credenza Light","server":"55e4481a.722098","deviceId":"388","attribute":"switch","sendEvent":true,"x":1100,"y":540,"wires":[["212b934f.1dc90c"]]},{"id":"212b934f.1dc90c","type":"debug","z":"ba901384.9c229","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":1390,"y":520,"wires":[]},{"id":"9bf8d69c.f7b118","type":"hubitat device","z":"ba901384.9c229","name":"Game Room Floor Lamp","server":"55e4481a.722098","deviceId":"357","attribute":"switch","sendEvent":true,"x":1110,"y":600,"wires":[["212b934f.1dc90c"]]},{"id":"4b466402.b3558c","type":"hubitat device","z":"ba901384.9c229","name":"Office Desk Lamp","server":"55e4481a.722098","deviceId":"550","attribute":"switch","sendEvent":true,"x":1090,"y":660,"wires":[["212b934f.1dc90c"]]},{"id":"dbc5b992.333ab8","type":"hubitat command","z":"ba901384.9c229","name":"Gtest G means Off","server":"55e4481a.722098","deviceId":"643","command":"off","commandArgs":"","x":790,"y":480,"wires":[[]]},{"id":"3da8e023.86b37","type":"hubitat command","z":"ba901384.9c229","name":"Mike Credenza Light","server":"55e4481a.722098","deviceId":"388","command":"off","commandArgs":"","x":800,"y":540,"wires":[[]]},{"id":"8c313ad5.2bef78","type":"hubitat command","z":"ba901384.9c229","name":"Game Room Floor Lamp","server":"55e4481a.722098","deviceId":"357","command":"off","commandArgs":"","x":810,"y":600,"wires":[[]]},{"id":"1f061d5e.203863","type":"hubitat command","z":"ba901384.9c229","name":"Office Desk Lamp","server":"55e4481a.722098","deviceId":"550","command":"off","commandArgs":"","x":790,"y":660,"wires":[[]]},{"id":"7eaf27db.b1e468","type":"hubitat command","z":"ba901384.9c229","name":"Gtest Gdev Means On","server":"55e4481a.722098","deviceId":"642","command":"off","commandArgs":"","x":800,"y":420,"wires":[[]]},{"id":"db856b74.7d3d08","type":"hubitat command","z":"ba901384.9c229","name":"Gtest No GDev","server":"55e4481a.722098","deviceId":"641","command":"off","commandArgs":"","x":780,"y":360,"wires":[[]]},{"id":"ff3158b4.375c18","type":"inject","z":"ba901384.9c229","name":"Off","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":590,"y":360,"wires":[["db856b74.7d3d08"]]},{"id":"b93c45f.44382b8","type":"inject","z":"ba901384.9c229","name":"Off","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":590,"y":420,"wires":[["7eaf27db.b1e468"]]},{"id":"71cad30b.5ea08c","type":"inject","z":"ba901384.9c229","name":"Off","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":590,"y":480,"wires":[["dbc5b992.333ab8"]]},{"id":"d3ad3954.147928","type":"inject","z":"ba901384.9c229","name":"Off","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":590,"y":540,"wires":[["3da8e023.86b37"]]},{"id":"1bdcad74.5a4fa3","type":"inject","z":"ba901384.9c229","name":"Off","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":590,"y":600,"wires":[["8c313ad5.2bef78"]]},{"id":"4f5fa70f.0d4e78","type":"inject","z":"ba901384.9c229","name":"Off","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":590,"y":660,"wires":[["1f061d5e.203863"]]},{"id":"db5d9766.57c9f8","type":"inject","z":"1a0aa13a.9d7b8f","name":"Initiate Check every 5 sec","topic":"","payload":"1","payloadType":"num","repeat":"5","crontab":"","once":true,"onceDelay":0.1,"x":180,"y":100,"wires":[["da8cbc87.ae3a5"]]},{"id":"de53fc38.e8dfb","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Start/Restart","group":"18f340fe.a70a3f","order":1,"width":3,"height":1,"passthru":false,"label":"Start/Restart","tooltip":"","color":"","bgcolor":"Green","icon":"","payload":"1","payloadType":"num","topic":"","x":90,"y":220,"wires":[["92dd4796.6f9b78"]]},{"id":"876a7f0f.97ec","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Manual Update Frisco","group":"18f340fe.a70a3f","order":3,"width":3,"height":1,"passthru":false,"label":"Update Frisco","tooltip":"","color":"","bgcolor":"#163e80","icon":"","payload":"1","payloadType":"num","topic":"","x":120,"y":460,"wires":[["e3a36dc7.11be4"]]},{"id":"92dd4796.6f9b78","type":"function","z":"1a0aa13a.9d7b8f","name":"flow.set(\"status\",\"run\");","func":"flow.set(\"status\",\"run\");\nreturn msg;","outputs":1,"noerr":0,"x":280,"y":220,"wires":[[]]},{"id":"b95d43d.3a36dc","type":"function","z":"1a0aa13a.9d7b8f","name":"flow.set(\"status\",\"stopped\");","func":"flow.set(\"status\",\"stopped\");\nreturn msg;","outputs":1,"noerr":0,"x":300,"y":300,"wires":[[]]},{"id":"da8cbc87.ae3a5","type":"function","z":"1a0aa13a.9d7b8f","name":"Pass request if status is run","func":"var status = flow.get(\"status\")||\"stopped\";\n\nif (status==\"run\") {\n   msg.payload = 1;\n   return msg;\n}","outputs":1,"noerr":0,"x":440,"y":100,"wires":[["2c536eac.962c32"]]},{"id":"cccb923b.d858e","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"No filter","group":"4baf1468.abb01c","order":1,"width":0,"height":0,"passthru":false,"label":"No filter","tooltip":"","color":"","bgcolor":"","icon":"","payload":"1","payloadType":"num","topic":"none","x":80,"y":660,"wires":[["d5ba20b1.2a352"]]},{"id":"aa86cd79.d94ad","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"DFW","group":"4baf1468.abb01c","order":2,"width":3,"height":1,"passthru":false,"label":"DFW","tooltip":"Dallas/Fort Worth","color":"","bgcolor":"#163e80","icon":"","payload":"1","payloadType":"num","topic":"DFW","x":70,"y":700,"wires":[["d5ba20b1.2a352"]]},{"id":"27435c82.f51e34","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"DAL","group":"4baf1468.abb01c","order":3,"width":3,"height":1,"passthru":false,"label":"DAL","tooltip":"Love Field","color":"","bgcolor":"#dec733","icon":"","payload":"1","payloadType":"num","topic":"DAL","x":70,"y":740,"wires":[["d5ba20b1.2a352"]]},{"id":"d5ba20b1.2a352","type":"function","z":"1a0aa13a.9d7b8f","name":"","func":"flow.set(\"filter\",msg.topic);\nreturn msg;","outputs":1,"noerr":0,"x":250,"y":660,"wires":[["93bd58c2.f4fe18"]]},{"id":"93bd58c2.f4fe18","type":"function","z":"1a0aa13a.9d7b8f","name":"Clear the map","func":"var command = {clear :(\"Planes\")};\nmsg.payload ={command};\nreturn msg;","outputs":1,"noerr":0,"x":440,"y":620,"wires":[["be318435.10d8b8"]]},{"id":"caee0f1a.07ba8","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"AUS","group":"4baf1468.abb01c","order":4,"width":3,"height":1,"passthru":false,"label":"AUS","tooltip":"Austin","color":"","bgcolor":"#e3a209","icon":"","payload":"1","payloadType":"num","topic":"AUS","x":70,"y":780,"wires":[["d5ba20b1.2a352"]]},{"id":"f9d66341.1059a","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"ADK","group":"4baf1468.abb01c","order":5,"width":3,"height":1,"passthru":false,"label":"ADK","tooltip":"Adak","color":"black","bgcolor":"#03fff2","icon":"","payload":"1","payloadType":"num","topic":"ADK","x":70,"y":820,"wires":[["d5ba20b1.2a352"]]},{"id":"8e440b7b.6ab8f8","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Clear Map","group":"18f340fe.a70a3f","order":6,"width":3,"height":1,"passthru":false,"label":"Clear Map","tooltip":"","color":"","bgcolor":"","icon":"","payload":"unknown","payloadType":"str","topic":"","x":90,"y":620,"wires":[["93bd58c2.f4fe18"]]},{"id":"4140806e.6466f","type":"function","z":"1a0aa13a.9d7b8f","name":"","func":"flow.set(\"filter_ac_type\",msg.topic);\nreturn msg;","outputs":1,"noerr":0,"x":250,"y":860,"wires":[["93bd58c2.f4fe18"]]},{"id":"ba4470ea.c6f46","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"No filter","group":"9cbb54f5.392db8","order":1,"width":"0","height":"0","passthru":false,"label":"No filter","tooltip":"","color":"","bgcolor":"","icon":"","payload":"1","payloadType":"num","topic":"none","x":80,"y":861,"wires":[["4140806e.6466f"]]},{"id":"f7bd0619.7b5958","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"E75L","group":"9cbb54f5.392db8","order":5,"width":3,"height":1,"passthru":false,"label":"E75L","tooltip":"E75L","color":"","bgcolor":"tan","icon":"","payload":"1","payloadType":"num","topic":"E75L","x":70,"y":980,"wires":[["4140806e.6466f"]]},{"id":"cd272b01.efcf38","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"CRJ9","group":"9cbb54f5.392db8","order":4,"width":3,"height":1,"passthru":false,"label":"CRJ9","tooltip":"CRJ9","color":"","bgcolor":"tan","icon":"","payload":"1","payloadType":"num","topic":"CRJ9","x":70,"y":940,"wires":[["4140806e.6466f"]]},{"id":"6ac93ca1.3b5044","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"B738","group":"9cbb54f5.392db8","order":11,"width":3,"height":1,"passthru":false,"label":"B738","tooltip":"B738","color":"","bgcolor":"tan","icon":"","payload":"1","payloadType":"num","topic":"B738","x":70,"y":900,"wires":[["4140806e.6466f"]]},{"id":"2069470f.ed9d38","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"PC12","group":"9cbb54f5.392db8","order":6,"width":3,"height":1,"passthru":false,"label":"PC12","tooltip":"PC12","color":"","bgcolor":"tan","icon":"","payload":"1","payloadType":"num","topic":"PC12","x":70,"y":1020,"wires":[["4140806e.6466f"]]},{"id":"70e6c475.1c4e3c","type":"inject","z":"1a0aa13a.9d7b8f","name":"Starutp","topic":"","payload":"1","payloadType":"num","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":120,"y":60,"wires":[["6a58e276.4439bc"]]},{"id":"6a58e276.4439bc","type":"function","z":"1a0aa13a.9d7b8f","name":"Set Initial Conditions","func":"flow.set(\"status\",\"stopped\");\nflow.set(\"filter\",\"none\");\nflow.set(\"filter_ac_type\",\"none\");\nflow.set(\"Flights\",0);\nflow.set(\"Unnamed\",0);\nreturn msg;","outputs":1,"noerr":0,"x":420,"y":60,"wires":[[]]},{"id":"e0dbb5f4.ea61a8","type":"inject","z":"1a0aa13a.9d7b8f","name":"Put static items","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":1100,"y":420,"wires":[["ae3e0ad9.38d3d8","40300d96.260ec4","f8753462.d6e958","df986dbb.427e1","f4d88d0e.bab43","b79ed39b.475ae"]]},{"id":"40300d96.260ec4","type":"change","z":"1a0aa13a.9d7b8f","name":"Ashmont 5 mile Ring","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"name\":\"Ashmont 5 Mile Ring\",\"lat\":33.110554,\"lon\":-96.790415,\"radius\":8047,\"layer\":\"Guides\",\"stroke\":true,\"fill\":false,\"color\":\"#163e80\"}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":1360,"y":500,"wires":[["65c68644.d9f5f8"]]},{"id":"df986dbb.427e1","type":"change","z":"1a0aa13a.9d7b8f","name":"Round Rock  5 mile ring","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"name\":\"Round Rock 5 Mile Ring\",\"lat\":30.580425,\"lon\":-97.6687,\"radius\":8047,\"layer\":\"Guides\",\"color\":\"#e3a209\",\"stroke\":true,\"fill\":false}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":1370,"y":580,"wires":[["65c68644.d9f5f8"]]},{"id":"ae3e0ad9.38d3d8","type":"change","z":"1a0aa13a.9d7b8f","name":"Ashmont +-1degree box","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"name\":\"Ashmont 2 degree box\",\"area\":[[34.110554,-95.790415],[32.110554,-97.790415]],\"layer\":\"Guides\",\"color\":\"#163e80\",\"stroke\":true,\"fill\":false}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":1370,"y":460,"wires":[["65c68644.d9f5f8"]]},{"id":"f8753462.d6e958","type":"change","z":"1a0aa13a.9d7b8f","name":"Round Rock +-1degree box","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"name\":\"Round Rock 2 degree box\",\"area\":[[31.580425,-96.6687],[29.580425,-98.6687]],\"layer\":\"Guides\",\"color\":\"#e3a209\",\"stroke\":true,\"fill\":false}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":1380,"y":540,"wires":[["65c68644.d9f5f8"]]},{"id":"f4d88d0e.bab43","type":"change","z":"1a0aa13a.9d7b8f","name":"Adak +-1degree box","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"name\":\"Adak 2 degree box\",\"area\":[[52.881211,-175.645945],[50.881211,-177.645945]],\"layer\":\"Guides\",\"color\":\"#42e6f5\",\"stroke\":true,\"fill\":false}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":1360,"y":620,"wires":[["65c68644.d9f5f8"]]},{"id":"8649aebd.474bf","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Manual Update Round Rock","group":"18f340fe.a70a3f","order":4,"width":3,"height":1,"passthru":false,"label":"Update Round Rock","tooltip":"","color":"","bgcolor":"#e3a209","icon":"","payload":"2","payloadType":"num","topic":"","x":140,"y":380,"wires":[["e3a36dc7.11be4"]]},{"id":"c190d566.420e98","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Manual Update Adak","group":"18f340fe.a70a3f","order":5,"width":3,"height":1,"passthru":false,"label":"Update Adak","tooltip":"","color":"black","bgcolor":"#03fff2","icon":"","payload":"3","payloadType":"num","topic":"","x":120,"y":540,"wires":[["e3a36dc7.11be4"]]},{"id":"65c68644.d9f5f8","type":"link out","z":"1a0aa13a.9d7b8f","name":"","links":["1d42282.fe857d8","ee484184.496fc"],"x":1615,"y":540,"wires":[]},{"id":"be318435.10d8b8","type":"link out","z":"1a0aa13a.9d7b8f","name":"","links":["ee484184.496fc","9524e728.08d2c8"],"x":555,"y":620,"wires":[]},{"id":"e087c831.86ec18","type":"worldmap in","z":"1a0aa13a.9d7b8f","name":"","path":"/worldmapF","events":"","x":780,"y":620,"wires":[["f30ac03a.0ad73"]]},{"id":"ffbec31e.59c3e","type":"worldmap","z":"1a0aa13a.9d7b8f","name":"","lat":"","lon":"","zoom":"9","layer":"","cluster":"9","maxage":"10","usermenu":"hide","layers":"hide","panit":"false","panlock":"false","zoomlock":"false","hiderightclick":"false","coords":"none","showgrid":"false","path":"/worldmapF","x":1530,"y":180,"wires":[]},{"id":"80419bfc.5b1768","type":"change","z":"1a0aa13a.9d7b8f","name":"Adak","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"command\":{\"zoom\":9,\"lat\":51.881211,\"lon\":-176.645945}}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":950,"y":780,"wires":[["a93f4f39.d0072"]]},{"id":"190bf318.1a650d","type":"inject","z":"1a0aa13a.9d7b8f","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":755,"y":780,"wires":[["80419bfc.5b1768"]],"l":false},{"id":"fa8f9937.f27ee8","type":"change","z":"1a0aa13a.9d7b8f","name":"Round Rock","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"command\":{\"zoom\":9,\"lat\":30.580425,\"lon\":-97.6687}}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":970,"y":860,"wires":[["a93f4f39.d0072"]]},{"id":"1a1fa532.ab215b","type":"inject","z":"1a0aa13a.9d7b8f","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":755,"y":860,"wires":[["fa8f9937.f27ee8"]],"l":false},{"id":"b4b2bf95.3b1ee","type":"change","z":"1a0aa13a.9d7b8f","name":"Frisco","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"command\":{\"zoom\":9,\"lat\":33.110554,\"lon\":-96.790415}}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":950,"y":940,"wires":[["a93f4f39.d0072"]]},{"id":"bf385b8.2b4ada8","type":"inject","z":"1a0aa13a.9d7b8f","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":755,"y":940,"wires":[["b4b2bf95.3b1ee"]],"l":false},{"id":"e407c2b6.a946a","type":"comment","z":"1a0aa13a.9d7b8f","name":"Center Map Manually or View Dashboard","info":"","x":880,"y":720,"wires":[]},{"id":"f30ac03a.0ad73","type":"switch","z":"1a0aa13a.9d7b8f","name":"Put Static Items upon connection","property":"payload.action","propertyType":"msg","rules":[{"t":"eq","v":"other","vt":"str"},{"t":"eq","v":"connected","vt":"str"},{"t":"eq","v":"blah","vt":"str"}],"checkall":"true","repair":false,"outputs":3,"x":1040,"y":620,"wires":[[],["ae3e0ad9.38d3d8","40300d96.260ec4","f8753462.d6e958","df986dbb.427e1","f4d88d0e.bab43","f597fefe.493b4","b79ed39b.475ae"],[]]},{"id":"3c198e04.951cf2","type":"comment","z":"1a0aa13a.9d7b8f","name":"Place Static Items","info":"","x":810,"y":380,"wires":[]},{"id":"d9c4756d.4912a8","type":"function","z":"1a0aa13a.9d7b8f","name":"Fix Null names, Color Aircraft, filter","func":"msg.payload.layer = \"Planes\"\nmsg.payload.iconColor = \"#111212\"\nif (msg.payload.name === null) {\n    msg.payload.name = \"Call Sign \" + msg.payload.callsign\n}\nif (msg.payload.destination == \"DFW\") {\n    msg.payload.iconColor = \"#4287f5\";\n} else if (msg.payload.destination == \"DAL\") {\n    msg.payload.iconColor = \"#dec733\";\n} else if (msg.payload.origin == \"DFW\") {\n    msg.payload.iconColor = \"#163e80\";\n} else if (msg.payload.origin == \"DAL\") {\n    msg.payload.iconColor = \"#6b6015\";\n} else if (msg.payload.destination == \"AUS\") {\n    msg.payload.iconColor = \"#e3a209\";\n} else if (msg.payload.origin == \"AUS\") {\n    msg.payload.iconColor = \"#6e520f\";\n} else if (msg.payload.destination == \"ADK\") {\n    msg.payload.iconColor = \"#03fff2\";\n} else if (msg.payload.origin == \"ADK\") {\n    msg.payload.iconColor = \"#026e68\";\n}\nvar flightcount = flow.get(\"Flights\")\nflightcount++\nflow.set(\"Flights\", flightcount)\nvar filter = flow.get(\"filter\");\nvar filter_ac_type = flow.get(\"filter_ac_type\");\n\nif ((msg.payload.origin == filter) || (msg.payload.destination == filter) || (\"none\" == filter)) {\n    if ((msg.payload.model == filter_ac_type) || (\"none\" == filter_ac_type)) {\n        return msg;\n    }\n}","outputs":1,"noerr":0,"x":1280,"y":140,"wires":[["35c05549.6bfb8a","ffbec31e.59c3e"]]},{"id":"f597fefe.493b4","type":"change","z":"1a0aa13a.9d7b8f","name":"Adak Ct 1 meter ring","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"name\":\"Courmayeur Ct 5 Mile Ring\",\"lat\":51.8812115,\"lon\":-176.645945,\"radius\":1,\"layer\":\"Guides\",\"color\":\"#42e6f5\",\"stroke\":true,\"fill\":false}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":1360,"y":660,"wires":[["65c68644.d9f5f8"]]},{"id":"ee484184.496fc","type":"link in","z":"1a0aa13a.9d7b8f","name":"Send Update to Map","links":["65c68644.d9f5f8","be318435.10d8b8","a93f4f39.d0072"],"x":1395,"y":180,"wires":[["ffbec31e.59c3e"]]},{"id":"c1a95748.60dee8","type":"inject","z":"1a0aa13a.9d7b8f","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":860,"y":300,"wires":[["e8dfc379.a198b"]]},{"id":"deb62833.319248","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Pause","group":"18f340fe.a70a3f","order":2,"width":3,"height":1,"passthru":false,"label":"Pause","tooltip":"","color":"black","bgcolor":"Yellow","icon":"","payload":"1","payloadType":"num","topic":"","x":70,"y":300,"wires":[["b95d43d.3a36dc"]]},{"id":"23f14bb4.2a9524","type":"change","z":"1a0aa13a.9d7b8f","name":"Frisco Close","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"command\":{\"zoom\":12,\"lat\":33.110554,\"lon\":-96.790415}}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":970,"y":1020,"wires":[["a93f4f39.d0072"]]},{"id":"32ca5c62.a67e44","type":"inject","z":"1a0aa13a.9d7b8f","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":755,"y":1020,"wires":[["23f14bb4.2a9524"]],"l":false},{"id":"b79ed39b.475ae","type":"change","z":"1a0aa13a.9d7b8f","name":"Ashmont Home","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"name\":\"Home\",\"lat\":33.110555,\"lon\":-96.790415,\"radius\":0,\"layer\":\"House\",\"stroke\":true,\"fill\":false,\"color\":\"red\",\"icon\":\"home\"}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":1340,"y":420,"wires":[["65c68644.d9f5f8"]]},{"id":"b7d336e3.07e088","type":"join","z":"1a0aa13a.9d7b8f","name":"","mode":"custom","build":"array","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"3","count":"","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1190,"y":100,"wires":[["6837dde8.0c0a64"]]},{"id":"6837dde8.0c0a64","type":"ui_table","z":"1a0aa13a.9d7b8f","group":"e298b809.c3c2f8","name":"Before mod","order":1,"width":"22","height":"7","columns":[{"field":"name","title":"Name","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"iconColor","title":"Icon Color","width":"105","align":"left","formatter":"color","formatterParams":{"target":"_blank"}},{"field":"id","title":"ID","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"registration","title":"Reg","width":"70","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"flight","title":"Flight","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"callsign","title":"Call Sign","width":"95","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"origin","title":"Origin","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"destination","title":"Destination","width":"110","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"altitude","title":"Altitude","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"bearing","title":"Bearing","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"speed","title":"Speed","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"rateOfClimb","title":"Rate of Climb","width":"125","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"isOnGround","title":"On Ground","width":"110","align":"left","formatter":"tickCross","formatterParams":{"target":"_blank"}},{"field":"squawkCode","title":"Squawk","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"model","title":"Model","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"modeSCode","title":"Mode S","width":"95","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"radar","title":"Radar","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"timestamp","title":"Timestamp","width":"110","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"lat","title":"Latitude","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"lon","title":"Longitude","width":"110","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}}],"outputs":0,"cts":false,"x":1670,"y":101,"wires":[]},{"id":"35c05549.6bfb8a","type":"join","z":"1a0aa13a.9d7b8f","name":"","mode":"custom","build":"array","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"3","count":"","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1510,"y":141,"wires":[["cf54cd13.c8b4c"]]},{"id":"cf54cd13.c8b4c","type":"ui_table","z":"1a0aa13a.9d7b8f","group":"2a128af6.d72c46","name":"After Mod","order":2,"width":"22","height":"7","columns":[{"field":"name","title":"Name","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"iconColor","title":"Icon Color","width":"105","align":"left","formatter":"color","formatterParams":{"target":"_blank"}},{"field":"id","title":"ID","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"registration","title":"Reg","width":"70","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"flight","title":"Flight","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"callsign","title":"Call Sign","width":"95","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"origin","title":"Origin","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"destination","title":"Destination","width":"110","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"altitude","title":"Altitude","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"bearing","title":"Bearing","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"speed","title":"Speed","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"rateOfClimb","title":"Rate of Climb","width":"125","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"isOnGround","title":"On Ground","width":"110","align":"left","formatter":"tickCross","formatterParams":{"target":"_blank"}},{"field":"squawkCode","title":"Squawk","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"model","title":"Model","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"modeSCode","title":"Mode S","width":"95","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"radar","title":"Radar","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"timestamp","title":"Timestamp","width":"110","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"lat","title":"Latitude","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"lon","title":"Longitude","width":"110","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}}],"outputs":0,"cts":false,"x":1660,"y":141,"wires":[]},{"id":"cb24235e.8e734","type":"flightradar24","z":"1a0aa13a.9d7b8f","lat":"33.110554","latType":"num","lon":"-96.790415","lonType":"num","name":"Frisco","x":830,"y":140,"wires":[["828d7df1.ced63","b7d336e3.07e088","d9c4756d.4912a8"]]},{"id":"1bb63a9a.228e25","type":"flightradar24","z":"1a0aa13a.9d7b8f","lat":"30.580425","latType":"num","lon":"-97.6687","lonType":"num","name":"Round Rock","x":850,"y":100,"wires":[["828d7df1.ced63","b7d336e3.07e088","d9c4756d.4912a8"]]},{"id":"8231f6f8.f19dc8","type":"flightradar24","z":"1a0aa13a.9d7b8f","lat":"51.881211","latType":"num","lon":"-176.645945","lonType":"num","name":"Adak","x":830,"y":180,"wires":[["828d7df1.ced63","b7d336e3.07e088","d9c4756d.4912a8"]]},{"id":"ddcdc7a9.5ce8e8","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Frisco","group":"602d7c75.e52ed4","order":1,"width":3,"height":1,"passthru":false,"label":"Frisco","tooltip":"","color":"","bgcolor":"#163e80","icon":"","payload":"1","payloadType":"num","topic":"","x":770,"y":980,"wires":[["b4b2bf95.3b1ee"]]},{"id":"643b8a51.1824d4","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Ashmont","group":"602d7c75.e52ed4","order":1,"width":3,"height":1,"passthru":false,"label":"Ashmont","tooltip":"","color":"","bgcolor":"#163e80","icon":"","payload":"1","payloadType":"num","topic":"","x":780,"y":1060,"wires":[["23f14bb4.2a9524"]]},{"id":"275ee96d.2d18c6","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Round Rock","group":"602d7c75.e52ed4","order":1,"width":3,"height":1,"passthru":false,"label":"Round Rock","tooltip":"","color":"","bgcolor":"#e3a209","icon":"","payload":"1","payloadType":"num","topic":"","x":790,"y":900,"wires":[["fa8f9937.f27ee8"]]},{"id":"8a0cf593.496128","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Adak","group":"602d7c75.e52ed4","order":1,"width":3,"height":1,"passthru":false,"label":"Adak","tooltip":"","color":"black","bgcolor":"#03fff2","icon":"","payload":"1","payloadType":"num","topic":"","x":770,"y":820,"wires":[["80419bfc.5b1768"]]},{"id":"e7d8ec72.7f72c","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Start/Restart","group":"a4570963.5547f8","order":1,"width":3,"height":1,"passthru":false,"label":"Start/Restart","tooltip":"","color":"","bgcolor":"Green","icon":"","payload":"1","payloadType":"num","topic":"","x":90,"y":260,"wires":[["92dd4796.6f9b78"]]},{"id":"f2f3203e.fb7b3","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Pause","group":"a4570963.5547f8","order":2,"width":3,"height":1,"passthru":false,"label":"Pause","tooltip":"","color":"black","bgcolor":"Yellow","icon":"","payload":"1","payloadType":"num","topic":"","x":70,"y":340,"wires":[["b95d43d.3a36dc"]]},{"id":"b80a6cf0.92a58","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Manual Update Frisco","group":"a4570963.5547f8","order":3,"width":3,"height":1,"passthru":false,"label":"Update Frisco","tooltip":"","color":"","bgcolor":"#163e80","icon":"","payload":"1","payloadType":"num","topic":"","x":120,"y":500,"wires":[["e3a36dc7.11be4"]]},{"id":"d499fa12.02bb28","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Manual Update Round Rock","group":"a4570963.5547f8","order":4,"width":3,"height":1,"passthru":false,"label":"Update Round Rock","tooltip":"","color":"","bgcolor":"#e3a209","icon":"","payload":"2","payloadType":"num","topic":"","x":140,"y":420,"wires":[["e3a36dc7.11be4"]]},{"id":"9b0185ef.894958","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Manual Update Adak","group":"a4570963.5547f8","order":5,"width":3,"height":1,"passthru":false,"label":"Update Adak","tooltip":"","color":"black","bgcolor":"#03fff2","icon":"","payload":"3","payloadType":"num","topic":"","x":120,"y":580,"wires":[["e3a36dc7.11be4"]]},{"id":"9524e728.08d2c8","type":"link in","z":"1a0aa13a.9d7b8f","name":"Trigger FR for All 3 locations","links":["2c536eac.962c32","e3a36dc7.11be4","e8dfc379.a198b","be318435.10d8b8"],"x":655,"y":140,"wires":[["cb24235e.8e734","1bb63a9a.228e25","8231f6f8.f19dc8"]]},{"id":"e3a36dc7.11be4","type":"link out","z":"1a0aa13a.9d7b8f","name":"Go to FR for All 3 Locations","links":["9524e728.08d2c8"],"x":355,"y":480,"wires":[]},{"id":"e8dfc379.a198b","type":"link out","z":"1a0aa13a.9d7b8f","name":"Go to FR for All 3 Locations","links":["9524e728.08d2c8"],"x":955,"y":300,"wires":[]},{"id":"2c536eac.962c32","type":"link out","z":"1a0aa13a.9d7b8f","name":"Go to FR for All 3 Locations","links":["9524e728.08d2c8"],"x":595,"y":100,"wires":[]},{"id":"4d548e5d.bb86b","type":"comment","z":"1a0aa13a.9d7b8f","name":"Startup and recurring trigger","info":"","x":160,"y":20,"wires":[]},{"id":"4c6c5ac3.b7f5f4","type":"comment","z":"1a0aa13a.9d7b8f","name":"Get Radar results, Send to table and map","info":"","x":880,"y":20,"wires":[]},{"id":"adcc6159.2a741","type":"comment","z":"1a0aa13a.9d7b8f","name":"Dashboard controls","info":"","x":130,"y":180,"wires":[]},{"id":"7037ef88.7d4fd","type":"comment","z":"1a0aa13a.9d7b8f","name":"Quick trigger of 1 radar update","info":"","x":840,"y":260,"wires":[]},{"id":"a93f4f39.d0072","type":"link out","z":"1a0aa13a.9d7b8f","name":"","links":["1d42282.fe857d8","ee484184.496fc"],"x":1115,"y":880,"wires":[]},{"id":"828d7df1.ced63","type":"delay","z":"1a0aa13a.9d7b8f","name":"","pauseType":"delay","timeout":"5","timeoutUnits":"milliseconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":1030,"y":220,"wires":[[]]},{"id":"70bd2141.f8cb7","type":"mqtt out","z":"b2524cfd.8c346","name":"Write reading to MQTT","topic":"","qos":"1","retain":"true","broker":"a5bf81ee.27852","x":1240,"y":100,"wires":[]},{"id":"2988c8da.c1caf8","type":"inject","z":"1c496d2.90bb093","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":100,"y":100,"wires":[["d78d0960.ff8058","240be700.afa08a"]]},{"id":"2be87653.327f4a","type":"debug","z":"1c496d2.90bb093","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":520,"y":100,"wires":[]},{"id":"d78d0960.ff8058","type":"function","z":"1c496d2.90bb093","name":"","func":"var msg2\nmsg.payload = 1\nmsg2 = {payload: 2}\nreturn [msg,msg2];","outputs":2,"noerr":0,"x":300,"y":120,"wires":[["2be87653.327f4a"],["f8b729e9.718e98"]]},{"id":"f8b729e9.718e98","type":"debug","z":"1c496d2.90bb093","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":510,"y":160,"wires":[]},{"id":"fd2cafd.b2d1a5","type":"influxdb out","z":"89f52889.bf1478","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1330,"y":20,"wires":[]},{"id":"5a07a5bc.19bd4c","type":"function","z":"89f52889.bf1478","name":"Format for InfluxDB & MQTT","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node via output 1 which will in turn write to the InfluxDB\n * It also formats an MQTT topic and the data sending that to output 2 which in turn can be used by an MQTT node to send to \n * MQTT\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n/* MQTT section \n * \n * \n * \n */\n\n//create the placeholder object\nvar msg2 = {}\n//add the MQTT topic\nmsg2.topic = \"Hubitat/\" + flow.get(\"MQTTDeviceTopic\") + \"/\" + typeOfMeasurement\n//add the data to be recorded to MQTT\nmsg2.payload = theData\n\n\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return [msg, msg2]\n}","outputs":2,"noerr":0,"x":960,"y":80,"wires":[["fd2cafd.b2d1a5","83a32fad.6930f"],["c658b240.3251"]]},{"id":"83a32fad.6930f","type":"change","z":"89f52889.bf1478","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1370,"y":60,"wires":[[]]},{"id":"c658b240.3251","type":"mqtt out","z":"89f52889.bf1478","name":"Write reading to MQTT","topic":"","qos":"1","retain":"true","broker":"a5bf81ee.27852","x":1260,"y":100,"wires":[]},{"id":"6b58af06.174ac","type":"influxdb out","z":"4e2f0c22.b816c4","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1290,"y":20,"wires":[]},{"id":"1c9129b5.ebcec6","type":"function","z":"4e2f0c22.b816c4","name":"Format for InfluxDB & MQTT","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node via output 1 which will in turn write to the InfluxDB\n * It also formats an MQTT topic and the data sending that to output 2 which in turn can be used by an MQTT node to send to \n * MQTT\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n/* MQTT section \n * \n * \n * \n */\n\n//create the placeholder object\nvar msg2 = {}\n//add the MQTT topic\nmsg2.topic = \"Hubitat/\" + flow.get(\"MQTTDeviceTopic\") + \"/\" + typeOfMeasurement\n//add the data to be recorded to MQTT\nmsg2.payload = theData\n\n\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return [msg, msg2]\n}","outputs":2,"noerr":0,"x":920,"y":80,"wires":[["6b58af06.174ac","b75b2fa.6ca99d"],["d005698f.f3ecf8"]]},{"id":"b75b2fa.6ca99d","type":"change","z":"4e2f0c22.b816c4","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1330,"y":60,"wires":[[]]},{"id":"d005698f.f3ecf8","type":"mqtt out","z":"4e2f0c22.b816c4","name":"Write reading to MQTT","topic":"","qos":"1","retain":"true","broker":"a5bf81ee.27852","x":1220,"y":100,"wires":[]},{"id":"ad45c423.093a38","type":"influxdb out","z":"d2615560.b868a8","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1270,"y":20,"wires":[]},{"id":"a9acec0f.71f8f","type":"function","z":"d2615560.b868a8","name":"Format for InfluxDB & MQTT","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node via output 1 which will in turn write to the InfluxDB\n * It also formats an MQTT topic and the data sending that to output 2 which in turn can be used by an MQTT node to send to \n * MQTT\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n/* MQTT section \n * \n * \n * \n */\n\n//create the placeholder object\nvar msg2 = {}\n//add the MQTT topic\nmsg2.topic = \"Hubitat/\" + flow.get(\"MQTTDeviceTopic\") + \"/\" + typeOfMeasurement\n//add the data to be recorded to MQTT\nmsg2.payload = theData\n\n\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return [msg, msg2]\n}","outputs":2,"noerr":0,"x":900,"y":80,"wires":[["ad45c423.093a38","eef7f9d4.4eaf48"],["f75c9b60.17fdb8"]]},{"id":"eef7f9d4.4eaf48","type":"change","z":"d2615560.b868a8","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1310,"y":60,"wires":[[]]},{"id":"f75c9b60.17fdb8","type":"mqtt out","z":"d2615560.b868a8","name":"Write reading to MQTT","topic":"","qos":"1","retain":"true","broker":"a5bf81ee.27852","x":1200,"y":100,"wires":[]},{"id":"9f128fd3.6cebe","type":"influxdb out","z":"f6aca0d2.59336","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1270,"y":20,"wires":[]},{"id":"1a11f17b.d7527f","type":"function","z":"f6aca0d2.59336","name":"Format for InfluxDB & MQTT","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node via output 1 which will in turn write to the InfluxDB\n * It also formats an MQTT topic and the data sending that to output 2 which in turn can be used by an MQTT node to send to \n * MQTT\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n/* MQTT section \n * \n * \n * \n */\n\n//create the placeholder object\nvar msg2 = {}\n//add the MQTT topic\nmsg2.topic = \"Hubitat/\" + flow.get(\"MQTTDeviceTopic\") + \"/\" + typeOfMeasurement\n//add the data to be recorded to MQTT\nmsg2.payload = theData\n\n\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return [msg, msg2]\n}","outputs":2,"noerr":0,"x":900,"y":80,"wires":[["9f128fd3.6cebe","d89c84bb.66d498"],["ab8962d2.5d636"]]},{"id":"d89c84bb.66d498","type":"change","z":"f6aca0d2.59336","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1310,"y":60,"wires":[[]]},{"id":"ab8962d2.5d636","type":"mqtt out","z":"f6aca0d2.59336","name":"Write reading to MQTT","topic":"","qos":"1","retain":"true","broker":"a5bf81ee.27852","x":1200,"y":100,"wires":[]},{"id":"f3d87d4c.6ab19","type":"influxdb out","z":"9d03767a.9b0288","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1270,"y":20,"wires":[]},{"id":"4b52a2a3.15145c","type":"function","z":"9d03767a.9b0288","name":"Format for InfluxDB & MQTT","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node via output 1 which will in turn write to the InfluxDB\n * It also formats an MQTT topic and the data sending that to output 2 which in turn can be used by an MQTT node to send to \n * MQTT\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n/* MQTT section \n * \n * \n * \n */\n\n//create the placeholder object\nvar msg2 = {}\n//add the MQTT topic\nmsg2.topic = \"Hubitat/\" + flow.get(\"MQTTDeviceTopic\") + \"/\" + typeOfMeasurement\n//add the data to be recorded to MQTT\nmsg2.payload = theData\n\n\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return [msg, msg2]\n}","outputs":2,"noerr":0,"x":900,"y":80,"wires":[["f3d87d4c.6ab19","3d6e8f0c.8aaad"],["5e5c5651.622578"]]},{"id":"3d6e8f0c.8aaad","type":"change","z":"9d03767a.9b0288","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1310,"y":60,"wires":[[]]},{"id":"5e5c5651.622578","type":"mqtt out","z":"9d03767a.9b0288","name":"Write reading to MQTT","topic":"","qos":"1","retain":"true","broker":"a5bf81ee.27852","x":1200,"y":100,"wires":[]},{"id":"5363a6a3.7d5488","type":"influxdb out","z":"390b8414.317d5c","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1290,"y":20,"wires":[]},{"id":"3c2795d.5d10d6a","type":"function","z":"390b8414.317d5c","name":"Format for InfluxDB & MQTT","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node via output 1 which will in turn write to the InfluxDB\n * It also formats an MQTT topic and the data sending that to output 2 which in turn can be used by an MQTT node to send to \n * MQTT\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n/* MQTT section \n * \n * \n * \n */\n\n//create the placeholder object\nvar msg2 = {}\n//add the MQTT topic\nmsg2.topic = \"Hubitat/\" + flow.get(\"MQTTDeviceTopic\") + \"/\" + typeOfMeasurement\n//add the data to be recorded to MQTT\nmsg2.payload = theData\n\n\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return [msg, msg2]\n}","outputs":2,"noerr":0,"x":920,"y":80,"wires":[["5363a6a3.7d5488","1f0266a0.281ff9"],["77ad4cd7.630d94"]]},{"id":"1f0266a0.281ff9","type":"change","z":"390b8414.317d5c","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1330,"y":60,"wires":[[]]},{"id":"77ad4cd7.630d94","type":"mqtt out","z":"390b8414.317d5c","name":"Write reading to MQTT","topic":"","qos":"1","retain":"true","broker":"a5bf81ee.27852","x":1220,"y":100,"wires":[]},{"id":"54de567e.cdede8","type":"influxdb out","z":"e58eb536.40cf18","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1290,"y":20,"wires":[]},{"id":"f00d5586.4300c8","type":"function","z":"e58eb536.40cf18","name":"Format for InfluxDB & MQTT","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node via output 1 which will in turn write to the InfluxDB\n * It also formats an MQTT topic and the data sending that to output 2 which in turn can be used by an MQTT node to send to \n * MQTT\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n/* MQTT section \n * \n * \n * \n */\n\n//create the placeholder object\nvar msg2 = {}\n//add the MQTT topic\nmsg2.topic = \"Hubitat/\" + flow.get(\"MQTTDeviceTopic\") + \"/\" + typeOfMeasurement\n//add the data to be recorded to MQTT\nmsg2.payload = theData\n\n\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return [msg, msg2]\n}","outputs":2,"noerr":0,"x":920,"y":80,"wires":[["54de567e.cdede8","a079c786.6808f8"],["57b18010.32c2b"]]},{"id":"a079c786.6808f8","type":"change","z":"e58eb536.40cf18","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1330,"y":60,"wires":[[]]},{"id":"57b18010.32c2b","type":"mqtt out","z":"e58eb536.40cf18","name":"Write reading to MQTT","topic":"","qos":"1","retain":"true","broker":"a5bf81ee.27852","x":1220,"y":100,"wires":[]},{"id":"2ce6bb5a.605cc4","type":"influxdb out","z":"fd34e084.87e19","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1290,"y":20,"wires":[]},{"id":"e180fc6a.c43cf","type":"function","z":"fd34e084.87e19","name":"Format for InfluxDB & MQTT","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node via output 1 which will in turn write to the InfluxDB\n * It also formats an MQTT topic and the data sending that to output 2 which in turn can be used by an MQTT node to send to \n * MQTT\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n/* MQTT section \n * \n * \n * \n */\n\n//create the placeholder object\nvar msg2 = {}\n//add the MQTT topic\nmsg2.topic = \"Hubitat/\" + flow.get(\"MQTTDeviceTopic\") + \"/\" + typeOfMeasurement\n//add the data to be recorded to MQTT\nmsg2.payload = theData\n\n\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return [msg, msg2]\n}","outputs":2,"noerr":0,"x":920,"y":80,"wires":[["2ce6bb5a.605cc4","4079ef1a.ff235"],["34d8c92b.0e3c96"]]},{"id":"4079ef1a.ff235","type":"change","z":"fd34e084.87e19","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1330,"y":60,"wires":[[]]},{"id":"34d8c92b.0e3c96","type":"mqtt out","z":"fd34e084.87e19","name":"Write reading to MQTT","topic":"","qos":"1","retain":"true","broker":"a5bf81ee.27852","x":1220,"y":100,"wires":[]},{"id":"9556c0b3.edcb5","type":"influxdb out","z":"92d72719.56bd38","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1290,"y":20,"wires":[]},{"id":"8763437a.22844","type":"function","z":"92d72719.56bd38","name":"Format for InfluxDB & MQTT","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node via output 1 which will in turn write to the InfluxDB\n * It also formats an MQTT topic and the data sending that to output 2 which in turn can be used by an MQTT node to send to \n * MQTT\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n/* MQTT section \n * \n * \n * \n */\n\n//create the placeholder object\nvar msg2 = {}\n//add the MQTT topic\nmsg2.topic = \"Hubitat/\" + flow.get(\"MQTTDeviceTopic\") + \"/\" + typeOfMeasurement\n//add the data to be recorded to MQTT\nmsg2.payload = theData\n\n\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return [msg, msg2]\n}","outputs":2,"noerr":0,"x":920,"y":80,"wires":[["9556c0b3.edcb5","1e943c1a.24d994"],["9ae71606.856418"]]},{"id":"1e943c1a.24d994","type":"change","z":"92d72719.56bd38","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1330,"y":60,"wires":[[]]},{"id":"9ae71606.856418","type":"mqtt out","z":"92d72719.56bd38","name":"Write reading to MQTT","topic":"","qos":"1","retain":"true","broker":"a5bf81ee.27852","x":1220,"y":100,"wires":[]},{"id":"b5543277.66f48","type":"influxdb out","z":"ae851807.40c0e8","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1310,"y":20,"wires":[]},{"id":"c8105a83.108b58","type":"function","z":"ae851807.40c0e8","name":"Format for InfluxDB & MQTT","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node via output 1 which will in turn write to the InfluxDB\n * It also formats an MQTT topic and the data sending that to output 2 which in turn can be used by an MQTT node to send to \n * MQTT\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n/* MQTT section \n * \n * \n * \n */\n\n//create the placeholder object\nvar msg2 = {}\n//add the MQTT topic\nmsg2.topic = \"Hubitat/\" + flow.get(\"MQTTDeviceTopic\") + \"/\" + typeOfMeasurement\n//add the data to be recorded to MQTT\nmsg2.payload = theData\n\n\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return [msg, msg2]\n}","outputs":2,"noerr":0,"x":940,"y":80,"wires":[["b5543277.66f48","9b8f6dcd.fae7e"],["21096ce6.0bdb14"]]},{"id":"9b8f6dcd.fae7e","type":"change","z":"ae851807.40c0e8","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1350,"y":60,"wires":[[]]},{"id":"21096ce6.0bdb14","type":"mqtt out","z":"ae851807.40c0e8","name":"Write reading to MQTT","topic":"","qos":"1","retain":"true","broker":"a5bf81ee.27852","x":1240,"y":100,"wires":[]},{"id":"b5728de5.e6f1d","type":"influxdb out","z":"5364e86b.44e3a8","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1330,"y":20,"wires":[]},{"id":"31f31813.96f798","type":"function","z":"5364e86b.44e3a8","name":"Format for InfluxDB & MQTT","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node via output 1 which will in turn write to the InfluxDB\n * It also formats an MQTT topic and the data sending that to output 2 which in turn can be used by an MQTT node to send to \n * MQTT\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n/* MQTT section \n * \n * \n * \n */\n\n//create the placeholder object\nvar msg2 = {}\n//add the MQTT topic\nmsg2.topic = \"Hubitat/\" + flow.get(\"MQTTDeviceTopic\") + \"/\" + typeOfMeasurement\n//add the data to be recorded to MQTT\nmsg2.payload = theData\n\n\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return [msg, msg2]\n}","outputs":2,"noerr":0,"x":960,"y":80,"wires":[["14631d22.b13213"],["2822741c.3ca54c"]]},{"id":"14631d22.b13213","type":"change","z":"5364e86b.44e3a8","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1370,"y":60,"wires":[[]]},{"id":"2822741c.3ca54c","type":"mqtt out","z":"5364e86b.44e3a8","name":"Write reading to MQTT","topic":"","qos":"1","retain":"true","broker":"a5bf81ee.27852","x":1260,"y":100,"wires":[]},{"id":"240be700.afa08a","type":"hubitat device","z":"1c496d2.90bb093","name":"Mike Credenza Light switch","server":"55e4481a.722098","deviceId":"388","attribute":"switch","sendEvent":true,"x":320,"y":320,"wires":[["8a4872a8.e20bd"]]},{"id":"8a4872a8.e20bd","type":"debug","z":"1c496d2.90bb093","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":640,"y":320,"wires":[]},{"id":"6a471d49.5aa234","type":"function","z":"592962b2.a94e1c","name":"Format for InfluxDB & MQTT","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node via output 1 which will in turn write to the InfluxDB\n * It also formats an MQTT topic and the data sending that to output 2 which in turn can be used by an MQTT node to send to \n * MQTT\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n/* MQTT section \n * \n * \n * \n */\n\n//create the placeholder object\nvar msg2 = {}\n//add the MQTT topic\nmsg2.topic = \"Hubitat/\" + flow.get(\"MQTTDeviceTopic\") + \"/\" + typeOfMeasurement\n//add the data to be recorded to MQTT\nmsg2.payload = theData\n\n\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return [msg, msg2]\n}","outputs":2,"noerr":0,"x":180,"y":420,"wires":[[],[]]},{"id":"938046de.031248","type":"config","z":"592962b2.a94e1c","name":"Office Echo Config","properties":[{"p":"Floor","pt":"flow","to":"2","tot":"str"},{"p":"Location","pt":"flow","to":"Mike's Desk","tot":"str"},{"p":"Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Echo","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Amazon","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Office Echo","tot":"str"}],"active":true,"x":1070,"y":20,"wires":[]},{"id":"d483d334.d227","type":"inject","z":"592962b2.a94e1c","name":"4AlexaPlaylists","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":120,"y":160,"wires":[["babf60fb.09bbd"]]},{"id":"61d2ed4f.696564","type":"debug","z":"592962b2.a94e1c","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":550,"y":340,"wires":[]},{"id":"43a1edc2.9cde14","type":"function","z":"592962b2.a94e1c","name":"","func":"msg = global.get(\"aSingleEntryArrayValue2\")\nglobal.set(\"aSingleEntryArrayValue1\",msg)\nreturn msg;","outputs":1,"noerr":0,"x":530,"y":520,"wires":[[]]},{"id":"97624432.435f18","type":"inject","z":"592962b2.a94e1c","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":180,"y":500,"wires":[["43a1edc2.9cde14"]]},{"id":"6b8282b6.2607ec","type":"subflow:5364e86b.44e3a8","z":"592962b2.a94e1c","name":"","env":[],"x":488,"y":613,"wires":[]},{"id":"a8a61dea.458e2","type":"inject","z":"592962b2.a94e1c","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":160,"y":640,"wires":[["6b8282b6.2607ec"]]},{"id":"e427fed2.fc82a","type":"change","z":"592962b2.a94e1c","name":"","rules":[{"t":"set","p":"payload","pt":"msg","to":"payload.value","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":800,"y":680,"wires":[["61d2ed4f.696564"]]},{"id":"869de701.8b5b58","type":"function","z":"592962b2.a94e1c","name":"msg = global.get(\"aSingleEntryArrayValue\")","func":"//msg = global.get(\"badinput\")\n//msg = global.get(\"goodinput\")\n//msg = global.get(\"ArrayInJSON2\")\nmsg = RED.util.cloneMessage(global.get(\"aSingleEntryArrayValue1\"))\n//msg = global.get(\"aSingleEntryArrayValue1\")\nreturn msg;","outputs":1,"noerr":0,"x":450,"y":680,"wires":[["e427fed2.fc82a"]]},{"id":"bbdda3bf.29437","type":"inject","z":"592962b2.a94e1c","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":140,"y":700,"wires":[["869de701.8b5b58"]]},{"id":"babf60fb.09bbd","type":"function","z":"592962b2.a94e1c","name":"4AlexaPlaylists","func":"//msg = global.get(\"badinput\")\n//msg = global.get(\"goodinput\")\n//msg = global.get(\"ArrayInJSON2\")\nmsg = RED.util.cloneMessage(global.get(\"4AlexaPlaylists\"))\n//msg = global.get(\"aSingleEntryArrayValue1\")\nreturn msg;","outputs":1,"noerr":0,"x":380,"y":160,"wires":[["7031493c.d2bfc8","2845bce0.b7bb94"]]},{"id":"39505ed8.5de472","type":"function","z":"592962b2.a94e1c","name":"6works for all put case 4 AlexaPlaylists","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\n//node.warn(\"line 6 \" +msg.payload.value)\nif (msg.payload.value === null) {\n    return null;\n}\n\n\n//check for a valule payload that is actually an array\n//(this probably should be built to be recursive like Split JSON, but other priorities put this off)\n//This does assume that the array hold key value pairs. If it doesn't then it is likely to crash in\n//some unexpected way, but then again arrays should be very rare\n\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n   //latestMsg = RED.util.cloneMessage(passedMsg)\n   node.warn(\"line 32 \" + latestMsg.payload.value+\"   \"+latestMsg.payload.name)\n   if (Array.isArray(latestMsg.payload.value)){\n        node.warn(\"Line 33 Is Array \"+ latestMsg.payload.value[0])\n        node.warn(\"Line 34 \"+ latestMsg.payload.value)\n    }\n    if ((Array.isArray(latestMsg.payload.value))&&(latestMsg.payload.dataType != 'JSON_OBJECT')) {\n        //variable to hold the keys and their values\n        var keys\n        var vals\n        //variable to hold the new msg that will be returned for each valid key:value pair\n        var armsg = { \"payload\": { \"name\": \"\", \"dataType\": \"\", \"value\": \"\" } }\n        \n        node.warn(\"line 44 \"+latestMsg.payload.value.length+\"  \"+latestMsg.payload.value)\n        if(latestMsg.payload.value.length==1){\n            //node.warn(\"Found Length = \"+ latestMsg.payload.value.length+\"  \"+latestMsg.payload.value)\n            //node.warn(latestMsg.payload.value[0])\n            //node.warn(latestMsg.payload.dataType)\n            //node.warn(latestMsg.payload.deviceId)\n            //node.warn(latestMsg.payload.name)\n            armsg.payload.value = latestMsg.payload.value[0]\n            armsg.payload.dataType = latestMsg.payload.dataType\n            armsg.payload.deviceId = latestMsg.payload.deviceId\n            armsg.payload.name = latestMsg.payload.name\n            //anothermsg = RED.util.cloneMessage(armsg)\n            //node.warn(\"Line 56 \"+ anothermsg.payload.value)\n            //SplitJSON(anothermsg)\n            SplitJSON(armsg)\n            //node.warn(\"Line 58 \"+ anothermsg.payload.value)\n            node.warn(\"Line 58 \"+ armsg.payload.value)\n            return\n        }\n        \n        \n        //loop through the array\n        for (index = 0; index < latestMsg.payload.value.length; index++) {\n            //get the key and value values\n            keys = Object.keys(latestMsg.payload.value[index])\n            vals = Object.values(latestMsg.payload.value[index])\n            //loop through the pairs\n            for (index2 = 0; index2 < keys.length; index2++) {\n                //check for null value and throw away that pair\n                if (vals[index2] === null) {\n                    node.log(\"The input \" + keys[index2] + \":\" + vals[index2] + \" has a null value thus was thrown away\");\n                }\n                //check if the value is a number and send a msg with the value and the dataType of number\n                else if (!isNaN(vals[index2])) {\n                    armsg.payload.value = ++vals[index2]\n                    armsg.payload.value = --armsg.payload.value\n                    armsg.payload.dataType = 'number'\n                    armsg.payload.deviceId = latestMsg.payload.deviceId\n                    armsg.payload.name = latestMsg.payload.name + \":\" + keys[index2]\n                    node.warn(\"Line 79 before send\"+ latestMsg.payload.value)\n                    node.send(armsg)\n                }\n                //check if the value is JSON and send to JSON splitting function\n                else if (IsValidJSONString(vals[index2])) {\n                    armsg.payload.value = vals[index2]\n                    armsg.payload.dataType = 'JSON_OBJECT'\n                    armsg.payload.deviceId = latestMsg.payload.deviceId\n                    armsg.payload.name = latestMsg.payload.name + \":\" + keys[index2]\n                    SplitJSON(armsg)\n                }\n                //check if the value is a string and send a msg with the value and the dataType of string\n                else if (typeof vals[index2] === 'string') {\n                    armsg.payload.value = vals[index2]\n                    armsg.payload.dataType = 'string'\n                    armsg.payload.deviceId = latestMsg.payload.deviceId\n                    armsg.payload.name = latestMsg.payload.name + \":\" + keys[index2]\n                    node.warn(\"Line 96 before send\"+ latestMsg.payload.value)\n                    node.send(armsg)\n                }\n                //Throw an error if the contents of the value is unanticipated\n                else {\n                    node.error(\"The input \" + keys[index2] + \":\" + vals[index2] + \" was not identified as having a value with a type of null, number, JSON, or string and thus was thrown away\");\n                }\n            }\n        }\n        //return nothing if the input was an array as the parsing of the array already sent anything parsable on\n        return\n    }\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        node.warn(\"Line 110 \"+ latestMsg.payload.value)\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            node.warn(\"Line 114 \"+ latestMsg.payload.value)\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the array of key:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                node.warn(\"line 126\")\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            node.warn(\"line 132\"+ latestMsg.payload.dataType)\n            if (Array.isArray(latestMsg.payload.value)){\n                node.warn(\"Line 133 Is Array \"+ latestMsg.payload.value[0])\n                node.warn(\"Line 134 \"+ latestMsg.payload.value)\n                //latestMsg.payload.value\n                }\n            latestMsg.payload.dataType = \"STRING\"\n            node.warn(\"Line 138 before send\"+ latestMsg.payload.value)\n            SplitJSON(latestMsg)\n            //node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.warn(\"Line 145 before send \"+ latestMsg.payload.value)\n        node.warn(\"Line 146 before send \"+ latestMsg.payload.name)\n        node.warn(\"Line 147 before send \"+ latestMsg.payload.dataType)\n        node.warn(\"Line 148 before send \"+ latestMsg.payload.deviceId)\n        node.send(latestMsg);\n        return\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":1110,"y":260,"wires":[[]]},{"id":"a31721fa.e1238","type":"function","z":"592962b2.a94e1c","name":"2 JSON and Array Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n\n\n//check for a valule payload that is actually an array\n//(this probably should be built to be recursive like Split JSON, but other priorities put this off)\n//This does assume that the array hold key value pairs. If it doesn't then it is likely to crash in\n//some unexpected way, but then again arrays should be very rare\nif (Array.isArray(msg.payload.value)){\n    //variable to hold the keys and their values\n    var keys\n    var vals\n    //variable to hold the new msg that will be returned for each valid key:value pair\n    var armsg={\"payload\":{\"name\":\"\",\"dataType\":\"\",\"value\":\"\"}}\n    //loop through the array\n    for (index = 0; index < msg.payload.value.length; index++) { \n        //get the key and value values\n        keys = Object.keys(msg.payload.value[index])\n        vals = Object.values(msg.payload.value[index])\n    \t//loop through the pairs\n    \tfor (index2 = 0; index2 < keys.length; index2++) {\n    \t    //check for null value and throw away that pair\n    \t    if (vals[index2] === null) {\n    \t        node.log(\"The input \" + keys[index2] + \":\" + vals[index2] +\" has a null value thus was thrown away\");\n    \t        }\n    \t        //check if the value is a number and send a msg with the value and the dataType of number\n    \t        else if (!isNaN(vals[index2])) {\n    \t            armsg.payload.value = ++vals[index2]\n    \t            armsg.payload.value = --armsg.payload.value\n    \t            armsg.payload.dataType = 'number'\n    \t            armsg.payload.deviceId = msg.payload.deviceId\n    \t            armsg.payload.name = msg.payload.name+\":\"+keys[index2]\n    \t            node.send(armsg)\n    \t            }\n    \t            //check if the value is JSON and send to JSON splitting function\n    \t            else if (IsValidJSONString(vals[index2])) {\n    \t                armsg.payload.value = vals[index2]\n    \t                armsg.payload.dataType = 'JSON_OBJECT'\n    \t                armsg.payload.deviceId = msg.payload.deviceId\n    \t                armsg.payload.name = msg.payload.name+\":\"+keys[index2]\n    \t                SplitJSON(armsg)\n    \t                }\n    \t                //check if the value is a string and send a msg with the value and the dataType of string\n    \t                else if (typeof vals[index2] === 'string') {\n    \t                    armsg.payload.value = vals[index2]\n    \t                    armsg.payload.dataType = 'string'\n    \t                    armsg.payload.deviceId = msg.payload.deviceId\n    \t                    armsg.payload.name = msg.payload.name+\":\"+keys[index2]\n    \t                    node.send(armsg)\n    \t                    } \n    \t                    //Throw an error if the contents of the value is unanticipated\n    \t                    else {\n    \t                        node.error(\"The input \" + keys[index2] + \":\" + vals[index2] +\" was not identified as having a value with a type of null, number, JSON, or string and thus was thrown away\");\n    \t                        }\n    \t                        }\n    \t                        }\n    \t                        //return nothing if the input was an array as the parsing of the array already sent anything parsable on\n    \t                        return\n}\n\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":1090,"y":100,"wires":[[]]},{"id":"6b4a7ef.18ac58","type":"function","z":"592962b2.a94e1c","name":"1 JSON and Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n\n\nvar tempbool = false\nvar keys\nvar vals\nvar armsg={\"payload\":{\"name\":\"\",\"dataType\":\"\",\"value\":\"\"}}\narmsg.payload.name = \"test\"\n//node.send(armsg)\n//return\ntempbool = Array.isArray(msg.payload.value)\n//node.error(\"value array? \"+ tempbool);\nif (Array.isArray(msg.payload.value)){\n    for (index = 0; index < msg.payload.value.length; index++) { \n//    \tnode.error(msg.payload.value[index]); \n        keys = Object.keys(msg.payload.value[index])\n        vals = Object.values(msg.payload.value[index])\n//    \tnode.error(keys); \n//    \tnode.error(vals);\n    \tfor (index2 = 0; index2 < keys.length; index2++) {\n    \t    //node.error(keys[index2]+\" is key and val is \"+vals[index2])\n    \t    //node.error(\"outer Is \"+ vals[index2]+ \" a number? This is \"+ !isNaN(vals[index2]))\n    \t    if (vals[index2] === null) {\n    \t        node.error(\"found a null for \" + keys[index2]);\n    \t    } else if (!isNaN(vals[index2])) {\n    \t        //node.error(\"found a number for \" + keys[index2]);\n    \t        node.error(\"Inner Is \"+ vals[index2]+ \" a number? This is \"+ !isNaN(vals[index2]) + \" and the key is\"+keys[index2]);\n    \t        armsg.payload.value = ++vals[index2]\n    \t        armsg.payload.value = --armsg.payload.value\n    \t        armsg.payload.dataType = 'number'\n    \t        armsg.payload.name = msg.payload.name+\":\"+keys[index2]\n    \t        node.send(armsg)\n    \t    } else if (IsValidJSONString(vals[index2])) {\n    \t        //node.error(\"found a number for \" + keys[index2]);\n    \t        node.error(\"don't have and example of JSON so the validity of this input was not tested\");\n    \t        armsg.payload.value = vals[index2]\n    \t        armsg.payload.dataType = 'JSON_OBJECT'\n    \t        armsg.payload.name = msg.payload.name+\":\"+keys[index2]\n    \t        SplitJSON(armsg)\n    \t    } else if (typeof vals[index2] === 'string') {\n    \t        node.error(\"Found String: \"+vals[index2]);\n    \t        armsg.payload.value = vals[index2]\n    \t        armsg.payload.dataType = 'string'\n    \t        armsg.payload.name = msg.payload.name+\":\"+keys[index2]\n    \t        node.send(armsg)\n    \t    } else {\n    \t        node.error(\"The input \" + keys[index2] + \":\" + vals[index2] +\" was not identified as having a value with a type of null, number, JSON, or string and thus was thrown away\");\n    \t    }\n    \t}\n    } \n    return\n}\n\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":1070,"y":60,"wires":[[]]},{"id":"2845bce0.b7bb94","type":"function","z":"592962b2.a94e1c","name":"3 Fast Fix?","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n\n\n//check for a valule payload that is actually an array\n//(this probably should be built to be recursive like Split JSON, but other priorities put this off)\n//This does assume that the array hold key value pairs. If it doesn't then it is likely to crash in\n//some unexpected way, but then again arrays should be very rare\n\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    if (Array.isArray(latestMsg.payload.value)) {\n        //variable to hold the keys and their values\n        var keys\n        var vals\n        //variable to hold the new msg that will be returned for each valid key:value pair\n        var armsg = { \"payload\": { \"name\": \"\", \"dataType\": \"\", \"value\": \"\" } }\n        //loop through the array\n        for (index = 0; index < latestMsg.payload.value.length; index++) {\n            //get the key and value values\n            keys = Object.keys(latestMsg.payload.value[index])\n            vals = Object.values(latestMsg.payload.value[index])\n            //loop through the pairs\n            for (index2 = 0; index2 < keys.length; index2++) {\n                //check for null value and throw away that pair\n                if (vals[index2] === null) {\n                    node.log(\"The input \" + keys[index2] + \":\" + vals[index2] + \" has a null value thus was thrown away\");\n                }\n                //check if the value is a number and send a msg with the value and the dataType of number\n                else if (!isNaN(vals[index2])) {\n                    armsg.payload.value = ++vals[index2]\n                    armsg.payload.value = --armsg.payload.value\n                    armsg.payload.dataType = 'number'\n                    armsg.payload.deviceId = latestMsg.payload.deviceId\n                    armsg.payload.name = latestMsg.payload.name + \":\" + keys[index2]\n                    node.send(armsg)\n                }\n                //check if the value is JSON and send to JSON splitting function\n                else if (IsValidJSONString(vals[index2])) {\n                    armsg.payload.value = vals[index2]\n                    armsg.payload.dataType = 'JSON_OBJECT'\n                    armsg.payload.deviceId = latestMsg.payload.deviceId\n                    armsg.payload.name = latestMsg.payload.name + \":\" + keys[index2]\n                    SplitJSON(armsg)\n                }\n                //check if the value is a string and send a msg with the value and the dataType of string\n                else if (typeof vals[index2] === 'string') {\n                    armsg.payload.value = vals[index2]\n                    armsg.payload.dataType = 'string'\n                    armsg.payload.deviceId = latestMsg.payload.deviceId\n                    armsg.payload.name = latestMsg.payload.name + \":\" + keys[index2]\n                    node.send(armsg)\n                }\n                //Throw an error if the contents of the value is unanticipated\n                else {\n                    node.error(\"The input \" + keys[index2] + \":\" + vals[index2] + \" was not identified as having a value with a type of null, number, JSON, or string and thus was thrown away\");\n                }\n            }\n        }\n        //return nothing if the input was an array as the parsing of the array already sent anything parsable on\n        return\n    }\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":710,"y":260,"wires":[[]]},{"id":"d0cf3cd9.6d52d","type":"function","z":"592962b2.a94e1c","name":"3 Fast Fix?","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n\n\n//check for a valule payload that is actually an array\n//(this probably should be built to be recursive like Split JSON, but other priorities put this off)\n//This does assume that the array hold key value pairs. If it doesn't then it is likely to crash in\n//some unexpected way, but then again arrays should be very rare\n\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    if (Array.isArray(latestMsg.payload.value)) {\n        //variable to hold the keys and their values\n        var keys\n        var vals\n        //variable to hold the new msg that will be returned for each valid key:value pair\n        var armsg = { \"payload\": { \"name\": \"\", \"dataType\": \"\", \"value\": \"\" } }\n        //loop through the array\n        for (index = 0; index < latestMsg.payload.value.length; index++) {\n            //get the key and value values\n            keys = Object.keys(latestMsg.payload.value[index])\n            vals = Object.values(latestMsg.payload.value[index])\n            //loop through the pairs\n            for (index2 = 0; index2 < keys.length; index2++) {\n                //check for null value and throw away that pair\n                if (vals[index2] === null) {\n                    node.log(\"The input \" + keys[index2] + \":\" + vals[index2] + \" has a null value thus was thrown away\");\n                }\n                //check if the value is a number and send a msg with the value and the dataType of number\n                else if (!isNaN(vals[index2])) {\n                    armsg.payload.value = ++vals[index2]\n                    armsg.payload.value = --armsg.payload.value\n                    armsg.payload.dataType = 'number'\n                    armsg.payload.deviceId = latestMsg.payload.deviceId\n                    armsg.payload.name = latestMsg.payload.name + \":\" + keys[index2]\n                    node.send(armsg)\n                }\n                //check if the value is JSON and send to JSON splitting function\n                else if (IsValidJSONString(vals[index2])) {\n                    armsg.payload.value = vals[index2]\n                    armsg.payload.dataType = 'JSON_OBJECT'\n                    armsg.payload.deviceId = latestMsg.payload.deviceId\n                    armsg.payload.name = latestMsg.payload.name + \":\" + keys[index2]\n                    SplitJSON(armsg)\n                }\n                //check if the value is a string and send a msg with the value and the dataType of string\n                else if (typeof vals[index2] === 'string') {\n                    armsg.payload.value = vals[index2]\n                    armsg.payload.dataType = 'string'\n                    armsg.payload.deviceId = latestMsg.payload.deviceId\n                    armsg.payload.name = latestMsg.payload.name + \":\" + keys[index2]\n                    node.send(armsg)\n                }\n                //Throw an error if the contents of the value is unanticipated\n                else {\n                    node.error(\"The input \" + keys[index2] + \":\" + vals[index2] + \" was not identified as having a value with a type of null, number, JSON, or string and thus was thrown away\");\n                }\n            }\n        }\n        //return nothing if the input was an array as the parsing of the array already sent anything parsable on\n        return\n    }\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":1030,"y":140,"wires":[[]]},{"id":"ba1041dc.472b7","type":"function","z":"592962b2.a94e1c","name":"4 Working","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\n//node.warn(\"line 6 \" +msg.payload.value)\nif (msg.payload.value === null) {\n    return null;\n}\n\n\n//check for a valule payload that is actually an array\n//(this probably should be built to be recursive like Split JSON, but other priorities put this off)\n//This does assume that the array hold key value pairs. If it doesn't then it is likely to crash in\n//some unexpected way, but then again arrays should be very rare\n\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(passedMsg) {\n   latestMsg = RED.util.cloneMessage(passedMsg)\n   node.warn(\"line 32 \" + latestMsg.payload.value+\"   \"+latestMsg.payload.name)\n   if (Array.isArray(latestMsg.payload.value)){\n        node.warn(\"Line 33 Is Array \"+ latestMsg.payload.value[0])\n        node.warn(\"Line 34 \"+ latestMsg.payload.value)\n    }\n    if ((Array.isArray(latestMsg.payload.value))&&(latestMsg.payload.dataType != 'JSON_OBJECT')) {\n        //variable to hold the keys and their values\n        var keys\n        var vals\n        //variable to hold the new msg that will be returned for each valid key:value pair\n        var armsg = { \"payload\": { \"name\": \"\", \"dataType\": \"\", \"value\": \"\" } }\n        \n        node.warn(\"line 44 \"+latestMsg.payload.value.length+\"  \"+latestMsg.payload.value)\n        if(latestMsg.payload.value.length==1){\n            //node.warn(\"Found Length = \"+ latestMsg.payload.value.length+\"  \"+latestMsg.payload.value)\n            //node.warn(latestMsg.payload.value[0])\n            //node.warn(latestMsg.payload.dataType)\n            //node.warn(latestMsg.payload.deviceId)\n            //node.warn(latestMsg.payload.name)\n            armsg.payload.value = latestMsg.payload.value[0]\n            armsg.payload.dataType = latestMsg.payload.dataType\n            armsg.payload.deviceId = latestMsg.payload.deviceId\n            armsg.payload.name = latestMsg.payload.name\n            anothermsg = RED.util.cloneMessage(armsg)\n            node.warn(\"Line 56 \"+ anothermsg.payload.value)\n            SplitJSON(anothermsg)\n            node.warn(\"Line 58 \"+ anothermsg.payload.value)\n            return\n        }\n        \n        \n        //loop through the array\n        for (index = 0; index < latestMsg.payload.value.length; index++) {\n            //get the key and value values\n            keys = Object.keys(latestMsg.payload.value[index])\n            vals = Object.values(latestMsg.payload.value[index])\n            //loop through the pairs\n            for (index2 = 0; index2 < keys.length; index2++) {\n                //check for null value and throw away that pair\n                if (vals[index2] === null) {\n                    node.log(\"The input \" + keys[index2] + \":\" + vals[index2] + \" has a null value thus was thrown away\");\n                }\n                //check if the value is a number and send a msg with the value and the dataType of number\n                else if (!isNaN(vals[index2])) {\n                    armsg.payload.value = ++vals[index2]\n                    armsg.payload.value = --armsg.payload.value\n                    armsg.payload.dataType = 'number'\n                    armsg.payload.deviceId = latestMsg.payload.deviceId\n                    armsg.payload.name = latestMsg.payload.name + \":\" + keys[index2]\n                    node.warn(\"Line 79 before send\"+ latestMsg.payload.value)\n                    node.send(armsg)\n                }\n                //check if the value is JSON and send to JSON splitting function\n                else if (IsValidJSONString(vals[index2])) {\n                    armsg.payload.value = vals[index2]\n                    armsg.payload.dataType = 'JSON_OBJECT'\n                    armsg.payload.deviceId = latestMsg.payload.deviceId\n                    armsg.payload.name = latestMsg.payload.name + \":\" + keys[index2]\n                    SplitJSON(armsg)\n                }\n                //check if the value is a string and send a msg with the value and the dataType of string\n                else if (typeof vals[index2] === 'string') {\n                    armsg.payload.value = vals[index2]\n                    armsg.payload.dataType = 'string'\n                    armsg.payload.deviceId = latestMsg.payload.deviceId\n                    armsg.payload.name = latestMsg.payload.name + \":\" + keys[index2]\n                    node.warn(\"Line 96 before send\"+ latestMsg.payload.value)\n                    node.send(armsg)\n                }\n                //Throw an error if the contents of the value is unanticipated\n                else {\n                    node.error(\"The input \" + keys[index2] + \":\" + vals[index2] + \" was not identified as having a value with a type of null, number, JSON, or string and thus was thrown away\");\n                }\n            }\n        }\n        //return nothing if the input was an array as the parsing of the array already sent anything parsable on\n        return\n    }\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        node.warn(\"Line 110 \"+ latestMsg.payload.value)\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            node.warn(\"Line 114 \"+ latestMsg.payload.value)\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the array of key:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                node.warn(\"line 126\")\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            node.warn(\"line 132\"+ latestMsg.payload.dataType)\n            if (Array.isArray(latestMsg.payload.value)){\n                node.warn(\"Line 133 Is Array \"+ latestMsg.payload.value[0])\n                node.warn(\"Line 134 \"+ latestMsg.payload.value)\n                //latestMsg.payload.value\n                }\n            latestMsg.payload.dataType = \"STRING\"\n            node.warn(\"Line 138 before send\"+ latestMsg.payload.value)\n            SplitJSON(latestMsg)\n            //node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.warn(\"Line 145 before send \"+ latestMsg.payload.value)\n        node.warn(\"Line 146 before send \"+ latestMsg.payload.name)\n        node.warn(\"Line 147 before send \"+ latestMsg.payload.dataType)\n        node.warn(\"Line 148 before send \"+ latestMsg.payload.deviceId)\n        node.send(latestMsg);\n        return\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":1020,"y":180,"wires":[[]]},{"id":"30266437.73d0fc","type":"function","z":"592962b2.a94e1c","name":"6.1 quick Swap","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\n//node.warn(\"line 6 \" +msg.payload.value)\nif (msg.payload.value === null) {\n    return null;\n}\n\n\n//check for a valule payload that is actually an array\n//(this probably should be built to be recursive like Split JSON, but other priorities put this off)\n//This does assume that the array hold key value pairs. If it doesn't then it is likely to crash in\n//some unexpected way, but then again arrays should be very rare\n\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        node.warn(\"Line 110 \" + latestMsg.payload.value)\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            node.warn(\"Line 114 \" + latestMsg.payload.value)\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the array of key:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                node.warn(\"line 126\")\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            node.warn(\"line 132\" + latestMsg.payload.dataType)\n            if (Array.isArray(latestMsg.payload.value)) {\n                node.warn(\"Line 133 Is Array \" + latestMsg.payload.value[0])\n                node.warn(\"Line 134 \" + latestMsg.payload.value)\n                //latestMsg.payload.value\n            }\n            latestMsg.payload.dataType = \"STRING\"\n            node.warn(\"Line 138 before send\" + latestMsg.payload.value)\n            SplitJSON(latestMsg)\n            //node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.warn(\"Line 145 before send \" + latestMsg.payload.value)\n        node.warn(\"Line 146 before send \" + latestMsg.payload.name)\n        node.warn(\"Line 147 before send \" + latestMsg.payload.dataType)\n        node.warn(\"Line 148 before send \" + latestMsg.payload.deviceId)\n        node.send(latestMsg);\n        return\n    }\n    //latestMsg = RED.util.cloneMessage(passedMsg)\n    node.warn(\"line 32 \" + latestMsg.payload.value + \"   \" + latestMsg.payload.name)\n    if (Array.isArray(latestMsg.payload.value)) {\n        node.warn(\"Line 33 Is Array \" + latestMsg.payload.value[0])\n        node.warn(\"Line 34 \" + latestMsg.payload.value)\n    }\n    if ((Array.isArray(latestMsg.payload.value)) && (latestMsg.payload.dataType != 'JSON_OBJECT')) {\n        //variable to hold the keys and their values\n        var keys\n        var vals\n        //variable to hold the new msg that will be returned for each valid key:value pair\n        var armsg = { \"payload\": { \"name\": \"\", \"dataType\": \"\", \"value\": \"\" } }\n\n        node.warn(\"line 44 \" + latestMsg.payload.value.length + \"  \" + latestMsg.payload.value)\n        if (latestMsg.payload.value.length == 1) {\n            //node.warn(\"Found Length = \"+ latestMsg.payload.value.length+\"  \"+latestMsg.payload.value)\n            //node.warn(latestMsg.payload.value[0])\n            //node.warn(latestMsg.payload.dataType)\n            //node.warn(latestMsg.payload.deviceId)\n            //node.warn(latestMsg.payload.name)\n            armsg.payload.value = latestMsg.payload.value[0]\n            armsg.payload.dataType = latestMsg.payload.dataType\n            armsg.payload.deviceId = latestMsg.payload.deviceId\n            armsg.payload.name = latestMsg.payload.name\n            //anothermsg = RED.util.cloneMessage(armsg)\n            //node.warn(\"Line 56 \"+ anothermsg.payload.value)\n            //SplitJSON(anothermsg)\n            SplitJSON(armsg)\n            //node.warn(\"Line 58 \"+ anothermsg.payload.value)\n            node.warn(\"Line 58 \" + armsg.payload.value)\n            return\n        }\n\n\n        //loop through the array\n        for (index = 0; index < latestMsg.payload.value.length; index++) {\n            //get the key and value values\n            keys = Object.keys(latestMsg.payload.value[index])\n            vals = Object.values(latestMsg.payload.value[index])\n            //loop through the pairs\n            for (index2 = 0; index2 < keys.length; index2++) {\n                //check for null value and throw away that pair\n                if (vals[index2] === null) {\n                    node.log(\"The input \" + keys[index2] + \":\" + vals[index2] + \" has a null value thus was thrown away\");\n                }\n                //check if the value is a number and send a msg with the value and the dataType of number\n                else if (!isNaN(vals[index2])) {\n                    armsg.payload.value = ++vals[index2]\n                    armsg.payload.value = --armsg.payload.value\n                    armsg.payload.dataType = 'number'\n                    armsg.payload.deviceId = latestMsg.payload.deviceId\n                    armsg.payload.name = latestMsg.payload.name + \":\" + keys[index2]\n                    node.warn(\"Line 79 before send\" + latestMsg.payload.value)\n                    node.send(armsg)\n                }\n                //check if the value is JSON and send to JSON splitting function\n                else if (IsValidJSONString(vals[index2])) {\n                    armsg.payload.value = vals[index2]\n                    armsg.payload.dataType = 'JSON_OBJECT'\n                    armsg.payload.deviceId = latestMsg.payload.deviceId\n                    armsg.payload.name = latestMsg.payload.name + \":\" + keys[index2]\n                    SplitJSON(armsg)\n                }\n                //check if the value is a string and send a msg with the value and the dataType of string\n                else if (typeof vals[index2] === 'string') {\n                    armsg.payload.value = vals[index2]\n                    armsg.payload.dataType = 'string'\n                    armsg.payload.deviceId = latestMsg.payload.deviceId\n                    armsg.payload.name = latestMsg.payload.name + \":\" + keys[index2]\n                    node.warn(\"Line 96 before send\" + latestMsg.payload.value)\n                    node.send(armsg)\n                }\n                //Throw an error if the contents of the value is unanticipated\n                else {\n                    node.error(\"The input \" + keys[index2] + \":\" + vals[index2] + \" was not identified as having a value with a type of null, number, JSON, or string and thus was thrown away\");\n                }\n            }\n        }\n        //return nothing if the input was an array as the parsing of the array already sent anything parsable on\n        return\n    }\n\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":200,"y":340,"wires":[["61d2ed4f.696564"]]},{"id":"c5e0ffeb.3a159","type":"inject","z":"592962b2.a94e1c","name":"","topic":"1BTDevicesPaired","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":160,"y":40,"wires":[["dd4eb54c.0077f8"]]},{"id":"dd4eb54c.0077f8","type":"function","z":"592962b2.a94e1c","name":"1BTDevicesPaired","func":"//msg = global.get(\"badinput\")\n//msg = global.get(\"goodinput\")\n//msg = global.get(\"ArrayInJSON2\")\nmsg = RED.util.cloneMessage(global.get(\"1BTDevicesPaired\"))\n//msg = global.get(\"aSingleEntryArrayValue1\")\nreturn msg;","outputs":1,"noerr":0,"x":390,"y":40,"wires":[["7031493c.d2bfc8"]]},{"id":"7031493c.d2bfc8","type":"function","z":"592962b2.a94e1c","name":"Revised ","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//delete the currentValue portion of the object since it is deprecated\ndelete msg.payload.currentValue\n//initial call into the recursive function\nhandlemsg(msg)\n//send nothing from main code\nreturn\n\n/*\n * Main recursive function code\n *\n */\n\nfunction handlemsg(msg) {\n    //The evaluation part of this switch/case statement determines which type of entity is in the value\n    //  the key idea is that once the value is an atomic item (number, string, bool) then the message should be sent out\n    //  of the node to downstream, but if the value is a splittable, then it should be split into multiple messages. These\n    //  messages are then evaulated individually. They in turn are either found to have atomic entries in the value or have\n    //  values that are themselves splittable.\n    //  For example:\n    //  JSON - each key value pair will be used to create a new msg. The msg.payload.name will be changed to add \":\" and the key\n    //          from the key value pair. The msg.payload.value will become the value from the key value pair\n    //  Array - TBAdded\n    //  Object - TBAdded\n    switch (typeofhubitatvalue(msg.payload.value, \"msg.payload.value\")) {\n        case \"number\":\n        case \"bigint\":\n            //numbers are an atomic type of value and should be sent to downstream nodes\n            msg.payload.dataType = \"Number\"\n            //send the version of the msg with an atomic value to downstream nodes\n            node.send(msg)\n            //do nothing more once msg has been sent\n            break;\n        case \"boolean\":\n            //Booleans are an atomic type of value and should be sent to downstream nodes\n            msg.payload.dataType = \"Boolean\"\n            //send the version of the msg with an atomic value to downstream nodes\n            node.send(msg)\n            //do nothing more once msg has been sent\n            break;\n        case \"string\":\n            //Strings are an atomic type of value and should be sent to downstream nodes\n            msg.payload.dataType = \"String\"\n            //send the version of the msg with an atomic value to downstream nodes\n            node.send(msg)\n            //do nothing more once msg has been sent\n            break;\n        case \"unsplittable array\":\n            //This case is where the item is an array, but with only a single entry. The idea is to move that single\n            //  value out of the array and into the value natively and then to call the recursive function to evaluate\n            //  what type of item it now is and then process (split or send or extract) appropriately\n            msg.payload.value = msg.payload.value[0]\n            handlemsg(msg)\n            break;\n        case \"splittable JSON\":\n            //This is for cases where the JSON is in the form of key:value where there is at least 1 pair\n            //  Examples of \"valid\" JSON that would not be coming to this case would be {} or 100\n            splitJSON(msg)\n            break;\n        case \"splittable array\":\n            //This is for cases where the Array is in the form [\"A\",\"B\",\"C\"] where there is are at least 2 members\n            //  SplitArray function not yet built. TBD\n            splitArray(msg)\n            break;\n        case \"unsplittable JSON\":\n            //This is for handling \"valid\" JSON that does not have key:value pairs.\n            //  Examples of \"valid\" JSON that are handed here are {} or 100 or \"100\"\n            //  This case either treats it as a string (no changes made) or a number where a number in\n            //  a string like \"100\" is changed into an actual number like 100\n\n            //by checking if NaN, if it is a number 100 or \"100\", the ++ followed by -- changes it to a number 100\n            //  without changing its actual value\n            if (isNaN(msg.payload.value)) { } else {\n                ++msg.payload.value\n                --msg.payload.value\n             }\n            //Sets the data type for downstream since the incoming message could have been a variety of types\n            //  before JSON, object or array was split\n            msg.payload.dataType = typeof (msg.payload.value)\n            //send the version of the msg with an atomic value to downstream nodes (could probably just recursively call\n            //  handlemsg, but I can't identify a circumstance where that would give a different result to downstream,\n            //  but this would be a place to investigate if downstream results are unexpected.)\n            node.send(msg)\n            break\n        case \"object\":\n            //This is for handling an object. It then calls splitObj to create multiple msgs with the object keys into the names\n            //  and the values from those keys moved into the value of the new object.\n            splitObj(msg)\n            break\n        default:\n            //This is just in case no valid process is found by the typeofhubitatvalue function.\n            //  If you encounter this then you will either need to investigate the function or contact tmichael in\n            //  Hubitat discourse forums https://community.hubitat.com/\n            return\n    }\n}\n\n/*\n * This function is used by the Main recursive function (handlemsg) to decide whether to send the msg on as\n *  the msg.payload.value is atomic or if it needs to split the value into multiple msgs\n *\n */\nfunction typeofhubitatvalue(value, source = \"\") {\n    switch (typeof (value)) {\n        case \"number\":\n            //atomic just return the result of typeof\n            return \"number\"\n            break;\n        case \"bigint\":\n            //atomic just return the result of typeof\n            return \"bigint\"\n            break;\n        case \"boolean\":\n            //atomic just return the result of typeof\n            return \"boolean\"\n            break;\n        case \"string\":\n            //most splittable values are encoded strictly as text and so may be identified as a string\n\n            //Fist check if the string is \"valid\" JSON\n            if (isvalidJSONstring(value)) {\n                //When it is \"valid\" JSON, check if it is splittable\n                if (issplittablevalidJSONstring(value)) {\n                    //When it is splittable, then return type as splittable JSON\n                    return \"splittable JSON\"\n                }\n                else\n                {\n                    //if it is JSON, but not splittable ({}, \"100, 100) return unsplittable JSON\n                    return \"unsplittable JSON\"\n                }\n            }\n            else\n            {\n                //When it isn't \"valid\" JSON, check if it is an array\n                if (isvalidarray(value)) {\n                    //When it is an array, check if it is splittable\n                    if (issplittablearray(value)) {\n                        //When it is splittable, return splittable Array\n                        return \"splittable Array\"\n                    }\n                    else\n                    {\n                        //if the array is not splittable ([\"apple\"]) return unsplittable array\n                        return \"unsplittable array\"\n                    }\n                }\n                else\n                {\n                    //When it is neither JSON or Array, then it is really just a string, so return string\n                    return \"string\"\n                }\n            }\n            break;\n        case \"object\":\n            //some  splittable values are identified as objects\n\n            //Fist check if the object is \"valid\" JSON\n            if (isvalidJSONstring(value)) {\n                //When it is \"valid\" JSON, check if it is splittable\n                if (issplittablevalidJSONstring(value)) {\n                    //When it is splittable, then return type as splittable JSON\n                    return \"splittable JSON\"\n                }\n                else\n                {\n                    //if it is JSON, but not splittable ({}, \"100, 100) return unsplittable JSON\n                    return \"unsplittable JSON\"\n                }\n            }\n            else\n            {\n                //When it isn't \"valid\" JSON, check if it is an array\n                if (isvalidarray(value)) {\n                    //When it is an array, check if it is splittable\n                    if (issplittablearray(value)) {\n                        //When it is splittable, return splittable Array\n                        return \"splittable Array\"\n                    }\n                    else {\n                        //if the array is not splittable ([\"apple\"]) return unsplittable array\n                        return \"unsplittable array\"\n                    }\n                }\n                else\n                {\n                    //When it is neither JSON or Array, then I have not accounted for it. If you reach this point during an\n                    //  investigation, it might be worth using the example that triggered your investigation to see if the object\n                    //  is really just a string (without a triggering example I have not investigated)\n                    return \"object\"\n                }\n            }\n            break;\n        default:\n            //When the type is not one that I coded for then return unhandled because the situation is by definition unhandled\n            return \"unhandled\"\n            break;\n    }\n}\n\n//True False functions\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction isvalidJSONstring(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\n\n/*\n * This function decides where the JSON is made up of at least 1 key:value pair\n */\nfunction issplittablevalidJSONstring(str) {\n    if (str.includes(\":\")) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/*\n * This function is simply wrapping the Array.isArray, to align the function naming with the other true false functions\n */\nfunction isvalidarray(str) {\n    if (Array.isArray(str)) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/*\n * This function identifies if the array has only a single entry or multiple entries i.e. [\"Apple\"] not splittable,\n *  [\"Apple\",\"Pear\"] splittable\n */\nfunction issplittablearray(str) {\n    // If the length is more than 1, then the array has mutliple entries, but if it is just 1, then it is not splittable\n    if (str.length > 1) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n//Splitting functions\n/*\n * This function takes in a msg where msg.payload.value is splittable JSON and iterates through all key:value pairs and then\n *  recursively calls handlemsg with multiple messages. Each new message retains most of the details of the input message, \n *  but the name and value are changed.\n *  The name has the key from the key:value pair appended with a : as a seperator\n *  The value is replaced with the value from the key:value pair\n *  A new message is created for each key:value pair\n */\nfunction splitJSON(latestMsg) {\n    //put the inputs value into a variable for easier access\n    var valueJSON = JSON.parse(latestMsg.payload.value);\n    //put the inputs name aside for multiple reuses\n    var name = latestMsg.payload.name\n    //Iterative loop\n    Object.keys(valueJSON).forEach(function (key) {\n        //concatenate the original name, a colon and the key from the pair\n        latestMsg.payload.name = name + \":\" + key;\n        //move the value from the pair to payload.value\n        latestMsg.payload.value = valueJSON[key];\n        //recursively call this function in case the value is itself splittable\n        handlemsg(latestMsg)\n    }\n    )\n    return\n}\n\n/*\n * This function takes in a msg where msg.payload.value is splittable object\n *  and iterates through all key:value pairs and then\n *  recursively calls handlemsg with multiple messages. Each new message retains most of the details of the input message,\n *  but the name and value are changed.\n *  The name has the key from the key:value pair appended with a : as a seperator\n *  The value is replaced with the value from the key:value pair\n *  A new message is created for each key:value pair\n *  \n *  Note: While working on the splitArray function, I realized that I may not have tested this on an object value with multiple\n *  pairs, so it is possible that the function only handles the first pair\n */\nfunction splitObj(oMsg) {\n    //put the inputs name aside for multiple reuses\n    var name = oMsg.payload.name\n    //Iterative loop\n    for (let [key, value] of Object.entries(oMsg.payload.value)) {\n        if ((value !== null) && (key !== null)) {\n            oMsg.payload.name = name + \":\" + key;\n            oMsg.payload.value = value;\n            //recursively call this function in case the value is itself splittable\n            handlemsg(oMsg)\n        }\n    }\n}\n\n/*\n * Note: At the time of creation, I did not have a live example and had too many other things in the works to construct one.\n * \n * This function takes in a msg where msg.payload.value is splittable array\n *  and iterates through all entries and recursively calls handlemsg with multiple messages. \n *  Each new message retains most of the details of the input message,\n *  but the value is changed.\n *  The value is replaced with the value from the entry in the Array\n *  For example if the input value is [\"Apple\",\"Pear\"], then the first msg will have a value of \"Apple\"\n *  and the second will have a value of \"Pear\"\n */\nfunction splitArray(aMsg) {\n    //Iterative loop\n    for (index = 0; index < aMsg.payload.value.length; index++) {\n        (aMsg.payload.value = aMsg.payload.value[index]);\n        //recursively call this function in case the value is itself splittable\n        handlemsg(aMsg)\n    }\n}","outputs":1,"noerr":0,"x":660,"y":120,"wires":[["61d2ed4f.696564"]]},{"id":"fc0508fc.6fcb08","type":"inject","z":"592962b2.a94e1c","name":"","topic":"2TrackData","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":140,"y":80,"wires":[["ad6aef23.d3b7a"]]},{"id":"ad6aef23.d3b7a","type":"function","z":"592962b2.a94e1c","name":"2TrackData","func":"//msg = global.get(\"badinput\")\n//msg = global.get(\"goodinput\")\n//msg = global.get(\"ArrayInJSON2\")\nmsg = RED.util.cloneMessage(global.get(\"2TrackData\"))\n//msg = global.get(\"aSingleEntryArrayValue1\")\nreturn msg;","outputs":1,"noerr":0,"x":370,"y":80,"wires":[["7031493c.d2bfc8"]]},{"id":"c81ffb33.1848e8","type":"inject","z":"592962b2.a94e1c","name":"","topic":"3AuidioTrackData","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":160,"y":120,"wires":[["39909aba.91e7a6"]]},{"id":"39909aba.91e7a6","type":"function","z":"592962b2.a94e1c","name":"3AuidioTrackData","func":"//msg = global.get(\"badinput\")\n//msg = global.get(\"goodinput\")\n//msg = global.get(\"ArrayInJSON2\")\nmsg = RED.util.cloneMessage(global.get(\"3AuidioTrackData\"))\n//msg = global.get(\"aSingleEntryArrayValue1\")\nreturn msg;","outputs":1,"noerr":0,"x":390,"y":120,"wires":[["7031493c.d2bfc8"]]},{"id":"e9ec0601.e5ef98","type":"function","z":"592962b2.a94e1c","name":"","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\n//node.warn(\"line 6 \" +msg.payload.value)\nif (msg.payload.value === null) {\n    return null;\n}\n//a = typeofhubitatvalue(msg, \"msg\")\n//a = typeofhubitatvalue(msg.payload, \"msg.payload\")\na = typeofhubitatvalue(msg.payload.value, \"msg.payload.value\")\nnode.warn(a)\nhandlemsg(msg)\nfunction handlemsg(msg) {\n    switch (typeofhubitatvalue(msg.payload.value, \"msg.payload.value\")) {\n        case \"number\":\n        case \"bigint\":\n            node.warn(\"Passing \" + msg.payload.value + \" as a number\")\n            break;\n        case \"boolean\":\n            node.warn(\"Passing \" + msg.payload.value + \" as a boolean\")\n            break;\n        case \"string\":\n        case \"unsplitable JSON\":\n        case \"unsplitable array\":\n            node.warn(\"Passing \" + msg.payload.value + \" as a string\")\n            break;\n        case \"splitable JSON\":\n            node.warn(\"Spliting the \" + msg.payload.value + \" JSON string\")\n            break;\n        case \"splitable array\":\n            node.warn(\"Spliting the \" + msg.payload.value + \" array string\")\n            break;\n        default:\n            node.warn(\"The \" + msg.payload.value + \" is unhandled\")\n            return\n    }\n}\n/*\n * number\n * bigint\n * boolean\n * string\n *      JSON\n *          any\n *      Array\n *          any\n *      string\n *      convertible numb, bigint, boolean\n *   \n * \n * object\n * undefined\n * symbol\n * function\n*/\n\nfunction typeofhubitatvalue(value,source =\"\") {\n    var identifiedtype = \"\"\n    switch (typeof(value)) {\n        case \"number\":\n            node.warn(\"The \" + source + \" is a number with value \" + value)\n            return \"number\"\n            break;\n        case \"bigint\":\n            node.warn(\"The \" + source + \" is a bigint with value \" + value)\n            return \"bigint\"\n            break;\n        case \"boolean\":\n            node.warn(\"The \" + source + \" is a boolean with value \" + value)\n            return \"boolean\"\n            break;\n        case \"string\":\n            node.warn(\"The \" + source + \" is a string with value \" + value)\n            if (isvalidJSONstring(value)) {\n                node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is JSON in the string\")\n                if (issplitablevalidJSONstring(value)) {\n                    node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is a splitable JSON in the string\")\n                    return \"splitable JSON\"\n                }\n                else {\n                    node.warn(\"It is false that the \" + source + \" (\" + value + \")\" + \" is a splitable JSON in the string\")\n                    return \"unsplitable JSON\"\n                }\n            }\n            else {\n                node.warn(\"It is false that the \" + source + \" (\" + value + \")\" + \" is JSON in the string\")\n                if (isvalidarray(value)) {\n                    node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is an array in the string\")\n                    if (issplitablearray(value)) {\n                        node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is a splitable array in the string\")\n                        return \"Splitable Array\"\n                    }\n                    else {\n                        node.warn(\"It is false that the \" + source + \" (\" + value + \")\" + \" is a splitable array in the string\")\n                        return \"unsplitable array\"\n                    }\n                }\n                else {\n                    node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is neither JSON nor an array and thus is a regular string\")\n                    return \"string\"\n                }\n            }\n            break;\n        default:\n            node.warn(\"The \" + source + \" (\" + value + \")\" + \" is an object, undefined, symbol or function and will not be processed by this function.\")\n            return \"unhandled\"\n            break;\n    }\n    return identifiedtype\n}\nfunction whichTypeOfString(sMsg) {\n}\nfunction splitJSON(jMsg) {\n}\nfunction splitArry(aMsg) {\n}\n\n\n\n//True False functions\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction isvalidJSONstring(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\n/*\n * Document a valid description\n */\nfunction issplitablevalidJSONstring(str) {\n    if (str.includes(\":\")) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/*\n * Document a valid description\n */\nfunction isvalidarray(str) {\n    if (Array.isArray(str)) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/*\n * Document a valid description\n */\nfunction issplitablearray(str) {\n    if (str.length == 1) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n","outputs":1,"noerr":0,"x":1170,"y":400,"wires":[[]]},{"id":"7624c591.ac4fdc","type":"function","z":"592962b2.a94e1c","name":"","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\n//node.warn(\"line 6 \" +msg.payload.value)\npmsg = RED.util.cloneMessage(msg)\nif (pmsg.payload.value === null) {\n    return null;\n}\n//a = typeofhubitatvalue(msg, \"msg\")\n//a = typeofhubitatvalue(msg.payload, \"msg.payload\")\n//a = typeofhubitatvalue(msg.payload.value, \"msg.payload.value\")\n//node.warn(a)\ndelete pmsg.payload.currentValue\nhandlemsg(pmsg)\nreturn\n\nfunction handlemsg(msg) {\n    node.warn(\"1 handle message (JSON), 10 handle message of array holding JSON, 22 handle message of JSON,34\")\n    switch (typeofhubitatvalue(msg.payload.value, \"msg.payload.value\")) {\n        case \"number\":\n        case \"bigint\":\n            node.warn(\"999 Passing \" + msg.payload.value + \" as a number\")\n            msg.payload.dataType = \"Number\"\n            node.send(msg)\n            break;\n        case \"boolean\":\n            node.warn(\"999 Passing \" + msg.payload.value + \" as a boolean\")\n            msg.payload.dataType = \"Boolean\"\n            node.send(msg)\n            break;\n        case \"string\":\n            node.warn(\"999 Passing \" + msg.payload.value + \" as a string\")\n            msg.payload.dataType = \"String\"\n            node.send(msg)\n            break;\n        case \"unsplitable array\":\n            node.warn(\"21 treat as unsplitable array\")\n            msg.payload.value = msg.payload.value[0]\n            node.warn(\"22 treat as unsplitable array\")\n            handlemsg(msg)\n            break;\n        case \"splitable JSON\":\n            node.warn(\"7 test typeofhubitatvalue Case splitable JSON\")\n            splitJSON(msg)\n            break;\n        case \"splitable array\":\n            node.warn(\"Spliting the \" + msg.payload.value + \" array string\")\n            splitArray(msg)\n            break;\n        case \"unhandled XXXX\":\n            node.warn(\"32 object in need of splitting\")\n            splitObj(msg)\n            break\n        case \"unsplitable JSON\":\n            node.warn(\"42 ended in unsplitable JSON\")\n            node.warn(typeof (msg.payload.value))\n            if (isNaN(msg.payload.value)) { } else {\n                ++msg.payload.value\n                --msg.payload.value\n             }\n            node.warn(typeof (msg.payload.value))\n            node.warn(msg.payload.value)\n            node.warn(\"999 in unsplitable JSON, but passing \" + msg.payload.value + \" as a number\")\n            msg.payload.dataType = typeof (msg.payload.value)\n            node.send(msg)\n            break\n/*        case \"unsplitable JSON\":\n            node.warn(\"42 ended in unsplitable JSON\")\n            node.warn(typeof (msg.payload.value))\n            ++msg.payload.value\n            --msg.payload.value\n            node.warn(typeof (msg.payload.value))\n            node.warn(msg.payload.value)\n            node.warn(\"999 in unsplitable JSON, but passing \" + msg.payload.value + \" as a number\")\n            msg.payload.dataType = typeof (msg.payload.value)\n            node.send(msg)\n            break */\n        default:\n            node.warn(\"The \" + msg.payload.value + \" is unhandled\")\n            return\n    }\n}\n\nfunction typeofhubitatvalue(value, source = \"\") {\n    node.warn(\"2 type of hubitat value, 11, 23\")\n    var identifiedtype = \"\"\n    //node.warn(\"1 check type of the initial value\" + typeof (value) + \" is the type of \" + value)\n    node.warn(\"3 check type of value using original value, 12,24,35\")\n    switch (typeof (value)) {\n        case \"number\":\n            node.warn(\"typeof value case number\")\n            node.warn(\"The \" + source + \" is a number with value \" + value)\n            return \"number\"\n            break;\n        case \"bigint\":\n            node.warn(\"typeof value case bigint\")\n            node.warn(\"The \" + source + \" is a bigint with value \" + value)\n            return \"bigint\"\n            break;\n        case \"boolean\":\n            node.warn(\"typeof value case boolean\")\n            node.warn(\"The \" + source + \" is a boolean with value \" + value)\n            return \"boolean\"\n            break;\n        case \"string\":\n            node.warn(\"4 typeof value case string\")\n            //node.warn(\"The \" + source + \" is a string with value \" + value)\n            node.warn(\"5 call is valid JSON\")\n            if (isvalidJSONstring(value)) {\n                // node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is JSON in the string\")\n                node.warn(\"6 call is splitable JSON\")\n                if (issplitablevalidJSONstring(value)) {\n                    //node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is a splitable JSON in the string\")\n                    return \"splitable JSON\"\n                }\n                else {\n                    node.warn(\"40 It is false that the \" + source + \" (\" + value + \")\" + \" is a splitable JSON in the string\")\n                    return \"unsplitable JSON\"\n                }\n            }\n            else {\n                node.warn(\"It is false that the \" + source + \" (\" + value + \")\" + \" is JSON in the string\")\n                if (isvalidarray(value)) {\n                    node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is an array in the string\")\n                    if (issplitablearray(value)) {\n                        node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is a splitable array in the string\")\n                        return \"splitable Array\"\n                    }\n                    else {\n                        node.warn(\"It is false that the \" + source + \" (\" + value + \")\" + \" is a splitable array in the string\")\n                        return \"unsplitable array\"\n                    }\n                }\n                else {\n                    node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is neither JSON nor an array and thus is a regular string\")\n                    return \"string\"\n                }\n            }\n            break;\n        case \"object\":\n            node.warn(\"13 typeof value case object,25,36\")\n            node.warn(\"14 The \" + source + \" is an object with value\"  + value+\" , 26,37\")\n            node.warn(\"15 Check if JSON,27\")\n            global.set(\"JSONnotJSON\",value)\n            if (isvalidJSONstring(value)) {\n                if (issplitablevalidJSONstring(value)) {\n                    //node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is a splitable JSON in the string\")\n                    return \"splitable JSON\"\n                }\n                else {\n                    node.warn(\"It is false that the \" + source + \" (\" + value + \")\" + \" is a splitable JSON in the string\")\n                    return \"unsplitable JSON\"\n                }\n            }\n            else {\n                node.warn(\"16 This valid JSON false (hardcoded), 29\")\n                node.warn(\"17 check if it is array,30\")\n                if (isvalidarray(value)) {\n                    node.warn(\"18 it is array\")\n                    node.warn(\"19 check if splittable\")\n                    if (issplitablearray(value)) {\n                        node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is a splitable array in the string\")\n                        return \"splitable Array\"\n                    }\n                    else {\n                        node.warn(\"20 find out it is not and return unsplitable array\")\n                        return \"unsplitable array\"\n                    }\n                }\n                else {\n                    node.warn(\"31 find out not an array\")\n                    //node.warn(\"The \" + source + \" (\" + value + \")\" + \" is an object other than an array and will not be processed by this function.\")\n                    return \"unhandled XXXX\"\n                }\n            }\n            break;\n//        case \"[object Object]\":\n  //          node.warn(\"[object Object]\")\n    //        break;\n        default:\n            node.warn(\"The \" + source + \" (\" + value + \")\" + \" is an object, undefined, symbol or function and will not be processed by this function.\")\n            return \"unhandled\"\n            break;\n    }\n    return identifiedtype\n}\nfunction splitArray(aMsg) {\n    node.warn(\"************************splitting Array\")\n    node.warn(\"placeholder for splitting array\")\n}\n\n\n\n//True False functions\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction isvalidJSONstring(str) {\n    node.warn(\"5 ************************validate if JSON, 15,27\")\n    global.set(\"JnotJinsideIsvalid\",str)\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        node.error(e)\n        node.warn(\"28 showing contents of the object\")\n        for (let [key, value] of Object.entries(str)) {\n            //node.warn(`${key}: ${value}`)\n        }\n        return false;\n    }\n    return true;\n}\n\n/*\n * Document a valid description\n */\nfunction issplitablevalidJSONstring(str) {\n    node.warn(\"6************************checking if splittable JSON\")\n    if (str.includes(\":\")) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/*\n * Document a valid description\n */\nfunction isvalidarray(str) {\n    node.warn(\"17 ************************validate if array,30\")\n    //node.warn(\"This is what is passed to is valid array\" + str)\n    //node.warn(\"This is what you get if you take what is passed to is valid array and convert to string\" + str.toString())\n    if (Array.isArray(str)) {\n        node.warn(\"18 it is array\")\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/*\n * Document a valid description\n */\nfunction issplitablearray(str) {\n    node.warn(\"19 ************************checking if splittable array\")\n    node.warn(\"length of array = \" + str.length)\n    if (str.length > 1) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nfunction splitJSON(latestMsg) {\n    node.warn(\"8 ************************splitting JSON\")\n    var valueJSON = JSON.parse(latestMsg.payload.value);\n    //set aside the original name to become the leading part of the concatenation\n    var name = latestMsg.payload.name\n    Object.keys(valueJSON).forEach(function (key) {\n        //concatenate the original name, a colon and the key from the pair\n        latestMsg.payload.name = name + \":\" + key;\n        //move the value from the pair to payload.value\n        latestMsg.payload.value = valueJSON[key];\n        //recursively call this function in case the value is itself JSON\n        node.warn(latestMsg.payload.name)\n        node.warn(latestMsg.payload.value)\n        //node.warn(\"splitJson function is calling handlemsg recursively with value \" + latestMsg.payload.value)\n        global.set(\"RecursivelySentMsg\", latestMsg)\n        node.warn(\"9 calling handlemsg 1 or more times sending split message\")\n        handlemsg(latestMsg)\n    }\n    )\n    return;\n}\n\nfunction splitObj(oMsg) {\n    node.warn(\"32***********************splitting Object\")\n    /*var valueJSON = JSON.parse(latestMsg.payload.value);\n    //set aside the original name to become the leading part of the concatenation\n    var name = msg.payload.name\n    Object.keys(valueJSON).forEach(function (key) {\n        //concatenate the original name, a colon and the key from the pair\n        latestMsg.payload.name = name + \":\" + key;\n        //move the value from the pair to payload.value\n        latestMsg.payload.value = valueJSON[key];\n        //recursively call this function in case the value is itself JSON\n        node.warn(latestMsg.payload.name)\n        node.warn(latestMsg.payload.value)\n        //node.warn(\"splitJson function is calling handlemsg recursively with value \" + latestMsg.payload.value)\n        global.set(\"RecursivelySentMsg\", latestMsg)\n        node.warn(\"9 calling handlemsg 1 or more times sending split message\")\n        handlemsg(latestMsg)\n    }\n    )*/\n    for (let [key, value] of Object.entries(oMsg.payload.value)) {\n        var name = oMsg.payload.name\n        //node.warn(name)\n        //node.warn(`${key}: ${value}`)\n        //node.warn(key)\n        if ((value !== null) && (key !== null)) {\n            oMsg.payload.name = name + \":\" + key;\n            oMsg.payload.value = value;\n            node.warn(\"33 calling handlemsg 1 or more times sending split message\")\n            node.warn(\"33.1 \" + oMsg.payload.value)\n            node.warn(\"33.2 \" + oMsg.payload.name)\n            handlemsg(oMsg)\n            //if (oMsg.payload.value === \"Upgraded Audio\") { handlemsg(oMsg) }\n            //if (oMsg.payload.value === \"Upgraded Audio\") {\n              //  node.warn(\"handling title\")\n               // handlemsg(oMsg)\n            //}\n        }\n    }\n}\n","outputs":1,"noerr":0,"x":1170,"y":360,"wires":[[]]},{"id":"1aadec4e.9a1cf4","type":"function","z":"592962b2.a94e1c","name":"7 4/30 screaming release candidate","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\n//node.warn(\"line 6 \" +msg.payload.value)\n//msg = RED.util.cloneMessage(msg)\nif (msg.payload.value === null) {\n    return null;\n}\n//a = typeofhubitatvalue(msg, \"msg\")\n//a = typeofhubitatvalue(msg.payload, \"msg.payload\")\n//a = typeofhubitatvalue(msg.payload.value, \"msg.payload.value\")\n//node.warn(a)\ndelete msg.payload.currentValue\nhandlemsg(msg)\nreturn\n\nfunction handlemsg(msg) {\n    node.warn(\"1 handle message (JSON), 10 handle message of array holding JSON, 22 handle message of JSON,34\")\n    switch (typeofhubitatvalue(msg.payload.value, \"msg.payload.value\")) {\n        case \"number\":\n        case \"bigint\":\n            node.warn(\"999 Passing \" + msg.payload.value + \" as a number\")\n            msg.payload.dataType = \"Number\"\n            node.send(msg)\n            break;\n        case \"boolean\":\n            node.warn(\"999 Passing \" + msg.payload.value + \" as a boolean\")\n            msg.payload.dataType = \"Boolean\"\n            node.send(msg)\n            break;\n        case \"string\":\n            node.warn(\"999 Passing \" + msg.payload.value + \" as a string\")\n            msg.payload.dataType = \"String\"\n            node.send(msg)\n            break;\n        case \"unsplitable array\":\n            node.warn(\"21 treat as unsplitable array\")\n            msg.payload.value = msg.payload.value[0]\n            node.warn(\"22 treat as unsplitable array\")\n            handlemsg(msg)\n            break;\n        case \"splitable JSON\":\n            node.warn(\"7 test typeofhubitatvalue Case splitable JSON\")\n            splitJSON(msg)\n            break;\n        case \"splitable array\":\n            node.warn(\"Spliting the \" + msg.payload.value + \" array string\")\n            splitArray(msg)\n            break;\n        case \"unhandled XXXX\":\n            node.warn(\"32 object in need of splitting\")\n            splitObj(msg)\n            break\n        case \"unsplitable JSON\":\n            node.warn(\"42 ended in unsplitable JSON\")\n            node.warn(typeof (msg.payload.value))\n            if (isNaN(msg.payload.value)) { } else {\n                ++msg.payload.value\n                --msg.payload.value\n             }\n            node.warn(typeof (msg.payload.value))\n            node.warn(msg.payload.value)\n            node.warn(\"999 in unsplitable JSON, but passing \" + msg.payload.value + \" as a number\")\n            msg.payload.dataType = typeof (msg.payload.value)\n            node.send(msg)\n            break\n/*        case \"unsplitable JSON\":\n            node.warn(\"42 ended in unsplitable JSON\")\n            node.warn(typeof (msg.payload.value))\n            ++msg.payload.value\n            --msg.payload.value\n            node.warn(typeof (msg.payload.value))\n            node.warn(msg.payload.value)\n            node.warn(\"999 in unsplitable JSON, but passing \" + msg.payload.value + \" as a number\")\n            msg.payload.dataType = typeof (msg.payload.value)\n            node.send(msg)\n            break */\n        default:\n            node.warn(\"The \" + msg.payload.value + \" is unhandled\")\n            return\n    }\n}\n\nfunction typeofhubitatvalue(value, source = \"\") {\n    node.warn(\"2 type of hubitat value, 11, 23\")\n    var identifiedtype = \"\"\n    //node.warn(\"1 check type of the initial value\" + typeof (value) + \" is the type of \" + value)\n    node.warn(\"3 check type of value using original value, 12,24,35\")\n    switch (typeof (value)) {\n        case \"number\":\n            node.warn(\"typeof value case number\")\n            node.warn(\"The \" + source + \" is a number with value \" + value)\n            return \"number\"\n            break;\n        case \"bigint\":\n            node.warn(\"typeof value case bigint\")\n            node.warn(\"The \" + source + \" is a bigint with value \" + value)\n            return \"bigint\"\n            break;\n        case \"boolean\":\n            node.warn(\"typeof value case boolean\")\n            node.warn(\"The \" + source + \" is a boolean with value \" + value)\n            return \"boolean\"\n            break;\n        case \"string\":\n            node.warn(\"4 typeof value case string\")\n            //node.warn(\"The \" + source + \" is a string with value \" + value)\n            node.warn(\"5 call is valid JSON\")\n            if (isvalidJSONstring(value)) {\n                // node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is JSON in the string\")\n                node.warn(\"6 call is splitable JSON\")\n                if (issplitablevalidJSONstring(value)) {\n                    //node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is a splitable JSON in the string\")\n                    return \"splitable JSON\"\n                }\n                else {\n                    node.warn(\"40 It is false that the \" + source + \" (\" + value + \")\" + \" is a splitable JSON in the string\")\n                    return \"unsplitable JSON\"\n                }\n            }\n            else {\n                node.warn(\"It is false that the \" + source + \" (\" + value + \")\" + \" is JSON in the string\")\n                if (isvalidarray(value)) {\n                    node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is an array in the string\")\n                    if (issplitablearray(value)) {\n                        node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is a splitable array in the string\")\n                        return \"splitable Array\"\n                    }\n                    else {\n                        node.warn(\"It is false that the \" + source + \" (\" + value + \")\" + \" is a splitable array in the string\")\n                        return \"unsplitable array\"\n                    }\n                }\n                else {\n                    node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is neither JSON nor an array and thus is a regular string\")\n                    return \"string\"\n                }\n            }\n            break;\n        case \"object\":\n            node.warn(\"13 typeof value case object,25,36\")\n            node.warn(\"14 The \" + source + \" is an object with value\"  + value+\" , 26,37\")\n            node.warn(\"15 Check if JSON,27\")\n            global.set(\"JSONnotJSON\",value)\n            if (isvalidJSONstring(value)) {\n                if (issplitablevalidJSONstring(value)) {\n                    //node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is a splitable JSON in the string\")\n                    return \"splitable JSON\"\n                }\n                else {\n                    node.warn(\"It is false that the \" + source + \" (\" + value + \")\" + \" is a splitable JSON in the string\")\n                    return \"unsplitable JSON\"\n                }\n            }\n            else {\n                node.warn(\"16 This valid JSON false (hardcoded), 29\")\n                node.warn(\"17 check if it is array,30\")\n                if (isvalidarray(value)) {\n                    node.warn(\"18 it is array\")\n                    node.warn(\"19 check if splittable\")\n                    if (issplitablearray(value)) {\n                        node.warn(\"It is true that the \" + source + \" (\" + value + \")\" + \" is a splitable array in the string\")\n                        return \"splitable Array\"\n                    }\n                    else {\n                        node.warn(\"20 find out it is not and return unsplitable array\")\n                        return \"unsplitable array\"\n                    }\n                }\n                else {\n                    node.warn(\"31 find out not an array\")\n                    //node.warn(\"The \" + source + \" (\" + value + \")\" + \" is an object other than an array and will not be processed by this function.\")\n                    return \"unhandled XXXX\"\n                }\n            }\n            break;\n//        case \"[object Object]\":\n  //          node.warn(\"[object Object]\")\n    //        break;\n        default:\n            node.warn(\"The \" + source + \" (\" + value + \")\" + \" is an object, undefined, symbol or function and will not be processed by this function.\")\n            return \"unhandled\"\n            break;\n    }\n    return identifiedtype\n}\nfunction splitArray(aMsg) {\n    node.warn(\"************************splitting Array\")\n    node.warn(\"placeholder for splitting array\")\n}\n\n\n\n//True False functions\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction isvalidJSONstring(str) {\n    node.warn(\"5 ************************validate if JSON, 15,27\")\n    global.set(\"JnotJinsideIsvalid\",str)\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        node.error(e)\n        node.warn(\"28 showing contents of the object\")\n        for (let [key, value] of Object.entries(str)) {\n            //node.warn(`${key}: ${value}`)\n        }\n        return false;\n    }\n    return true;\n}\n\n/*\n * Document a valid description\n */\nfunction issplitablevalidJSONstring(str) {\n    node.warn(\"6************************checking if splittable JSON\")\n    if (str.includes(\":\")) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/*\n * Document a valid description\n */\nfunction isvalidarray(str) {\n    node.warn(\"17 ************************validate if array,30\")\n    //node.warn(\"This is what is passed to is valid array\" + str)\n    //node.warn(\"This is what you get if you take what is passed to is valid array and convert to string\" + str.toString())\n    if (Array.isArray(str)) {\n        node.warn(\"18 it is array\")\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/*\n * Document a valid description\n */\nfunction issplitablearray(str) {\n    node.warn(\"19 ************************checking if splittable array\")\n    node.warn(\"length of array = \" + str.length)\n    if (str.length > 1) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nfunction splitJSON(latestMsg) {\n    node.warn(\"8 ************************splitting JSON\")\n    var valueJSON = JSON.parse(latestMsg.payload.value);\n    //set aside the original name to become the leading part of the concatenation\n    var name = latestMsg.payload.name\n    Object.keys(valueJSON).forEach(function (key) {\n        //concatenate the original name, a colon and the key from the pair\n        latestMsg.payload.name = name + \":\" + key;\n        //move the value from the pair to payload.value\n        latestMsg.payload.value = valueJSON[key];\n        //recursively call this function in case the value is itself JSON\n        node.warn(latestMsg.payload.name)\n        node.warn(latestMsg.payload.value)\n        //node.warn(\"splitJson function is calling handlemsg recursively with value \" + latestMsg.payload.value)\n        global.set(\"RecursivelySentMsg\", latestMsg)\n        node.warn(\"9 calling handlemsg 1 or more times sending split message\")\n        handlemsg(latestMsg)\n    }\n    )\n    return;\n}\n\nfunction splitObj(oMsg) {\n    node.warn(\"32***********************splitting Object\")\n    /*var valueJSON = JSON.parse(latestMsg.payload.value);\n    //set aside the original name to become the leading part of the concatenation\n    var name = msg.payload.name\n    Object.keys(valueJSON).forEach(function (key) {\n        //concatenate the original name, a colon and the key from the pair\n        latestMsg.payload.name = name + \":\" + key;\n        //move the value from the pair to payload.value\n        latestMsg.payload.value = valueJSON[key];\n        //recursively call this function in case the value is itself JSON\n        node.warn(latestMsg.payload.name)\n        node.warn(latestMsg.payload.value)\n        //node.warn(\"splitJson function is calling handlemsg recursively with value \" + latestMsg.payload.value)\n        global.set(\"RecursivelySentMsg\", latestMsg)\n        node.warn(\"9 calling handlemsg 1 or more times sending split message\")\n        handlemsg(latestMsg)\n    }\n    )*/\n    for (let [key, value] of Object.entries(oMsg.payload.value)) {\n        var name = oMsg.payload.name\n        //node.warn(name)\n        //node.warn(`${key}: ${value}`)\n        //node.warn(key)\n        if ((value !== null) && (key !== null)) {\n            oMsg.payload.name = name + \":\" + key;\n            oMsg.payload.value = value;\n            node.warn(\"33 calling handlemsg 1 or more times sending split message\")\n            node.warn(\"33.1 \" + oMsg.payload.value)\n            node.warn(\"33.2 \" + oMsg.payload.name)\n            handlemsg(oMsg)\n            //if (oMsg.payload.value === \"Upgraded Audio\") { handlemsg(oMsg) }\n            //if (oMsg.payload.value === \"Upgraded Audio\") {\n              //  node.warn(\"handling title\")\n               // handlemsg(oMsg)\n            //}\n        }\n    }\n}\n","outputs":1,"noerr":0,"x":1100,"y":300,"wires":[[]]},{"id":"2e5b9f2f.80672","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring All Hubitat Controlled Devices","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":230,"y":960,"wires":[["433897b3.6e5228"]]},{"id":"9b6c715d.7d0df","type":"hubitat device","z":"a73af62e.c418b8","name":"Aqara button","server":"55e4481a.722098","deviceId":"356","attribute":"","sendEvent":true,"x":330,"y":100,"wires":[["5cf6a5cd.b96f2c"]]},{"id":"7ec6233c.30bd0c","type":"link out","z":"a73af62e.c418b8","name":"Passthrough to enable subflow","links":["c3d2eb8b.0e8048","65cb4f4d.450a1","804a40fe.1d409"],"x":230,"y":40,"wires":[],"l":true},{"id":"c3d2eb8b.0e8048","type":"link in","z":"a73af62e.c418b8","name":"From Input","links":["7ec6233c.30bd0c"],"x":100,"y":100,"wires":[["9b6c715d.7d0df","cf8e9b11.19c528","18f40ebe.889bd1","49a1b73f.b67818","b237626a.d45a","e1e92c35.1d1fd","6b022c72.4d95c4","23464554.36baaa","5b30cc27.8dd184","2651fd89.0d2442","918f661d.bacfa8","60dbefae.a983f","f8119c1f.d777a","c115715c.9116e"]],"l":true},{"id":"7b80fecb.c058a","type":"influxdb out","z":"a73af62e.c418b8","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1710,"y":80,"wires":[]},{"id":"13c8ec56.33a504","type":"function","z":"a73af62e.c418b8","name":"Format for InfluxDB & MQTT","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node via output 1 which will in turn write to the InfluxDB\n * It also formats an MQTT topic and the data sending that to output 2 which in turn can be used by an MQTT node to send to \n * MQTT\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(deviceID + element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n/* MQTT section \n * \n * \n * \n */\n\n//create the placeholder object\nvar msg2 = {}\n//add the MQTT topic\nmsg2.topic = \"Hubitat/\" + flow.get(\"MQTTDeviceTopic\") + \"/\" + typeOfMeasurement\n//add the data to be recorded to MQTT\nmsg2.payload = theData\n\n\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return [msg, msg2]\n}","outputs":2,"noerr":0,"x":1340,"y":80,"wires":[["377f4ebf.3750b2","7b80fecb.c058a"],["495328dc.7fdd98"]]},{"id":"377f4ebf.3750b2","type":"change","z":"a73af62e.c418b8","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1750,"y":120,"wires":[[]]},{"id":"495328dc.7fdd98","type":"mqtt out","z":"a73af62e.c418b8","name":"Write reading to MQTT","topic":"","qos":"1","retain":"true","broker":"a5bf81ee.27852","x":1320,"y":120,"wires":[]},{"id":"38d4b9eb.7bd596","type":"config","z":"1e603513.011bdb","name":"Game Room Floor Lamp Config","properties":[{"p":"Floor","pt":"flow","to":"2","tot":"str"},{"p":"Location","pt":"flow","to":"Northeast Corner","tot":"str"},{"p":"Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Bulb","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Ikea","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Game Room Floor Lamp","tot":"str"}],"active":true,"x":230,"y":480,"wires":[]},{"id":"26ca9d2e.33c5d2","type":"link out","z":"1e603513.011bdb","name":"Passthrough to enable subflow","links":["8f041522.a579a8"],"x":290,"y":520,"wires":[],"l":true},{"id":"8f041522.a579a8","type":"link in","z":"1e603513.011bdb","name":"From Input","links":["26ca9d2e.33c5d2"],"x":200,"y":600,"wires":[[]],"l":true},{"id":"88a41a43.4ce8f8","type":"link in","z":"1e603513.011bdb","name":"Send to InfluxDB","links":["86095303.ccb5d"],"x":580,"y":480,"wires":[["7dc2f0e7.61bab"]],"l":true},{"id":"86095303.ccb5d","type":"link out","z":"1e603513.011bdb","name":"Gather to Send to InfluxDB","links":["88a41a43.4ce8f8"],"x":880,"y":600,"wires":[],"l":true},{"id":"7dc2f0e7.61bab","type":"function","z":"1e603513.011bdb","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":780,"y":480,"wires":[["8dbf8c.bc891078"]]},{"id":"b891a686.fc5f88","type":"influxdb out","z":"1e603513.011bdb","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1410,"y":420,"wires":[]},{"id":"8dbf8c.bc891078","type":"function","z":"1e603513.011bdb","name":"Format for InfluxDB & MQTT","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node via output 1 which will in turn write to the InfluxDB\n * It also formats an MQTT topic and the data sending that to output 2 which in turn can be used by an MQTT node to send to \n * MQTT\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n/* MQTT section \n * \n * \n * \n */\n\n//create the placeholder object\nvar msg2 = {}\n//add the MQTT topic\nmsg2.topic = \"Hubitat/\" + flow.get(\"MQTTDeviceTopic\") + \"/\" + typeOfMeasurement\n//add the data to be recorded to MQTT\nmsg2.payload = theData\n\n\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return [msg, msg2]\n}","outputs":2,"noerr":0,"x":1040,"y":480,"wires":[["b891a686.fc5f88","5ac581c6.58c4"],["bbe9b3c3.8757c"]]},{"id":"5ac581c6.58c4","type":"change","z":"1e603513.011bdb","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1450,"y":460,"wires":[[]]},{"id":"bbe9b3c3.8757c","type":"mqtt out","z":"1e603513.011bdb","name":"Write reading to MQTT","topic":"","qos":"1","retain":"true","broker":"a5bf81ee.27852","x":1340,"y":500,"wires":[]},{"id":"433897b3.6e5228","type":"subflow:a73af62e.c418b8","z":"54cae49c.6ee04c","name":"","env":[],"x":540,"y":960,"wires":[]},{"id":"cb7f3d05.97917","type":"ui_worldmap","z":"1a0aa13a.9d7b8f","group":"c7810244.5e40a","order":1,"width":"17","height":"14","name":"Common Map","lat":"33.110554","lon":"-96.790415","zoom":"7","layer":"OSM grey","cluster":"","maxage":"","usermenu":"hide","layers":"show","panit":"false","panlock":"false","zoomlock":"false","hiderightclick":"true","coords":"none","showgrid":"false","path":"/worldmapF","x":1680,"y":40,"wires":[]},{"id":"628d4a24.2b1aa4","type":"inject","z":"98a6e865.a02ea8","name":"11 pm Turn Off First Light","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"00 23 * * *","once":false,"onceDelay":0.1,"x":160,"y":180,"wires":[["563a472b.7924e8"]]},{"id":"d4d54bb9.9ec768","type":"inject","z":"98a6e865.a02ea8","name":"11:30 pm Turn Off Second Living Room Light","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"30 23 * * *","once":false,"onceDelay":0.1,"x":220,"y":220,"wires":[["c490e6e5.e0e728"]]},{"id":"563a472b.7924e8","type":"hubitat command","z":"98a6e865.a02ea8","name":"Corner Off","server":"55e4481a.722098","deviceId":"100","command":"off","commandArgs":"","x":370,"y":180,"wires":[[]]},{"id":"c490e6e5.e0e728","type":"hubitat command","z":"98a6e865.a02ea8","name":"Table Lamp Off","server":"55e4481a.722098","deviceId":"225","command":"off","commandArgs":"","x":500,"y":220,"wires":[[]]},{"id":"27d40011.32d0e","type":"inject","z":"98a6e865.a02ea8","name":"7 pm Turn on Bedside Light","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"00 19 * * *","once":false,"onceDelay":0.1,"x":160,"y":260,"wires":[["3c71784d.a38fe8"]]},{"id":"3c71784d.a38fe8","type":"hubitat command","z":"98a6e865.a02ea8","name":"Mike Bedside On","server":"55e4481a.722098","deviceId":"257","command":"on","commandArgs":"","x":390,"y":260,"wires":[[]]},{"id":"8db205c8.4a1268","type":"hubitat device","z":"98a6e865.a02ea8","name":"Master Light Overhead Switch double tapped","server":"55e4481a.722098","deviceId":"33","attribute":"doubleTapped","sendEvent":true,"x":190,"y":120,"wires":[["3128627d.70be9e"]]},{"id":"3128627d.70be9e","type":"hubitat command","z":"98a6e865.a02ea8","name":"Turn on Table Lamp@10%","server":"55e4481a.722098","deviceId":"225","command":"setLevel","commandArgs":"10,0","x":500,"y":120,"wires":[[]]},{"id":"906e2ccd.f427f","type":"sun events","z":"ba901384.9c229","testmode":true,"verbose":true,"topic":"","name":"","x":80,"y":140,"wires":[["8a4d687d.4132c8"]]},{"id":"8a4d687d.4132c8","type":"debug","z":"ba901384.9c229","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":240,"y":140,"wires":[]},{"id":"276d7462.8ad96c","type":"function","z":"5364e86b.44e3a8","name":"Splitting Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//delete the currentValue portion of the object since it is deprecated\ndelete msg.payload.currentValue\n//initial call into the recursive function\nhandlemsg(msg)\n//send nothing from main code\nreturn\n\n/*\n * Main recursive function code\n *\n */\n\nfunction handlemsg(msg) {\n    //The evaluation part of this switch/case statement determines which type of entity is in the value\n    //  the key idea is that once the value is an atomic item (number, string, bool) then the message should be sent out\n    //  of the node to downstream, but if the value is a splittable, then it should be split into multiple messages. These\n    //  messages are then evaulated individually. They in turn are either found to have atomic entries in the value or have\n    //  values that are themselves splittable.\n    //  For example:\n    //  JSON - each key value pair will be used to create a new msg. The msg.payload.name will be changed to add \":\" and the key\n    //          from the key value pair. The msg.payload.value will become the value from the key value pair\n    //  Array - TBAdded\n    //  Object - TBAdded\n    switch (typeofhubitatvalue(msg.payload.value, \"msg.payload.value\")) {\n        case \"number\":\n        case \"bigint\":\n            //numbers are an atomic type of value and should be sent to downstream nodes\n            msg.payload.dataType = \"Number\"\n            //send the version of the msg with an atomic value to downstream nodes\n            node.send(msg)\n            //do nothing more once msg has been sent\n            break;\n        case \"boolean\":\n            //Booleans are an atomic type of value and should be sent to downstream nodes\n            msg.payload.dataType = \"Boolean\"\n            //send the version of the msg with an atomic value to downstream nodes\n            node.send(msg)\n            //do nothing more once msg has been sent\n            break;\n        case \"string\":\n            //Strings are an atomic type of value and should be sent to downstream nodes\n            msg.payload.dataType = \"String\"\n            //send the version of the msg with an atomic value to downstream nodes\n            node.send(msg)\n            //do nothing more once msg has been sent\n            break;\n        case \"unsplittable array\":\n            //This case is where the item is an array, but with only a single entry. The idea is to move that single\n            //  value out of the array and into the value natively and then to call the recursive function to evaluate\n            //  what type of item it now is and then process (split or send or extract) appropriately\n            msg.payload.value = msg.payload.value[0]\n            handlemsg(msg)\n            break;\n        case \"splittable JSON\":\n            //This is for cases where the JSON is in the form of key:value where there is at least 1 pair\n            //  Examples of \"valid\" JSON that would not be coming to this case would be {} or 100\n            splitJSON(msg)\n            break;\n        case \"splittable array\":\n            //This is for cases where the Array is in the form [\"A\",\"B\",\"C\"] where there is are at least 2 members\n            //  SplitArray function not yet built. TBD\n            splitArray(msg)\n            break;\n        case \"unsplittable JSON\":\n            //This is for handling \"valid\" JSON that does not have key:value pairs.\n            //  Examples of \"valid\" JSON that are handed here are {} or 100 or \"100\"\n            //  This case either treats it as a string (no changes made) or a number where a number in\n            //  a string like \"100\" is changed into an actual number like 100\n\n            //by checking if NaN, if it is a number 100 or \"100\", the ++ followed by -- changes it to a number 100\n            //  without changing its actual value\n            if (isNaN(msg.payload.value)) { } else {\n                ++msg.payload.value\n                --msg.payload.value\n             }\n            //Sets the data type for downstream since the incoming message could have been a variety of types\n            //  before JSON, object or array was split\n            msg.payload.dataType = typeof (msg.payload.value)\n            //send the version of the msg with an atomic value to downstream nodes (could probably just recursively call\n            //  handlemsg, but I can't identify a circumstance where that would give a different result to downstream,\n            //  but this would be a place to investigate if downstream results are unexpected.)\n            node.send(msg)\n            break\n        case \"object\":\n            //This is for handling an object. It then calls splitObj to create multiple msgs with the object keys into the names\n            //  and the values from those keys moved into the value of the new object.\n            splitObj(msg)\n            break\n        default:\n            //This is just in case no valid process is found by the typeofhubitatvalue function.\n            //  If you encounter this then you will either need to investigate the function or contact tmichael in\n            //  Hubitat discourse forums https://community.hubitat.com/\n            return\n    }\n}\n\n/*\n * This function is used by the Main recursive function (handlemsg) to decide whether to send the msg on as\n *  the msg.payload.value is atomic or if it needs to split the value into multiple msgs\n *\n */\nfunction typeofhubitatvalue(value, source = \"\") {\n    switch (typeof (value)) {\n        case \"number\":\n            //atomic just return the result of typeof\n            return \"number\"\n            break;\n        case \"bigint\":\n            //atomic just return the result of typeof\n            return \"bigint\"\n            break;\n        case \"boolean\":\n            //atomic just return the result of typeof\n            return \"boolean\"\n            break;\n        case \"string\":\n            //most splittable values are encoded strictly as text and so may be identified as a string\n\n            //Fist check if the string is \"valid\" JSON\n            if (isvalidJSONstring(value)) {\n                //When it is \"valid\" JSON, check if it is splittable\n                if (issplittablevalidJSONstring(value)) {\n                    //When it is splittable, then return type as splittable JSON\n                    return \"splittable JSON\"\n                }\n                else\n                {\n                    //if it is JSON, but not splittable ({}, \"100, 100) return unsplittable JSON\n                    return \"unsplittable JSON\"\n                }\n            }\n            else\n            {\n                //When it isn't \"valid\" JSON, check if it is an array\n                if (isvalidarray(value)) {\n                    //When it is an array, check if it is splittable\n                    if (issplittablearray(value)) {\n                        //When it is splittable, return splittable Array\n                        return \"splittable Array\"\n                    }\n                    else\n                    {\n                        //if the array is not splittable ([\"apple\"]) return unsplittable array\n                        return \"unsplittable array\"\n                    }\n                }\n                else\n                {\n                    //When it is neither JSON or Array, then it is really just a string, so return string\n                    return \"string\"\n                }\n            }\n            break;\n        case \"object\":\n            //some  splittable values are identified as objects\n\n            //Fist check if the object is \"valid\" JSON\n            if (isvalidJSONstring(value)) {\n                //When it is \"valid\" JSON, check if it is splittable\n                if (issplittablevalidJSONstring(value)) {\n                    //When it is splittable, then return type as splittable JSON\n                    return \"splittable JSON\"\n                }\n                else\n                {\n                    //if it is JSON, but not splittable ({}, \"100, 100) return unsplittable JSON\n                    return \"unsplittable JSON\"\n                }\n            }\n            else\n            {\n                //When it isn't \"valid\" JSON, check if it is an array\n                if (isvalidarray(value)) {\n                    //When it is an array, check if it is splittable\n                    if (issplittablearray(value)) {\n                        //When it is splittable, return splittable Array\n                        return \"splittable Array\"\n                    }\n                    else {\n                        //if the array is not splittable ([\"apple\"]) return unsplittable array\n                        return \"unsplittable array\"\n                    }\n                }\n                else\n                {\n                    //When it is neither JSON or Array, then I have not accounted for it. If you reach this point during an\n                    //  investigation, it might be worth using the example that triggered your investigation to see if the object\n                    //  is really just a string (without a triggering example I have not investigated)\n                    return \"object\"\n                }\n            }\n            break;\n        default:\n            //When the type is not one that I coded for then return unhandled because the situation is by definition unhandled\n            return \"unhandled\"\n            break;\n    }\n}\n\n//True False functions\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction isvalidJSONstring(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\n\n/*\n * This function decides where the JSON is made up of at least 1 key:value pair\n */\nfunction issplittablevalidJSONstring(str) {\n    if (str.includes(\":\")) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/*\n * This function is simply wrapping the Array.isArray, to align the function naming with the other true false functions\n */\nfunction isvalidarray(str) {\n    if (Array.isArray(str)) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/*\n * This function identifies if the array has only a single entry or multiple entries i.e. [\"Apple\"] not splittable,\n *  [\"Apple\",\"Pear\"] splittable\n */\nfunction issplittablearray(str) {\n    // If the length is more than 1, then the array has mutliple entries, but if it is just 1, then it is not splittable\n    if (str.length > 1) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n//Splitting functions\n/*\n * This function takes in a msg where msg.payload.value is splittable JSON and iterates through all key:value pairs and then\n *  recursively calls handlemsg with multiple messages. Each new message retains most of the details of the input message, \n *  but the name and value are changed.\n *  The name has the key from the key:value pair appended with a : as a seperator\n *  The value is replaced with the value from the key:value pair\n *  A new message is created for each key:value pair\n */\nfunction splitJSON(latestMsg) {\n    //put the inputs value into a variable for easier access\n    var valueJSON = JSON.parse(latestMsg.payload.value);\n    //put the inputs name aside for multiple reuses\n    var name = latestMsg.payload.name\n    //Iterative loop\n    Object.keys(valueJSON).forEach(function (key) {\n        //concatenate the original name, a colon and the key from the pair\n        latestMsg.payload.name = name + \":\" + key;\n        //move the value from the pair to payload.value\n        latestMsg.payload.value = valueJSON[key];\n        //recursively call this function in case the value is itself splittable\n        handlemsg(latestMsg)\n    }\n    )\n    return\n}\n\n/*\n * This function takes in a msg where msg.payload.value is splittable object\n *  and iterates through all key:value pairs and then\n *  recursively calls handlemsg with multiple messages. Each new message retains most of the details of the input message,\n *  but the name and value are changed.\n *  The name has the key from the key:value pair appended with a : as a seperator\n *  The value is replaced with the value from the key:value pair\n *  A new message is created for each key:value pair\n *  \n *  Note: While working on the splitArray function, I realized that I may not have tested this on an object value with multiple\n *  pairs, so it is possible that the function only handles the first pair\n */\nfunction splitObj(oMsg) {\n    //put the inputs name aside for multiple reuses\n    var name = oMsg.payload.name\n    //Iterative loop\n    for (let [key, value] of Object.entries(oMsg.payload.value)) {\n        if ((value !== null) && (key !== null)) {\n            oMsg.payload.name = name + \":\" + key;\n            oMsg.payload.value = value;\n            //recursively call this function in case the value is itself splittable\n            handlemsg(oMsg)\n        }\n    }\n}\n\n/*\n * Note: At the time of creation, I did not have a live example and had too many other things in the works to construct one.\n * \n * This function takes in a msg where msg.payload.value is splittable array\n *  and iterates through all entries and recursively calls handlemsg with multiple messages. \n *  Each new message retains most of the details of the input message,\n *  but the value is changed.\n *  The value is replaced with the value from the entry in the Array\n *  For example if the input value is [\"Apple\",\"Pear\"], then the first msg will have a value of \"Apple\"\n *  and the second will have a value of \"Pear\"\n */\nfunction splitArray(aMsg) {\n    //Iterative loop\n    for (index = 0; index < aMsg.payload.value.length; index++) {\n        (aMsg.payload.value = aMsg.payload.value[index]);\n        //recursively call this function in case the value is itself splittable\n        handlemsg(aMsg)\n    }\n}","outputs":1,"noerr":0,"x":720,"y":80,"wires":[["31f31813.96f798"]]},{"id":"5fbe337e.5eaf8c","type":"function","z":"a73af62e.c418b8","name":"Splitting Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//delete the currentValue portion of the object since it is deprecated\ndelete msg.payload.currentValue\n//initial call into the recursive function\nhandlemsg(msg)\n//send nothing from main code\nreturn\n\n/*\n * Main recursive function code\n *\n */\n\nfunction handlemsg(msg) {\n    //The evaluation part of this switch/case statement determines which type of entity is in the value\n    //  the key idea is that once the value is an atomic item (number, string, bool) then the message should be sent out\n    //  of the node to downstream, but if the value is a splittable, then it should be split into multiple messages. These\n    //  messages are then evaulated individually. They in turn are either found to have atomic entries in the value or have\n    //  values that are themselves splittable.\n    //  For example:\n    //  JSON - each key value pair will be used to create a new msg. The msg.payload.name will be changed to add \":\" and the key\n    //          from the key value pair. The msg.payload.value will become the value from the key value pair\n    //  Array - TBAdded\n    //  Object - TBAdded\n    switch (typeofhubitatvalue(msg.payload.value, \"msg.payload.value\")) {\n        case \"number\":\n        case \"bigint\":\n            //numbers are an atomic type of value and should be sent to downstream nodes\n            msg.payload.dataType = \"Number\"\n            //send the version of the msg with an atomic value to downstream nodes\n            node.send(msg)\n            //do nothing more once msg has been sent\n            break;\n        case \"boolean\":\n            //Booleans are an atomic type of value and should be sent to downstream nodes\n            msg.payload.dataType = \"Boolean\"\n            //send the version of the msg with an atomic value to downstream nodes\n            node.send(msg)\n            //do nothing more once msg has been sent\n            break;\n        case \"string\":\n            //Strings are an atomic type of value and should be sent to downstream nodes\n            msg.payload.dataType = \"String\"\n            //send the version of the msg with an atomic value to downstream nodes\n            node.send(msg)\n            //do nothing more once msg has been sent\n            break;\n        case \"unsplittable array\":\n            //This case is where the item is an array, but with only a single entry. The idea is to move that single\n            //  value out of the array and into the value natively and then to call the recursive function to evaluate\n            //  what type of item it now is and then process (split or send or extract) appropriately\n            msg.payload.value = msg.payload.value[0]\n            handlemsg(msg)\n            break;\n        case \"splittable JSON\":\n            //This is for cases where the JSON is in the form of key:value where there is at least 1 pair\n            //  Examples of \"valid\" JSON that would not be coming to this case would be {} or 100\n            splitJSON(msg)\n            break;\n        case \"splittable array\":\n            //This is for cases where the Array is in the form [\"A\",\"B\",\"C\"] where there is are at least 2 members\n            //  SplitArray function not yet built. TBD\n            splitArray(msg)\n            break;\n        case \"unsplittable JSON\":\n            //This is for handling \"valid\" JSON that does not have key:value pairs.\n            //  Examples of \"valid\" JSON that are handed here are {} or 100 or \"100\"\n            //  This case either treats it as a string (no changes made) or a number where a number in\n            //  a string like \"100\" is changed into an actual number like 100\n\n            //by checking if NaN, if it is a number 100 or \"100\", the ++ followed by -- changes it to a number 100\n            //  without changing its actual value\n            if (isNaN(msg.payload.value)) { } else {\n                ++msg.payload.value\n                --msg.payload.value\n             }\n            //Sets the data type for downstream since the incoming message could have been a variety of types\n            //  before JSON, object or array was split\n            msg.payload.dataType = typeof (msg.payload.value)\n            //send the version of the msg with an atomic value to downstream nodes (could probably just recursively call\n            //  handlemsg, but I can't identify a circumstance where that would give a different result to downstream,\n            //  but this would be a place to investigate if downstream results are unexpected.)\n            node.send(msg)\n            break\n        case \"object\":\n            //This is for handling an object. It then calls splitObj to create multiple msgs with the object keys into the names\n            //  and the values from those keys moved into the value of the new object.\n            splitObj(msg)\n            break\n        default:\n            //This is just in case no valid process is found by the typeofhubitatvalue function.\n            //  If you encounter this then you will either need to investigate the function or contact tmichael in\n            //  Hubitat discourse forums https://community.hubitat.com/\n            return\n    }\n}\n\n/*\n * This function is used by the Main recursive function (handlemsg) to decide whether to send the msg on as\n *  the msg.payload.value is atomic or if it needs to split the value into multiple msgs\n *\n */\nfunction typeofhubitatvalue(value, source = \"\") {\n    switch (typeof (value)) {\n        case \"number\":\n            //atomic just return the result of typeof\n            return \"number\"\n            break;\n        case \"bigint\":\n            //atomic just return the result of typeof\n            return \"bigint\"\n            break;\n        case \"boolean\":\n            //atomic just return the result of typeof\n            return \"boolean\"\n            break;\n        case \"string\":\n            //most splittable values are encoded strictly as text and so may be identified as a string\n\n            //Fist check if the string is \"valid\" JSON\n            if (isvalidJSONstring(value)) {\n                //When it is \"valid\" JSON, check if it is splittable\n                if (issplittablevalidJSONstring(value)) {\n                    //When it is splittable, then return type as splittable JSON\n                    return \"splittable JSON\"\n                }\n                else\n                {\n                    //if it is JSON, but not splittable ({}, \"100, 100) return unsplittable JSON\n                    return \"unsplittable JSON\"\n                }\n            }\n            else\n            {\n                //When it isn't \"valid\" JSON, check if it is an array\n                if (isvalidarray(value)) {\n                    //When it is an array, check if it is splittable\n                    if (issplittablearray(value)) {\n                        //When it is splittable, return splittable Array\n                        return \"splittable Array\"\n                    }\n                    else\n                    {\n                        //if the array is not splittable ([\"apple\"]) return unsplittable array\n                        return \"unsplittable array\"\n                    }\n                }\n                else\n                {\n                    //When it is neither JSON or Array, then it is really just a string, so return string\n                    return \"string\"\n                }\n            }\n            break;\n        case \"object\":\n            //some  splittable values are identified as objects\n\n            //Fist check if the object is \"valid\" JSON\n            if (isvalidJSONstring(value)) {\n                //When it is \"valid\" JSON, check if it is splittable\n                if (issplittablevalidJSONstring(value)) {\n                    //When it is splittable, then return type as splittable JSON\n                    return \"splittable JSON\"\n                }\n                else\n                {\n                    //if it is JSON, but not splittable ({}, \"100, 100) return unsplittable JSON\n                    return \"unsplittable JSON\"\n                }\n            }\n            else\n            {\n                //When it isn't \"valid\" JSON, check if it is an array\n                if (isvalidarray(value)) {\n                    //When it is an array, check if it is splittable\n                    if (issplittablearray(value)) {\n                        //When it is splittable, return splittable Array\n                        return \"splittable Array\"\n                    }\n                    else {\n                        //if the array is not splittable ([\"apple\"]) return unsplittable array\n                        return \"unsplittable array\"\n                    }\n                }\n                else\n                {\n                    //When it is neither JSON or Array, then I have not accounted for it. If you reach this point during an\n                    //  investigation, it might be worth using the example that triggered your investigation to see if the object\n                    //  is really just a string (without a triggering example I have not investigated)\n                    return \"object\"\n                }\n            }\n            break;\n        default:\n            //When the type is not one that I coded for then return unhandled because the situation is by definition unhandled\n            return \"unhandled\"\n            break;\n    }\n}\n\n//True False functions\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction isvalidJSONstring(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\n\n/*\n * This function decides where the JSON is made up of at least 1 key:value pair\n */\nfunction issplittablevalidJSONstring(str) {\n    if (str.includes(\":\")) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/*\n * This function is simply wrapping the Array.isArray, to align the function naming with the other true false functions\n */\nfunction isvalidarray(str) {\n    if (Array.isArray(str)) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/*\n * This function identifies if the array has only a single entry or multiple entries i.e. [\"Apple\"] not splittable,\n *  [\"Apple\",\"Pear\"] splittable\n */\nfunction issplittablearray(str) {\n    // If the length is more than 1, then the array has mutliple entries, but if it is just 1, then it is not splittable\n    if (str.length > 1) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n//Splitting functions\n/*\n * This function takes in a msg where msg.payload.value is splittable JSON and iterates through all key:value pairs and then\n *  recursively calls handlemsg with multiple messages. Each new message retains most of the details of the input message, \n *  but the name and value are changed.\n *  The name has the key from the key:value pair appended with a : as a seperator\n *  The value is replaced with the value from the key:value pair\n *  A new message is created for each key:value pair\n */\nfunction splitJSON(latestMsg) {\n    //put the inputs value into a variable for easier access\n    var valueJSON = JSON.parse(latestMsg.payload.value);\n    //put the inputs name aside for multiple reuses\n    var name = latestMsg.payload.name\n    //Iterative loop\n    Object.keys(valueJSON).forEach(function (key) {\n        //concatenate the original name, a colon and the key from the pair\n        latestMsg.payload.name = name + \":\" + key;\n        //move the value from the pair to payload.value\n        latestMsg.payload.value = valueJSON[key];\n        //recursively call this function in case the value is itself splittable\n        handlemsg(latestMsg)\n    }\n    )\n    return\n}\n\n/*\n * This function takes in a msg where msg.payload.value is splittable object\n *  and iterates through all key:value pairs and then\n *  recursively calls handlemsg with multiple messages. Each new message retains most of the details of the input message,\n *  but the name and value are changed.\n *  The name has the key from the key:value pair appended with a : as a seperator\n *  The value is replaced with the value from the key:value pair\n *  A new message is created for each key:value pair\n *  \n *  Note: While working on the splitArray function, I realized that I may not have tested this on an object value with multiple\n *  pairs, so it is possible that the function only handles the first pair\n */\nfunction splitObj(oMsg) {\n    //put the inputs name aside for multiple reuses\n    var name = oMsg.payload.name\n    //Iterative loop\n    for (let [key, value] of Object.entries(oMsg.payload.value)) {\n        if ((value !== null) && (key !== null)) {\n            oMsg.payload.name = name + \":\" + key;\n            oMsg.payload.value = value;\n            //recursively call this function in case the value is itself splittable\n            handlemsg(oMsg)\n        }\n    }\n}\n\n/*\n * Note: At the time of creation, I did not have a live example and had too many other things in the works to construct one.\n * \n * This function takes in a msg where msg.payload.value is splittable array\n *  and iterates through all entries and recursively calls handlemsg with multiple messages. \n *  Each new message retains most of the details of the input message,\n *  but the value is changed.\n *  The value is replaced with the value from the entry in the Array\n *  For example if the input value is [\"Apple\",\"Pear\"], then the first msg will have a value of \"Apple\"\n *  and the second will have a value of \"Pear\"\n */\nfunction splitArray(aMsg) {\n    //Iterative loop\n    for (index = 0; index < aMsg.payload.value.length; index++) {\n        (aMsg.payload.value = aMsg.payload.value[index]);\n        //recursively call this function in case the value is itself splittable\n        handlemsg(aMsg)\n    }\n}","outputs":1,"noerr":0,"x":1320,"y":40,"wires":[["13c8ec56.33a504"]]},{"id":"a6558da6.bf7de","type":"function","z":"d866934c.b2cbc","name":"","func":"//send original on output 2\nnode.send([null,msg])\n//interate through the objects in the input\nfor (let [key, value] of Object.entries(msg.payload))\n{    \n    msg.payload = value\n    node.send([msg,null])\n    node.done()\n}\nreturn","outputs":2,"noerr":0,"x":850,"y":420,"wires":[[],["d28a4d7.ba47db","bf442bf8.1b12f8"]]},{"id":"5ca11645.c7ce18","type":"inject","z":"d866934c.b2cbc","name":"Request","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":240,"y":320,"wires":[["907054aa.337dc8"]]},{"id":"907054aa.337dc8","type":"hubitat device","z":"d866934c.b2cbc","name":"Game Room Floor Lamp","server":"55e4481a.722098","deviceId":"357","attribute":"","sendEvent":true,"x":490,"y":320,"wires":[["266587d3.9bffb8"]]},{"id":"bf442bf8.1b12f8","type":"debug","z":"d866934c.b2cbc","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":1110,"y":120,"wires":[]},{"id":"266587d3.9bffb8","type":"function","z":"d866934c.b2cbc","name":"","func":"var singleAttributeData = false\nvar foundType\nfor (let [key, value] of Object.entries(msg.payload)) {\n  foundtype= typeof(value)\n  if ((foundtype==\"string\")||(foundtype==\"number\")||(foundtype==\"boolean\")){\n      singleAttributeData =true\n  }\n}\nif (singleAttributeData){\n    node.send([msg,null])\n} else\n{\n    node.send([null,msg])\n    //interate through the objects in the input\n    for (let [key, value] of Object.entries(msg.payload))\n    {    \n        msg.payload = value\n        node.send([msg,null])\n        node.done()\n        \n    }\n}\nreturn","outputs":2,"noerr":0,"x":1350,"y":340,"wires":[["bf442bf8.1b12f8"],["bf442bf8.1b12f8"]]},{"id":"d28a4d7.ba47db","type":"delay","z":"d866934c.b2cbc","name":"","pauseType":"delay","timeout":"5","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":1040,"y":460,"wires":[[]]},{"id":"ea5d1134.04038","type":"delay","z":"d866934c.b2cbc","name":"","pauseType":"delay","timeout":"5","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":1120,"y":380,"wires":[["266587d3.9bffb8"]]},{"id":"1549ca02.e618b6","type":"function","z":"d866934c.b2cbc","name":"Split 2 types of device node outputs","func":"var singleAttributeData = false\nvar foundType\nfor (let [key, value] of Object.entries(msg.payload)) {\n  foundtype= typeof(value)\n  if ((foundtype==\"string\")||(foundtype==\"number\")||(foundtype==\"boolean\")){\n      singleAttributeData =true\n  }\n}\nif (singleAttributeData){\n    node.send([msg,null])\n} else\n{\n    node.send([null,msg])\n    //interate through the objects in the input\n    for (let [key, value] of Object.entries(msg.payload))\n    {    \n        msg.payload = value\n        node.send([msg,null])\n        node.done()\n        \n    }\n}\nreturn","outputs":2,"noerr":0,"x":820,"y":800,"wires":[["53280e08.1cbe1"],["f79521c7.7b1aa"]]},{"id":"53280e08.1cbe1","type":"function","z":"d866934c.b2cbc","name":"Do things with individual attribute feed","func":"\nreturn msg;","outputs":1,"noerr":0,"x":1156,"y":781,"wires":[[]],"icon":"node-red/alert.svg"},{"id":"f79521c7.7b1aa","type":"function","z":"d866934c.b2cbc","name":"Do things with all attributes feed","func":"\nreturn msg;","outputs":1,"noerr":0,"x":1136,"y":821,"wires":[[]],"icon":"node-red/alert.svg"},{"id":"4cd5578b.b4b0e8","type":"inject","z":"d866934c.b2cbc","name":"Request","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":340,"y":800,"wires":[["128f8ff2.da569"]]},{"id":"128f8ff2.da569","type":"hubitat device","z":"d866934c.b2cbc","name":"Game Room Floor Lamp","server":"55e4481a.722098","deviceId":"357","attribute":"","sendEvent":false,"x":530,"y":800,"wires":[["1549ca02.e618b6"]]},{"id":"dfbd848e.e08f68","type":"hubitat device","z":"d866934c.b2cbc","name":"Game Room Floor Lamp All (wait for events)","server":"55e4481a.722098","deviceId":"357","attribute":"","sendEvent":true,"x":590,"y":580,"wires":[["35ddafff.82f23"]]},{"id":"1f0d6640.70964a","type":"hubitat device","z":"d866934c.b2cbc","name":"Game Room Floor Lamp All (triggerable)","server":"55e4481a.722098","deviceId":"357","attribute":"","sendEvent":false,"x":580,"y":620,"wires":[["af4ae22c.765cf"]]},{"id":"dc932238.6aae8","type":"config","z":"d866934c.b2cbc","name":"Game Room Floor Lamp Config","properties":[{"p":"Floor","pt":"flow","to":"2","tot":"str"},{"p":"Location","pt":"flow","to":"Northeast Corner","tot":"str"},{"p":"Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Bulb","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Ikea","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Game Room Floor Lamp","tot":"str"}],"active":true,"x":570,"y":540,"wires":[]},{"id":"af4ae22c.765cf","type":"link out","z":"d866934c.b2cbc","name":"Gather to Send Multi-Object to InfluxDB","links":["79af2189.fdbfe"],"x":960,"y":620,"wires":[],"l":true},{"id":"35ddafff.82f23","type":"link out","z":"d866934c.b2cbc","name":"Gather to Send Single Object to InfluxDB","links":["9a2698dd.e004f8"],"x":960,"y":580,"wires":[],"l":true},{"id":"bbfe6ae0.388bb8","type":"hubitat device","z":"d866934c.b2cbc","name":"Game Room Floor Lamp All (triggerable and waiting for events)","server":"55e4481a.722098","deviceId":"357","attribute":"","sendEvent":false,"x":650,"y":980,"wires":[["b401d977.ab7b38"]]},{"id":"457a9019.9bf46","type":"config","z":"d866934c.b2cbc","name":"Game Room Floor Lamp Config","properties":[{"p":"Floor","pt":"flow","to":"2","tot":"str"},{"p":"Location","pt":"flow","to":"Northeast Corner","tot":"str"},{"p":"Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Bulb","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Ikea","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"MQTTDeviceTopic","pt":"flow","to":"Game Room Floor Lamp","tot":"str"}],"active":true,"x":590,"y":940,"wires":[]},{"id":"c6abb83c.1c5c88","type":"link out","z":"d866934c.b2cbc","name":"Do stuff with Multi-Attribute Objects","links":[],"x":1380,"y":1020,"wires":[],"l":true},{"id":"27dadd41.577d12","type":"link out","z":"d866934c.b2cbc","name":"Do stuff with Single Attribute Objects","links":[],"x":1390,"y":980,"wires":[],"l":true},{"id":"b401d977.ab7b38","type":"function","z":"d866934c.b2cbc","name":"Split 2 types of device node outputs","func":"var singleAttributeData = false\nvar foundType\nfor (let [key, value] of Object.entries(msg.payload)) {\n  foundtype= typeof(value)\n  if ((foundtype==\"string\")||(foundtype==\"number\")||(foundtype==\"boolean\")){\n      singleAttributeData =true\n  }\n}\nif (singleAttributeData){\n    node.send([msg,null])\n} else\n{\n    node.send([null,msg])\n    //interate through the objects in the input\n    for (let [key, value] of Object.entries(msg.payload))\n    {    \n        msg.payload = value\n        node.send([msg,null])\n        node.done()\n        \n    }\n}\nreturn","outputs":2,"noerr":0,"x":1040,"y":980,"wires":[["27dadd41.577d12"],["c6abb83c.1c5c88"]]},{"id":"b2277769.c20dd8","type":"inject","z":"d866934c.b2cbc","name":"Request","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":340,"y":620,"wires":[["1f0d6640.70964a"]]},{"id":"764cc62b.b63908","type":"inject","z":"d866934c.b2cbc","name":"Request","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":340,"y":980,"wires":[["bbfe6ae0.388bb8"]]},{"id":"9fe681fa.d63","type":"function","z":"a73af62e.c418b8","name":"Split 2 types of device node outputs","func":"var singleAttributeData = false\nvar foundType\nfor (let [key, value] of Object.entries(msg.payload)) {\n  foundtype= typeof(value)\n  if ((foundtype==\"string\")||(foundtype==\"number\")||(foundtype==\"boolean\")){\n      singleAttributeData =true\n  }\n}\nif (singleAttributeData){\n    node.send([msg,null])\n} else\n{\n    node.send([null,msg])\n    //interate through the objects in the input\n    for (let [key, value] of Object.entries(msg.payload))\n    {    \n        msg.payload = value\n        node.send([msg,null])\n        node.done()\n        \n    }\n}\nreturn","outputs":2,"noerr":0,"x":1040,"y":40,"wires":[["5fbe337e.5eaf8c"],[]]},{"id":"79af2189.fdbfe","type":"link in","z":"a73af62e.c418b8","name":"Send to InfluxDB, MQTT","links":["5cf6a5cd.b96f2c","5f3cfdbe.fa5cd4","9b2f3d79.c657a","1d6d8c5.03a1d74"],"x":710,"y":40,"wires":[["9fe681fa.d63"]],"l":true},{"id":"5cf6a5cd.b96f2c","type":"link out","z":"a73af62e.c418b8","name":"Gather to Send to InfluxDB, MQTT","links":["79af2189.fdbfe"],"x":700,"y":100,"wires":[],"l":true},{"id":"cf8e9b11.19c528","type":"hubitat device","z":"a73af62e.c418b8","name":"Corner","server":"55e4481a.722098","deviceId":"100","attribute":"","sendEvent":true,"x":310,"y":140,"wires":[["5cf6a5cd.b96f2c"]]},{"id":"18f40ebe.889bd1","type":"hubitat device","z":"a73af62e.c418b8","name":"Cube 1","server":"55e4481a.722098","deviceId":"360","attribute":"","sendEvent":true,"x":320,"y":180,"wires":[["5cf6a5cd.b96f2c"]]},{"id":"49a1b73f.b67818","type":"hubitat device","z":"a73af62e.c418b8","name":"Downstairs Thermostat","server":"55e4481a.722098","deviceId":"161","attribute":"","sendEvent":true,"x":370,"y":220,"wires":[["5cf6a5cd.b96f2c"]]},{"id":"b237626a.d45a","type":"hubitat device","z":"a73af62e.c418b8","name":"Echo - Office","server":"55e4481a.722098","deviceId":"321","attribute":"","sendEvent":true,"x":330,"y":260,"wires":[["5f3cfdbe.fa5cd4"]]},{"id":"e1e92c35.1d1fd","type":"hubitat device","z":"a73af62e.c418b8","name":"Game Room Floor Lamp","server":"55e4481a.722098","deviceId":"357","attribute":"","sendEvent":true,"x":370,"y":300,"wires":[["5f3cfdbe.fa5cd4"]]},{"id":"6b022c72.4d95c4","type":"hubitat device","z":"a73af62e.c418b8","name":"Master Fan","server":"55e4481a.722098","deviceId":"65","attribute":"","sendEvent":true,"x":330,"y":340,"wires":[["9b2f3d79.c657a"]]},{"id":"23464554.36baaa","type":"hubitat device","z":"a73af62e.c418b8","name":"Master Light Overhead","server":"55e4481a.722098","deviceId":"33","attribute":"","sendEvent":true,"x":360,"y":380,"wires":[["9b2f3d79.c657a"]]},{"id":"5b30cc27.8dd184","type":"hubitat device","z":"a73af62e.c418b8","name":"Mike Bedside","server":"55e4481a.722098","deviceId":"257","attribute":"","sendEvent":true,"x":340,"y":420,"wires":[["9b2f3d79.c657a"]]},{"id":"2651fd89.0d2442","type":"hubitat device","z":"a73af62e.c418b8","name":"Mike Credenza Light","server":"55e4481a.722098","deviceId":"388","attribute":"","sendEvent":true,"x":360,"y":460,"wires":[["9b2f3d79.c657a"]]},{"id":"918f661d.bacfa8","type":"hubitat device","z":"a73af62e.c418b8","name":"Mike's Ipad","server":"55e4481a.722098","deviceId":"129","attribute":"","sendEvent":true,"x":330,"y":500,"wires":[["1d6d8c5.03a1d74"]]},{"id":"60dbefae.a983f","type":"hubitat device","z":"a73af62e.c418b8","name":"Office Desk Lamp","server":"55e4481a.722098","deviceId":"550","attribute":"","sendEvent":true,"x":350,"y":540,"wires":[["1d6d8c5.03a1d74"]]},{"id":"f8119c1f.d777a","type":"hubitat device","z":"a73af62e.c418b8","name":"Table Lamp","server":"55e4481a.722098","deviceId":"225","attribute":"","sendEvent":true,"x":330,"y":580,"wires":[["1d6d8c5.03a1d74"]]},{"id":"c115715c.9116e","type":"hubitat device","z":"a73af62e.c418b8","name":"Watch Uverse","server":"55e4481a.722098","deviceId":"262","attribute":"","sendEvent":true,"x":340,"y":620,"wires":[["1d6d8c5.03a1d74"]]},{"id":"5f3cfdbe.fa5cd4","type":"link out","z":"a73af62e.c418b8","name":"Gather to Send to InfluxDB, MQTT","links":["79af2189.fdbfe"],"x":700,"y":260,"wires":[],"l":true},{"id":"9b2f3d79.c657a","type":"link out","z":"a73af62e.c418b8","name":"Gather to Send to InfluxDB, MQTT","links":["79af2189.fdbfe"],"x":700,"y":340,"wires":[],"l":true},{"id":"1d6d8c5.03a1d74","type":"link out","z":"a73af62e.c418b8","name":"Gather to Send to InfluxDB, MQTT","links":["79af2189.fdbfe"],"x":700,"y":540,"wires":[],"l":true},{"id":"be4b942b.9bcd08","type":"config","z":"a73af62e.c418b8","name":"357 Game Room Floor Lamp Config","properties":[{"p":"357Floor","pt":"flow","to":"2","tot":"str"},{"p":"357Location","pt":"flow","to":"Northeast Corner","tot":"str"},{"p":"357Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"357DeviceType","pt":"flow","to":"Bulb","tot":"str"},{"p":"357Manufacturer","pt":"flow","to":"Ikea","tot":"str"},{"p":"357AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"357PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"357PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"357House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"357MQTTDeviceTopic","pt":"flow","to":"Game Room Floor Lamp","tot":"str"}],"active":true,"x":1050,"y":300,"wires":[]},{"id":"5f674567.0f7cac","type":"config","z":"a73af62e.c418b8","name":"356 Aqara Button Config","properties":[{"p":"356Floor","pt":"flow","to":"1","tot":"str"},{"p":"356Location","pt":"flow","to":"Mike Bedside","tot":"str"},{"p":"356Room","pt":"flow","to":"Maste rBedroom","tot":"str"},{"p":"356DeviceType","pt":"flow","to":"Button","tot":"str"},{"p":"356Manufacturer","pt":"flow","to":"Aqara","tot":"str"},{"p":"356AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"356PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"356PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"356House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"356MQTTDeviceTopic","pt":"flow","to":"Aqara button","tot":"str"}],"active":true,"x":1010,"y":100,"wires":[]},{"id":"5e417522.eca8dc","type":"config","z":"a73af62e.c418b8","name":"100 Corner Lamp IKEA Switch Config","properties":[{"p":"100Floor","pt":"flow","to":"1","tot":"str"},{"p":"100Location","pt":"flow","to":"Northeast Corner","tot":"str"},{"p":"100Room","pt":"flow","to":"Living Room","tot":"str"},{"p":"100DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"100Manufacturer","pt":"flow","to":"IKEA","tot":"str"},{"p":"100AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"100PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"100PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"100House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"100MQTTDeviceTopic","pt":"flow","to":"Corner Light","tot":"str"}],"active":true,"x":1050,"y":140,"wires":[]},{"id":"19119e30.02ebd2","type":"config","z":"a73af62e.c418b8","name":"360 Cube 1 Config","properties":[{"p":"360Floor","pt":"flow","to":"2","tot":"str"},{"p":"360Location","pt":"flow","to":"Mike's Desk","tot":"str"},{"p":"360Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"360DeviceType","pt":"flow","to":"Cube","tot":"str"},{"p":"360Manufacturer","pt":"flow","to":"Aqara","tot":"str"},{"p":"360AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"360PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"360PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"360House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"360MQTTDeviceTopic","pt":"flow","to":"Cube 1","tot":"str"}],"active":true,"x":990,"y":180,"wires":[]},{"id":"18e80edf.fadfd1","type":"link out","z":"27566e75.091d22","name":"Do stuff with Multi-Attribute Objects","links":[],"x":820,"y":200,"wires":[],"l":true},{"id":"22cbbbf2.21e404","type":"link out","z":"27566e75.091d22","name":"Do stuff with Single Attribute Objects","links":[],"x":830,"y":160,"wires":[],"l":true},{"id":"719c2698.0d8118","type":"function","z":"27566e75.091d22","name":"Split 2 types of device node outputs","func":"var singleAttributeData = false\nvar foundType\nfor (let [key, value] of Object.entries(msg.payload)) {\n  foundtype= typeof(value)\n  if ((foundtype==\"string\")||(foundtype==\"number\")||(foundtype==\"boolean\")){\n      singleAttributeData =true\n  }\n}\nif (singleAttributeData){\n    node.send([msg,null])\n} else\n{\n    node.send([null,msg])\n    //interate through the objects in the input\n    for (let [key, value] of Object.entries(msg.payload))\n    {    \n        msg.payload = value\n        node.send([msg,null])\n        node.done()\n        \n    }\n}\nreturn","outputs":2,"noerr":0,"x":480,"y":160,"wires":[["22cbbbf2.21e404"],["18e80edf.fadfd1"]]},{"id":"65749fae.88073","type":"link in","z":"27566e75.091d22","name":"Get Input from Device Node","links":[],"x":180,"y":160,"wires":[["719c2698.0d8118"]],"l":true},{"id":"3b172f63.1e809","type":"link out","z":"27566e75.091d22","name":"Do stuff with Multi-Attribute Objects","links":[],"x":840,"y":480,"wires":[],"l":true},{"id":"c4c45e10.930ed","type":"link out","z":"27566e75.091d22","name":"Do stuff with Single Attribute Objects","links":[],"x":850,"y":440,"wires":[],"l":true},{"id":"20c34dbe.ffc2d2","type":"function","z":"27566e75.091d22","name":"Split 2 types of device node outputs","func":"var singleAttributeData = false\nvar foundType\nfor (let [key, value] of Object.entries(msg.payload)) {\n foundtype= typeof(value)\n if ((foundtype==\"string\")||(foundtype==\"number\")||(foundtype==\"boolean\")){\n singleAttributeData =true\n }\n}\nif (singleAttributeData){\n node.send([msg,null])\n} else\n{\n node.send([null,msg])\n //interate through the objects in the input\n for (let [key, value] of Object.entries(msg.payload))\n { \n msg.payload = value\n node.send([msg,null])\n node.done()\n \n }\n}\nreturn","outputs":2,"noerr":0,"x":500,"y":440,"wires":[["c4c45e10.930ed"],["3b172f63.1e809"]]},{"id":"175dcbe7.9df6b4","type":"link in","z":"27566e75.091d22","name":"Get Input from Device Node","links":[],"x":200,"y":440,"wires":[["20c34dbe.ffc2d2"]],"l":true},{"id":"7f51d1c4.17391","type":"config","z":"a73af62e.c418b8","name":"161 Lennox Thermostat Config","properties":[{"p":"161Floor","pt":"flow","to":"1","tot":"str"},{"p":"161Location","pt":"flow","to":"Narrow Hall","tot":"str"},{"p":"161Room","pt":"flow","to":"","tot":"str"},{"p":"161DeviceType","pt":"flow","to":"Thermostat","tot":"str"},{"p":"161Manufacturer","pt":"flow","to":"Lennox","tot":"str"},{"p":"161AccessProtocol","pt":"flow","to":"WiFi","tot":"str"},{"p":"161PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"161PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"161MQTTDeviceTopic","pt":"flow","to":"Lennox Thermostat","tot":"str"}],"active":true,"x":1030,"y":220,"wires":[]},{"id":"866270d7.044cb","type":"config","z":"a73af62e.c418b8","name":"321 Office Echo Config","properties":[{"p":"321Floor","pt":"flow","to":"2","tot":"str"},{"p":"321Location","pt":"flow","to":"Mike's Desk","tot":"str"},{"p":"321Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"321DeviceType","pt":"flow","to":"Echo","tot":"str"},{"p":"321Manufacturer","pt":"flow","to":"Amazon","tot":"str"},{"p":"321AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"321PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"321PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"321House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"321MQTTDeviceTopic","pt":"flow","to":"Office Echo","tot":"str"}],"active":true,"x":1010,"y":260,"wires":[]},{"id":"f81312e7.2608b","type":"config","z":"a73af62e.c418b8","name":"65 Master Fan Config","properties":[{"p":"65Floor","pt":"flow","to":"1","tot":"str"},{"p":"65Location","pt":"flow","to":"North","tot":"str"},{"p":"65Room","pt":"flow","to":"Master Bedroom","tot":"str"},{"p":"65DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"65Manufacturer","pt":"flow","to":"GE/Jasco","tot":"str"},{"p":"65AccessProtocol","pt":"flow","to":"Z-Wave","tot":"str"},{"p":"65PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"65PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"65House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"65MQTTDeviceTopic","pt":"flow","to":"Master Fan","tot":"str"}],"active":true,"x":1000,"y":340,"wires":[]},{"id":"e33c573c.c232f8","type":"config","z":"a73af62e.c418b8","name":"33 Master Light Config","properties":[{"p":"33Floor","pt":"flow","to":"1","tot":"str"},{"p":"33Location","pt":"flow","to":"North","tot":"str"},{"p":"33Room","pt":"flow","to":"Master Bedroom","tot":"str"},{"p":"33DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"33Manufacturer","pt":"flow","to":"GE/Jasco","tot":"str"},{"p":"33AccessProtocol","pt":"flow","to":"Z-Wave","tot":"str"},{"p":"33PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"33PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"33House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"33MQTTDeviceTopic","pt":"flow","to":"Master Overhead Light","tot":"str"}],"active":true,"x":1000,"y":380,"wires":[]},{"id":"f4206f1a.b8e7b","type":"config","z":"a73af62e.c418b8","name":"257 Mike Bedside Config","properties":[{"p":"257Floor","pt":"flow","to":"1","tot":"str"},{"p":"257Location","pt":"flow","to":"Southeast Corner","tot":"str"},{"p":"257Room","pt":"flow","to":"Master Bedroom","tot":"str"},{"p":"257DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"257Manufacturer","pt":"flow","to":"Wemo","tot":"str"},{"p":"257AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"257PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"257PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"257House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"257MQTTDeviceTopic","pt":"flow","to":"Mike's Bedside Light","tot":"str"}],"active":true,"x":1010,"y":420,"wires":[]},{"id":"cc12bf55.bf86c","type":"config","z":"a73af62e.c418b8","name":"388 Mike Credenza Light Config","properties":[{"p":"388Floor","pt":"flow","to":"2","tot":"str"},{"p":"388Location","pt":"flow","to":"Mike's Desk","tot":"str"},{"p":"388Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"388DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"388Manufacturer","pt":"flow","to":"IKEA","tot":"str"},{"p":"388AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"388PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"388PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"388House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"388MQTTDeviceTopic","pt":"flow","to":"Mike's Credenza Light","tot":"str"}],"active":true,"x":1030,"y":460,"wires":[]},{"id":"4d415bf0.1cb284","type":"config","z":"a73af62e.c418b8","name":"129 Mike iPad Config","properties":[{"p":"129Floor","pt":"flow","to":"","tot":"str"},{"p":"129Location","pt":"flow","to":"","tot":"str"},{"p":"129Room","pt":"flow","to":"","tot":"str"},{"p":"129DeviceType","pt":"flow","to":"Tablet","tot":"str"},{"p":"129Manufacturer","pt":"flow","to":"Apple","tot":"str"},{"p":"129AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"129PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"129PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"129House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"129MQTTDeviceTopic","pt":"flow","to":"Mike's iPad","tot":"str"}],"active":true,"x":1000,"y":500,"wires":[]},{"id":"d1089d9c.8a2fa","type":"config","z":"a73af62e.c418b8","name":"550 Ofice Desk Lamp Config","properties":[{"p":"550Floor","pt":"flow","to":"2","tot":"str"},{"p":"550Location","pt":"flow","to":"Mike's Desk","tot":"str"},{"p":"550Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"550DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"550Manufacturer","pt":"flow","to":"IKEA","tot":"str"},{"p":"550AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"550PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"550PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"550House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"550MQTTDeviceTopic","pt":"flow","to":"Mike's Credenza Light","tot":"str"}],"active":true,"x":1020,"y":540,"wires":[]},{"id":"12d11f92.746c3","type":"config","z":"a73af62e.c418b8","name":"225 Table Lamp Config","properties":[{"p":"225Floor","pt":"flow","to":"1","tot":"str"},{"p":"225Location","pt":"flow","to":"North Side","tot":"str"},{"p":"225Room","pt":"flow","to":"Living Room","tot":"str"},{"p":"225DeviceType","pt":"flow","to":"Bulb","tot":"str"},{"p":"225Manufacturer","pt":"flow","to":"TP-Link","tot":"str"},{"p":"225AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"225PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"225PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"225House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"225MQTTDeviceTopic","pt":"flow","to":"Table Lamp","tot":"str"}],"active":true,"x":1010,"y":580,"wires":[]},{"id":"5091e13d.3b68b","type":"config","z":"a73af62e.c418b8","name":"262 Mike Watch Uverse","properties":[{"p":"262Floor","pt":"flow","to":"1","tot":"str"},{"p":"262Location","pt":"flow","to":"TV Cabinet","tot":"str"},{"p":"262Room","pt":"flow","to":"Living Room","tot":"str"},{"p":"262DeviceType","pt":"flow","to":"Harmony Activity","tot":"str"},{"p":"262Manufacturer","pt":"flow","to":"Logitech","tot":"str"},{"p":"262AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"262PhysicalVirtualType","pt":"flow","to":"Virtual","tot":"str"},{"p":"262PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"262House","pt":"flow","to":"Ashmont","tot":"str"},{"p":"262MQTTDeviceTopic","pt":"flow","to":"Watch Uverse","tot":"str"}],"active":true,"x":1010,"y":620,"wires":[]}]