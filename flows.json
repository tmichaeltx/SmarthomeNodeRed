[{"id":"2b2a4010.a6b5e","type":"tab","label":"Triggerable Flows","disabled":false,"info":""},{"id":"54cae49c.6ee04c","type":"tab","label":"Recurring Flow Triggers","disabled":false,"info":""},{"id":"98a6e865.a02ea8","type":"tab","label":"Automation Flows","disabled":false,"info":""},{"id":"ba901384.9c229","type":"tab","label":"Flow 1","disabled":false,"info":""},{"id":"1a0aa13a.9d7b8f","type":"tab","label":"Fake Radar","disabled":false,"info":""},{"id":"65feaf2a.1fb8f","type":"tab","label":"Flow 2","disabled":false,"info":""},{"id":"db3a486d.c20478","type":"subflow","name":"Dimmer Settings","info":"","category":"","in":[{"x":400,"y":80,"wires":[{"id":"f2650446.2a56d8"}]}],"out":[{"x":620,"y":80,"wires":[{"id":"f2650446.2a56d8","port":0}]}],"env":[{"name":"Step","type":"num","value":"30"}],"color":"#3FADB5","icon":"node-red/cog.svg"},{"id":"250ecbce.340264","type":"subflow","name":"Read Spreadsheet For Details","info":"","category":"","in":[{"x":40,"y":20,"wires":[{"id":"7115886d.01af18"}]}],"out":[{"x":960,"y":60,"wires":[{"id":"33cf6aac.eabb16","port":0}]},{"x":960,"y":140,"wires":[{"id":"d91779c2.896ea8","port":0}]},{"x":960,"y":220,"wires":[{"id":"46c25d0f.563a44","port":0}]},{"x":960,"y":300,"wires":[{"id":"893d102e.47b92","port":0}]},{"x":960,"y":380,"wires":[{"id":"c62b3213.e206a","port":0}]},{"x":960,"y":460,"wires":[{"id":"c9c7210d.d881f","port":0}]},{"x":960,"y":540,"wires":[{"id":"9cabee41.a056b","port":0}]},{"x":960,"y":620,"wires":[{"id":"be5dfe12.c99f2","port":0}]}],"env":[{"name":"Spreadsheet ID","type":"str","value":"","ui":{"icon":"font-awesome/fa-file-excel-o","type":"input","opts":{"types":["str"]}}},{"name":"TabName","type":"str","value":"","ui":{"icon":"font-awesome/fa-table","label":{"en-US":"Tab"},"type":"input","opts":{"types":["str"]}}},{"name":"ColStart","type":"str","value":"A","ui":{"icon":"font-awesome/fa-columns","type":"input","opts":{"types":["str"]}}},{"name":"ColEnd","type":"str","value":"Z","ui":{"icon":"font-awesome/fa-columns","type":"input","opts":{"types":["str"]}}},{"name":"MinRow","type":"num","value":"1","ui":{"icon":"font-awesome/fa-window-minimize","type":"input","opts":{"types":["num"]}}},{"name":"MaxRow","type":"num","value":"1000","ui":{"icon":"font-awesome/fa-window-maximize","type":"input","opts":{"types":["num"]}}},{"name":"OverrideEnvVariables","type":"bool","value":"false"}],"color":"#0cad0c","outputLabels":["Error","Last Populated Row","First Empty Row","Last Populated Column","First Empty Column","Spreadsheet Array","Full Data","Full Data with Inputs"],"icon":"font-awesome/fa-file-excel-o"},{"id":"711cdb94.5b9a04","type":"subflow","name":"Decide Quality of Ping","info":"","category":"Abandoned Subflows","in":[{"x":40,"y":100,"wires":[{"id":"5117f3ab.9484cc"}]}],"out":[],"env":[],"color":"#FDF0C2"},{"id":"76e3605b.0e6e7","type":"subflow","name":"Process Ping Results To Local Files","info":"","category":"","in":[{"x":20,"y":140,"wires":[{"id":"7c6b7df4.a02714"}]}],"out":[],"env":[],"color":"#0cad0c"},{"id":"aba876af.3a45e8","type":"subflow","name":"Ping, Write Down to Google and send Result to Process Ping Results","info":"","category":"","in":[{"x":20,"y":100,"wires":[{"id":"81b5485a.3abc58"}]}],"out":[],"env":[],"color":"#C7E9C0","status":{"x":1220,"y":520,"wires":[{"id":"ffcbe690.d32758","port":0}]}},{"id":"c3686304.f6d31","type":"subflow","name":"Backup all 4 Hubitats using Bash Script","info":"","category":"","in":[{"x":60,"y":80,"wires":[{"id":"dae3700e.3752"}]}],"out":[],"env":[],"color":"#0cad0c"},{"id":"b2524cfd.8c346","type":"subflow","name":"Monitor Lennox Thermotat","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"f902dc8c.c0f5"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1500,"y":120,"wires":[{"id":"c72595c7.770458","port":0}]}},{"id":"1e603513.011bdb","type":"subflow","name":"Monitor Game Room Floor Lamp","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"3ddaf972.6b39b6"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1520,"y":80,"wires":[{"id":"3ac0f3fc.89a54c","port":0}]}},{"id":"89f52889.bf1478","type":"subflow","name":"Monitor Aqara Button","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":60,"y":80,"wires":[{"id":"6ccdb89c.8350f8"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1500,"y":80,"wires":[{"id":"653bc46e.2d853c","port":0}]}},{"id":"4e2f0c22.b816c4","type":"subflow","name":"Monitor Corner Light","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":20,"y":80,"wires":[{"id":"427dc421.8d781c"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1460,"y":80,"wires":[{"id":"f161e413.59a918","port":0}]}},{"id":"5364e86b.44e3a8","type":"subflow","name":"Montitor Office Echo","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"c2484670.ff6178"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1480,"y":80,"wires":[{"id":"8bb600f1.44256","port":0}]}},{"id":"ae851807.40c0e8","type":"subflow","name":"Monitor Mike's Bedside Lamp","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"c7c61ee1.9dfe9"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1480,"y":80,"wires":[{"id":"190b5fc0.438e","port":0}]}},{"id":"92d72719.56bd38","type":"subflow","name":"Monitor Mike's Credenza Light","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"8bb21bf9.9058f8"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1460,"y":80,"wires":[{"id":"cf90206.f18cae","port":0}]}},{"id":"fd34e084.87e19","type":"subflow","name":"Monitor Table Lamp","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"c4868b86.653628"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1460,"y":80,"wires":[{"id":"2c849688.b10c4a","port":0}]}},{"id":"e58eb536.40cf18","type":"subflow","name":"Monitor Mike's iPad","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"e52e72d9.77dbd"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1460,"y":80,"wires":[{"id":"7f324c1.08e51b4","port":0}]}},{"id":"390b8414.317d5c","type":"subflow","name":"Monitor Watch Uverse","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"85febe11.1b0c4"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1460,"y":80,"wires":[{"id":"e41ff176.5dc96","port":0}]}},{"id":"9d03767a.9b0288","type":"subflow","name":"Monitor Master Fan","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"2cf48409.d5206c"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1460,"y":80,"wires":[{"id":"ab3cb55f.3b66e8","port":0}]}},{"id":"f6aca0d2.59336","type":"subflow","name":"Monitor Light Overhead","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"5170d88d.798268"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1460,"y":80,"wires":[{"id":"faada734.3761a8","port":0}]}},{"id":"d2615560.b868a8","type":"subflow","name":"Monitor Cube 1","info":"","category":"Mike Monitoring Subflows 4-17","in":[{"x":40,"y":80,"wires":[{"id":"bec0b04e.e9c99"}]}],"out":[],"env":[],"color":"#0cad0c","icon":"node-red-contrib-hubitat/device.png","status":{"x":1460,"y":80,"wires":[{"id":"d559f199.3d317","port":0}]}},{"id":"bb5b26fe.1fc278","type":"gauth","z":""},{"id":"2f23f49.924a10c","type":"ui_base","theme":{"name":"theme-light","lightTheme":{"default":"#0094CE","baseColor":"#0094CE","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif","edited":true,"reset":false},"darkTheme":{"default":"#097479","baseColor":"#097479","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif","edited":false},"customTheme":{"name":"Untitled Theme 1","default":"#4B7930","baseColor":"#4B7930","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"},"themeState":{"base-color":{"default":"#0094CE","value":"#0094CE","edited":false},"page-titlebar-backgroundColor":{"value":"#0094CE","edited":false},"page-backgroundColor":{"value":"#fafafa","edited":false},"page-sidebar-backgroundColor":{"value":"#ffffff","edited":false},"group-textColor":{"value":"#1bbfff","edited":false},"group-borderColor":{"value":"#ffffff","edited":false},"group-backgroundColor":{"value":"#ffffff","edited":false},"widget-textColor":{"value":"#111111","edited":false},"widget-backgroundColor":{"value":"#0094ce","edited":false},"widget-borderColor":{"value":"#ffffff","edited":false},"base-font":{"value":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"}},"angularTheme":{"primary":"indigo","accents":"blue","warn":"red","background":"grey"}},"site":{"name":"Mike's Production Node-RED Dashboard","hideToolbar":"false","allowSwipe":"false","lockMenu":"true","allowTempTheme":"true","dateFormat":"DD/MM/YYYY","sizes":{"sx":48,"sy":48,"gx":6,"gy":6,"cx":6,"cy":6,"px":0,"py":0}}},{"id":"3ce7ceed.69be02","type":"homekit-bridge","z":"","bridgeName":"Mike","pinCode":"121-01-707","port":"","allowInsecureRequest":false,"manufacturer":"TMS Industries","model":"1","serialNo":"1","customMdnsConfig":false,"mdnsMulticast":true,"mdnsInterface":"","mdnsPort":"","mdnsIp":"","mdnsTtl":"","mdnsLoopback":true,"mdnsReuseAddr":true,"allowMessagePassthrough":true},{"id":"a5bf81ee.27852","type":"mqtt-broker","z":"","name":"MQTT Docker","broker":"192.168.86.3","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"d417815c.8097e","type":"hb-conf","z":"","username":"121-01-707"},{"id":"adb4e9b8.8beee8","type":"gauth","z":""},{"id":"430b7850.44c1a8","type":"influxdb","z":"","hostname":"127.0.0.1","port":"8086","protocol":"http","database":"MikeTestFromNR","name":"","usetls":false,"tls":""},{"id":"55e4481a.722098","type":"hubitat config","z":"","name":"Main Hub (110) Maker Production Node Red","usetls":false,"host":"192.168.86.110","port":"80","token":"79eb990f-05f6-4f92-b9ee-ff39db572caf","appId":"646","nodeRedServer":"http://192.168.86.3:1980","webhookPath":"/hubitat/prodwebhook"},{"id":"b862b36a.1a11d","type":"influxdb","z":"","hostname":"127.0.0.1","port":"8086","protocol":"http","database":"MikeTestFromNR","name":"","usetls":false,"tls":""},{"id":"91b3c821.2ebac8","type":"ui_group","z":"","name":"Airport Filters","tab":"f5e0aa39.8a3c98","order":3,"disp":true,"width":"6","collapse":false},{"id":"ba5b6aec.cfc938","type":"ui_group","z":"","name":"Type Filters","tab":"f5e0aa39.8a3c98","order":4,"disp":true,"width":"6","collapse":false},{"id":"537bbaf1.d2a004","type":"ui_group","z":"","name":"Map","tab":"f5e0aa39.8a3c98","order":2,"disp":true,"width":"22","collapse":true},{"id":"18f340fe.a70a3f","type":"ui_group","z":"","name":"Control","tab":"429e5ab.771c5a4","order":1,"disp":false,"width":"22","collapse":false},{"id":"161deef2.b22fa1","type":"ui_group","z":"","name":"Airport Filters","tab":"d5ea0f3.4753bf","order":3,"disp":true,"width":"6","collapse":false},{"id":"8d055308.4aefa","type":"ui_group","z":"","name":"Type Filters","tab":"d5ea0f3.4753bf","order":5,"disp":true,"width":"6","collapse":false},{"id":"f97190c4.d94fa","type":"ui_group","z":"","name":"Map","tab":"d5ea0f3.4753bf","order":2,"disp":true,"width":"22","collapse":true},{"id":"8abf2e02.5fe9f","type":"ui_group","name":"Group 5","tab":"d5ea0f3.4753bf","order":4,"disp":true,"width":6},{"id":"60c16cd3.e9d974","type":"ui_spacer","name":"spacer","group":"8abf2e02.5fe9f","order":2,"width":1,"height":1},{"id":"9e60bee8.9eb17","type":"ui_spacer","name":"spacer","group":"8abf2e02.5fe9f","order":3,"width":1,"height":1},{"id":"7f5ac49d.bd200c","type":"ui_group","z":"","name":"Control","tab":"147827a2.86a988","order":1,"disp":true,"width":"18","collapse":false},{"id":"c2d8a8cd.1a9ef8","type":"ui_group","z":"","name":"Airport Filters","tab":"147827a2.86a988","order":3,"disp":true,"width":"6","collapse":false},{"id":"35024911.cbf516","type":"ui_group","z":"","name":"Type Filters","tab":"147827a2.86a988","order":4,"disp":true,"width":"6","collapse":false},{"id":"f1b79c0c.e854c","type":"ui_group","z":"","name":"Map","tab":"147827a2.86a988","order":2,"disp":true,"width":"22","collapse":true},{"id":"429e5ab.771c5a4","type":"ui_tab","z":"","name":"Radar","icon":"dashboard","order":1,"disabled":false,"hidden":false},{"id":"5c8719a8.e00b38","type":"ui_group","z":"","name":"Log Live2","tab":"b581c9bb.635e68","order":2,"disp":true,"width":"12"},{"id":"625e26f6.7a51b8","type":"ui_group","z":"","name":"Control","tab":"e11725b6.8eeeb8","order":1,"disp":true,"width":"18","collapse":false},{"id":"4baf1468.abb01c","type":"ui_group","z":"","name":"Airport Filters","tab":"429e5ab.771c5a4","order":4,"disp":true,"width":"6","collapse":true},{"id":"6de52288.ba24bc","type":"ui_group","z":"","name":"Type Filters","tab":"e11725b6.8eeeb8","order":4,"disp":true,"width":"6","collapse":false},{"id":"641a9e85.3d5c","type":"ui_group","z":"","name":"Map","tab":"e11725b6.8eeeb8","order":2,"disp":true,"width":"22","collapse":true},{"id":"9cbb54f5.392db8","type":"ui_group","z":"","name":"Aircraft Filters","tab":"429e5ab.771c5a4","order":5,"disp":true,"width":"6","collapse":true},{"id":"c7810244.5e40a","type":"ui_group","z":"","name":"Map","tab":"429e5ab.771c5a4","order":2,"disp":false,"width":"17","collapse":false},{"id":"33707b81.b256d4","type":"ui_group","name":"Group 1","tab":"","order":1,"disp":true,"width":6},{"id":"672eda7d.54f084","type":"ui_group","name":"Group 1","tab":"","order":1,"disp":true,"width":6},{"id":"5308a4eb.b73f2c","type":"ui_group","name":"Group 1","tab":"","order":1,"disp":true,"width":6},{"id":"a68c0105.e9c7e","type":"ui_tab","z":"","name":"Table Holder","icon":"dashboard","order":6,"disabled":false,"hidden":false},{"id":"e298b809.c3c2f8","type":"ui_group","z":"","name":"Before/After Modification","tab":"a68c0105.e9c7e","order":2,"disp":true,"width":"22","collapse":true},{"id":"a5286a8a.1e56e8","type":"ui_group","z":"","name":"Default","tab":"1a94010f.a3b71f","disp":true,"width":"6","collapse":false},{"id":"1a94010f.a3b71f","type":"ui_tab","z":"","name":"Home","icon":"dashboard","disabled":false,"hidden":false},{"id":"2a128af6.d72c46","type":"ui_group","z":"","name":"After Modification","tab":"a68c0105.e9c7e","order":3,"disp":false,"width":"22","collapse":false},{"id":"7de1e931.486e78","type":"ui_group","z":"","name":"www","tab":"","disp":false,"width":"35","collapse":false},{"id":"602d7c75.e52ed4","type":"ui_group","z":"","name":"Radar Console","tab":"429e5ab.771c5a4","order":3,"disp":true,"width":"6","collapse":false},{"id":"a4570963.5547f8","type":"ui_group","z":"","name":"Group 3","tab":"a68c0105.e9c7e","order":1,"disp":false,"width":"3","collapse":false},{"id":"820d7886.9debb8","type":"ui_spacer","name":"spacer","group":"a4570963.5547f8","order":6,"width":"3","height":"6"},{"id":"f2650446.2a56d8","type":"function","z":"db3a486d.c20478","name":"Step","func":"var x = env.get(\"Step\"); \nflow.set(\"$parent.Step\", x);\n\nmsg.payload = \"Your brightness increment has been set to: \" + x;\n\nreturn msg;","outputs":1,"noerr":0,"x":510,"y":80,"wires":[[]]},{"id":"7115886d.01af18","type":"function","z":"250ecbce.340264","name":"Set Read Col","func":"//Read subflow input variables\nif (env.get(\"OverrideEnvVariables\")){\n    //Put inputs and read values into msg properties to be visible downstream\n    msg.sheet = msg.SpreadsheetID;\n    msg.tab = msg.Tab;\n    msg.cellstart = msg.ColStart + msg.MinRow;\n    msg.cellend = msg.ColEnd + msg.MaxRow;\n    msg.targetrange = msg.tab+\"!\"+msg.cellstart+\":\"+msg.cellend\n    msg.topic = msg.targetrange\n    delete msg.Tab\n    delete msg.SpreadsheetID\n    delete msg.ColStart\n    delete msg.ColEnd\n    delete msg.MinRow\n    delete msg.MaxRow\n    delete msg.IgnoreEnvVar\n}else if (msg.IgnoreEnvVar) {\n    //Put inputs and read values into msg properties to be visible downstream\n    msg.sheet = msg.SpreadsheetID;\n    msg.tab = msg.Tab;\n    msg.cellstart = msg.ColStart + msg.MinRow;\n    msg.cellend = msg.ColEnd + msg.MaxRow;\n    msg.targetrange = msg.tab+\"!\"+msg.cellstart+\":\"+msg.cellend\n    msg.topic = msg.targetrange\n    delete msg.Tab\n    delete msg.SpreadsheetID\n    delete msg.ColStart\n    delete msg.ColEnd\n    delete msg.MinRow\n    delete msg.MaxRow\n    delete msg.IgnoreEnvVar\n}else{\n    var ColStart = env.get(\"ColStart\");\n    var ColEnd = env.get(\"ColEnd\");\n    var FirstRow = env.get(\"MinRow\");\n    var LastRow = env.get(\"MaxRow\");\n    //Put inputs and read values into msg properties to be visible downstream\n    msg.sheet = env.get(\"Spreadsheet ID\");\n    msg.tab = env.get(\"TabName\");\n    msg.cellstart = ColStart + FirstRow\n    msg.cellend = ColEnd + LastRow\n    msg.targetrange = msg.tab+\"!\"+msg.cellstart+\":\"+msg.cellend\n    msg.topic = msg.targetrange\n}\nreturn msg;","outputs":1,"noerr":0,"x":150,"y":20,"wires":[["f19af657.19fe88","cdae2d80.8d615"]]},{"id":"f19af657.19fe88","type":"GSheet","z":"250ecbce.340264","creds":"bb5b26fe.1fc278","method":"get","action":"","sheet":"","cells":"","name":"Read Input from GSheet","x":410,"y":20,"wires":[["b11f8aff.9aee68"]]},{"id":"8740490b.77e458","type":"comment","z":"250ecbce.340264","name":"Error","info":"","x":990,"y":20,"wires":[]},{"id":"6af56d08.1ec794","type":"comment","z":"250ecbce.340264","name":"Last Populated Row","info":"","x":1030,"y":100,"wires":[]},{"id":"be5dfe12.c99f2","type":"function","z":"250ecbce.340264","name":"Work In Progress","func":"\n/*\n * Actual good responses\n */\nmsg.LastPopulatedRow = msg.payload.length + env.get(\"MinRow\") - 1\nmsg.FirstEmptyRow = msg.LastPopulatedRow + 1\n/*\n * Placeholder/Fake Testing variables\n */\nvar colCount = 1 //number of columns wide from the data retrieved. This will eventually be replace by logic that loops through array find the max width for any given row\nvar sheetdata = msg.payload //this is the data that is returned from Google that will then be examined\n\n\n// Deletable msg.arraysize = msg.payload.length\nfor (index = 0; index < sheetdata.length; index++) {\n    if (Array.isArray(sheetdata[index])){\n        colCount = Math.max(colCount, sheetdata[index].length)\n        // Deletable msg.arrayfound = sheetdata[index].length\n    }\n    // Deletable msg.arrayfound = sheetdata[1].length\n} \n//deletable var fCol = \"aa\" // Test input column that will later be removed leaving in place\n/*\n *Column response calculation variables\n */\nvar fCol = env.get(\"ColStart\")\nvar fColTotal = 0 //to hold the column number\nvar nCol = \"\"   //nCol is new column\nvar lCol = \"\"   //lCol is last column in the range (to be populated from the actual Gsheet calls data)\n// Deletable var fCharFCol = fCol.charCodeAt(fCol.length - 1)   // fCharFCol is the final character of the first column in the range  \n// Deletable var fCol = env.get(\"ColStart\")     //fCol is the first column moved into a shorter local variable \n// Deletable var fColNum = fCol.charCodeAt(fCol.length - 1) //thecchar number of the last character of the column\n// Deletable var replacementNum = fColNum + colCount - 1 //the char of the replacement letter that will turn the first populated column in to the last column\n// Deletable var excess = 0 //this will be used to figure out how far beyond the Z or z the char num is\nfCol = fCol.toUpperCase()\n\n/*\n * validate fCol (done)\n */\nvar validStartCol = false\nvalidStartCol = ((fCol.length == 1) ||\n                ((fCol.substr(0, 1).charCodeAt(0) - 64) < 9) ||\n                (((fCol.substr(0, 1).charCodeAt(0) - 64) == 9) && ((fCol.substr(1, 1).charCodeAt(0) - 64) <= 22)))\n/*\n *Column response calculations\n */\nswitch (fCol.length) {\n    case 1:\n        fColTotal = (fCol.substr(0, 1).charCodeAt(0) - 64)\n        fColTotal += colCount - 1\n        break\n    case 2:\n        fColTotal = (fCol.substr(1, 1).charCodeAt(0) - 64) + 26 * (fCol.substr(0, 1).charCodeAt(0) - 64)\n        fColTotal += colCount - 1\n        break\n    default:\n        fColTotal = -1\n}\n//Last Populated Column and First Empty Column calculation\nif ((fColTotal <= 25) && (fColTotal >= 1)) {\n    lCol = String.fromCharCode(fColTotal+64)\n    nCol = String.fromCharCode(fColTotal+65)\n} else if (fColTotal == 26) {\n    lCol = \"Z\"\n    nCol = \"AA\"\n} else if (fColTotal >= 27) {\n    lCol = String.fromCharCode((Math.floor(fColTotal / 26)) + 64) + String.fromCharCode((fColTotal % 26) + 64)\n    nCol = String.fromCharCode((Math.floor(fColTotal / 26)) + 64) + String.fromCharCode((fColTotal % 26) + 65)\n} else if (fColTotal == -1) {\n    lCol = \"Error\"\n    nCol = \"Error\"\n    //Probably worth putting real error here, but deferred\n} else if (fColTotal == 256) {\n    lCol = \"IV\"\n    nCol = \"None\"\n}\nmsg.LastPopulatedCol = lCol\nmsg.FirstEmptyCol = nCol\nmsg.SpreadsheetArray = msg.payload\nreturn msg;","outputs":1,"noerr":0,"x":370,"y":560,"wires":[["9cabee41.a056b","d91779c2.896ea8","46c25d0f.563a44","893d102e.47b92","c62b3213.e206a","c9c7210d.d881f"]]},{"id":"95b7965d.e4b428","type":"comment","z":"250ecbce.340264","name":"First Empty Row","info":"","x":1020,"y":180,"wires":[]},{"id":"a57014a2.3e04b8","type":"comment","z":"250ecbce.340264","name":"Last Populated Column","info":"","x":1040,"y":260,"wires":[]},{"id":"485298fb.4f6858","type":"comment","z":"250ecbce.340264","name":"First Empty Column","info":"","x":1030,"y":340,"wires":[]},{"id":"a7b5845f.22c4d8","type":"comment","z":"250ecbce.340264","name":"Spreadsheet Array","info":"","x":1030,"y":420,"wires":[]},{"id":"17f3bcf9.9a03e3","type":"comment","z":"250ecbce.340264","name":"Full Data","info":"","x":1000,"y":500,"wires":[]},{"id":"ad16bbb.aa68a48","type":"comment","z":"250ecbce.340264","name":"Full Data with Inputs","info":"","x":1030,"y":580,"wires":[]},{"id":"9cabee41.a056b","type":"change","z":"250ecbce.340264","name":"Leave Outputs","rules":[{"t":"delete","p":"topic","pt":"msg"},{"t":"delete","p":"tab","pt":"msg"},{"t":"delete","p":"sheet","pt":"msg"},{"t":"delete","p":"cellstart","pt":"msg"},{"t":"delete","p":"cellend","pt":"msg"},{"t":"delete","p":"targetrange","pt":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":740,"y":540,"wires":[[]]},{"id":"d91779c2.896ea8","type":"change","z":"250ecbce.340264","name":"Leave Last Populated Row","rules":[{"t":"delete","p":"topic","pt":"msg"},{"t":"delete","p":"tab","pt":"msg"},{"t":"delete","p":"sheet","pt":"msg"},{"t":"delete","p":"cellstart","pt":"msg"},{"t":"delete","p":"cellend","pt":"msg"},{"t":"delete","p":"targetrange","pt":"msg"},{"t":"delete","p":"FirstEmptyRow","pt":"msg"},{"t":"delete","p":"LastPopulatedCol","pt":"msg"},{"t":"delete","p":"FirstEmptyCol","pt":"msg"},{"t":"delete","p":"SpreadsheetArray","pt":"msg"},{"t":"set","p":"payload","pt":"msg","to":"LastPopulatedRow","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":780,"y":140,"wires":[[]]},{"id":"46c25d0f.563a44","type":"change","z":"250ecbce.340264","name":"Leave First Empty Row","rules":[{"t":"delete","p":"topic","pt":"msg"},{"t":"delete","p":"tab","pt":"msg"},{"t":"delete","p":"sheet","pt":"msg"},{"t":"delete","p":"cellstart","pt":"msg"},{"t":"delete","p":"cellend","pt":"msg"},{"t":"delete","p":"targetrange","pt":"msg"},{"t":"delete","p":"LastPopulatedRow","pt":"msg"},{"t":"delete","p":"LastPopulatedCol","pt":"msg"},{"t":"delete","p":"FirstEmptyCol","pt":"msg"},{"t":"delete","p":"SpreadsheetArray","pt":"msg"},{"t":"set","p":"payload","pt":"msg","to":"FirstEmptyRow","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":770,"y":220,"wires":[[]]},{"id":"893d102e.47b92","type":"change","z":"250ecbce.340264","name":"Leave Last Populated Column","rules":[{"t":"delete","p":"topic","pt":"msg"},{"t":"delete","p":"tab","pt":"msg"},{"t":"delete","p":"sheet","pt":"msg"},{"t":"delete","p":"cellstart","pt":"msg"},{"t":"delete","p":"cellend","pt":"msg"},{"t":"delete","p":"targetrange","pt":"msg"},{"t":"delete","p":"LastPopulatedRow","pt":"msg"},{"t":"delete","p":"FirstEmptyRow","pt":"msg"},{"t":"delete","p":"FirstEmptyCol","pt":"msg"},{"t":"delete","p":"SpreadsheetArray","pt":"msg"},{"t":"set","p":"payload","pt":"msg","to":"LastPopulatedCol","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":790,"y":300,"wires":[[]]},{"id":"c62b3213.e206a","type":"change","z":"250ecbce.340264","name":"Leave First Empty Column","rules":[{"t":"delete","p":"topic","pt":"msg"},{"t":"delete","p":"tab","pt":"msg"},{"t":"delete","p":"sheet","pt":"msg"},{"t":"delete","p":"cellstart","pt":"msg"},{"t":"delete","p":"cellend","pt":"msg"},{"t":"delete","p":"targetrange","pt":"msg"},{"t":"delete","p":"LastPopulatedRow","pt":"msg"},{"t":"delete","p":"FirstEmptyRow","pt":"msg"},{"t":"delete","p":"LastPopulatedCol","pt":"msg"},{"t":"delete","p":"SpreadsheetArray","pt":"msg"},{"t":"set","p":"payload","pt":"msg","to":"FirstEmptyCol","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":780,"y":380,"wires":[[]]},{"id":"c9c7210d.d881f","type":"change","z":"250ecbce.340264","name":"Leave Spreadsheet Array","rules":[{"t":"delete","p":"topic","pt":"msg"},{"t":"delete","p":"tab","pt":"msg"},{"t":"delete","p":"sheet","pt":"msg"},{"t":"delete","p":"cellstart","pt":"msg"},{"t":"delete","p":"cellend","pt":"msg"},{"t":"delete","p":"targetrange","pt":"msg"},{"t":"delete","p":"LastPopulatedRow","pt":"msg"},{"t":"delete","p":"FirstEmptyRow","pt":"msg"},{"t":"delete","p":"LastPopulatedCol","pt":"msg"},{"t":"delete","p":"FirstEmptyCol","pt":"msg"},{"t":"set","p":"payload","pt":"msg","to":"SpreadsheetArray","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":770,"y":460,"wires":[[]]},{"id":"b11f8aff.9aee68","type":"function","z":"250ecbce.340264","name":"Cancel Timeout?","func":"msg.reset = true\nreturn msg;","outputs":1,"noerr":0,"x":170,"y":140,"wires":[["fa582a24.4565e8","eb587bd4.e05c58"]]},{"id":"fa582a24.4565e8","type":"trigger","z":"250ecbce.340264","op1":"","op2":"timeout","op1type":"nul","op2type":"str","duration":"10","extend":true,"units":"s","reset":"","bytopic":"all","name":"Watchdog","x":480,"y":140,"wires":[["893d102e.47b92","d91779c2.896ea8","c62b3213.e206a","c9c7210d.d881f","9cabee41.a056b"]]},{"id":"cdae2d80.8d615","type":"change","z":"250ecbce.340264","name":"","rules":[{"t":"set","p":"timeout","pt":"msg","to":"true","tot":"bool"}],"action":"","property":"","from":"","to":"","reg":false,"x":460,"y":100,"wires":[["fa582a24.4565e8"]]},{"id":"eb587bd4.e05c58","type":"change","z":"250ecbce.340264","name":"","rules":[{"t":"delete","p":"reset","pt":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":370,"y":500,"wires":[["be5dfe12.c99f2"]]},{"id":"33cf6aac.eabb16","type":"catch","z":"250ecbce.340264","name":"Catch and Relay Errors","scope":null,"uncaught":false,"x":760,"y":60,"wires":[[]]},{"id":"f9ce45cd.70d568","type":"rbe","z":"76e3605b.0e6e7","name":"Changing Ping?","func":"rbe","gap":"","start":"","inout":"out","property":"PingStatus","x":860,"y":100,"wires":[["23c83a68.f57316"]]},{"id":"54bcf469.64fc1c","type":"file","z":"76e3605b.0e6e7","name":"Append to NetUpPerpetual","filename":"","appendNewline":true,"createDir":false,"overwriteFile":"false","encoding":"none","x":940,"y":220,"wires":[[]]},{"id":"800cd2f0.7e6fc","type":"simpletime","z":"76e3605b.0e6e7","name":"Populate Time Messages","x":150,"y":240,"wires":[["2224f154.3db68e"]]},{"id":"2224f154.3db68e","type":"change","z":"76e3605b.0e6e7","name":"Create Log Start line with Formated Date","rules":[{"t":"set","p":"payload","pt":"msg","to":"myyear\t&\"-\"&\tmymonthn\t&\"-\"&\tmydom\t&\" \"&\tmyhourpm\t&\":\"&\tmyminute\t&\":\"&\tmysecond\t&\".\"&\tmymillis\t&\" \"&\tmypm\t&\"          Log Start\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":440,"y":240,"wires":[["54bcf469.64fc1c","b832f02e.6f68d"]]},{"id":"7b2187a9.5139d8","type":"change","z":"76e3605b.0e6e7","name":"Get dir/file destination from Flow context","rules":[{"t":"set","p":"filename","pt":"msg","to":"$flowContext('OutputDirectory') &\tpingtarget & \".txt\"","tot":"jsonata"},{"t":"set","p":"pingtime","pt":"msg","to":"payload","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":580,"y":140,"wires":[["833fda41.17b198","41c7aa38.91a0b4"]]},{"id":"f1a77239.f0493","type":"comment","z":"76e3605b.0e6e7","name":"JSONata Flow context","info":"myyear&\"-\"&mymonthn&\"-\"&mydom&\" \"&myhourpm &\":\"&myminute&\":\"&mysecond&\n\".\"&mymillis\n","x":500,"y":100,"wires":[]},{"id":"38e74b76.ec65d4","type":"change","z":"76e3605b.0e6e7","name":"Failure Start time","rules":[{"t":"set","p":"payload","pt":"msg","to":"","tot":"date"}],"action":"","property":"","from":"","to":"","reg":false,"x":150,"y":960,"wires":[["b89a96f9.f64b88","f6326890.3b8ae8","148d89ae.8a8376"]]},{"id":"c2fdf835.927178","type":"change","z":"76e3605b.0e6e7","name":"Failure End time","rules":[{"t":"set","p":"payload","pt":"msg","to":"","tot":"date"}],"action":"","property":"","from":"","to":"","reg":false,"x":580,"y":1000,"wires":[["b89a96f9.f64b88"]]},{"id":"6b07ffa.4eb28","type":"calculator","z":"76e3605b.0e6e7","name":"Calculate the difference","inputMsgField":"payload","outputMsgField":"payload","operation":"sub","constant":"","x":610,"y":1040,"wires":[["94dfb9b5.59e1a8"]]},{"id":"b89a96f9.f64b88","type":"join","z":"76e3605b.0e6e7","name":"Get start and end times","mode":"custom","build":"array","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":170,"y":1040,"wires":[["6b07ffa.4eb28"]]},{"id":"f6326890.3b8ae8","type":"delay","z":"76e3605b.0e6e7","name":"","pauseType":"random","timeout":"1300","timeoutUnits":"milliseconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"milliseconds","drop":false,"x":400,"y":1000,"wires":[["c2fdf835.927178"]]},{"id":"94dfb9b5.59e1a8","type":"calculator","z":"76e3605b.0e6e7","name":"Multiply by -1 to get positive duration","inputMsgField":"payload","outputMsgField":"payload","operation":"mult","constant":"-1","x":210,"y":1080,"wires":[["2ea97499.5a805c"]]},{"id":"2ea97499.5a805c","type":"function","z":"76e3605b.0e6e7","name":"Translate Duration Function","func":"/* \n * Create Variables\n * \n */\n        var milliseconds = msg.payload;\n        var years, weeks, days, hours, minutes, seconds, millis;\n    //creating 2 string versions of each of the durations that can be in the middle of a 1:01:01.001 duration \n    //minstr is the always 2 character one\n    //lminstr is the version that can be 1 or more characers that will be used when that part is the portion of the duration\n        var minstr, secstr, millistr, lminstr, lsecstr, lmillistr;\n        var whichcomponents, readableduration;\n\n/*\n * Calculate the numbers for the subcomponents\n * \n */\n    //by getting the remainder when dividing by 1000\n    //it leaves just the fraction of milliseconds\n        millis = milliseconds % 1000;\n    //the floor function drops the decimal portion\n    //returning the non fractional seconds\n        seconds = Math.floor(milliseconds / 1000);\n    //the floor function drops the decimal portion\n    //returning the non fractional minutes\n        minutes = Math.floor(seconds / 60);\n    //Once the minutes have been calculated, then\n    //the seconds is replaced with those seconds not\n    //accounted for by the minutes\n        seconds = seconds % 60;\n    //The same sequence as used for minutes/seconds\n    //then used to calulate minutes, hours, dayss, weeks, years\n\n        hours = Math.floor(minutes / 60);\n        minutes = minutes % 60;\n        days = Math.floor(hours / 24);\n        hours = hours % 24;\n        weeks = Math.floor(days / 7)\n        days = days % 7;\n        years = Math.floor(days / 365.25)\n        weeks = weeks % 52;\n\n/*\n * Put the subcomponents into msg payloads for easy access by later nodes\n *\n */\n        msg.years = years\n        msg.weeks = weeks\n        msg.days = days\n        msg.hours = hours\n        msg.minutes = minutes\n        msg.seconds = seconds\n        msg.millis = millis\n \n\n/*\n * create the string verssion for the subcomponents\n */\n    //milliseconds\n        lmillistr = millis.toString();\n        //put padding on the milliseconds so that 1 ms shows as .001 and not .1 when concatenated after a decimal\n            millistr = millis.toString().padStart(3, \"0\");\n    //seconds\n        lsecstr = seconds.toString();\n        //put padding on the seconds so that 1 s shows as :01.000 and not :1.000 when concatenated after a dividing :\n            secstr = lsecstr.padStart(2, \"0\");\n    //minutes\n        lminstr = minutes.toString();\n        //put padding on the minutes so that 1 m shows as :01:00.000 and not :1:00.000 when concatenated after a dividing :\n            minstr = lminstr.padStart(2, \"0\");\n\n/*\n * Build output based on largest significant populated unit\n * The general rule is to include in the output the largest unit (years, weeks, days, etc) followed by the next 2\n * smaller units if the happen to be populated\n */\n    readableduration =\"\"\n//years populated\n    if (years !== 0) { \n        if (days !== 0) {\n            if (days === 1) {\n                readableduration = \" \".concat(days.toString(), \" Day\", readableduration)\n            } else {\n                readableduration = \" \".concat(days.toString(), \" Days\", readableduration)\n            }\n        }\n        if (weeks !== 0) {\n            if (weeks === 1) {\n                readableduration = \" \".concat(weeks.toString(), \" Week\", readableduration)\n            } else {\n                readableduration = \" \".concat(weeks.toString(), \" Weeks\", readableduration)\n            }\n        }\n        if (years === 1) {\n            readableduration = years.toString().concat(\" Year\", readableduration)\n        } else {\n            readableduration = years.toString().concat(\" Years\", readableduration)\n        }\n//weeks populated\n    } else if (weeks !== 0) {\n        if (hours !== 0) {\n            if (hours === 1) {\n                readableduration = \" \".concat(hours.toString(), \" Hour\", readableduration)\n            } else {\n                readableduration = \" \".concat(hours.toString(), \" Hours\", readableduration)\n            }\n        }\n        if (days !== 0) {\n            if (weeks === 1) {\n                readableduration = \" \".concat(days.toString(), \" Day\", readableduration)\n            } else {\n                readableduration = \" \".concat(days.toString(), \" Days\", readableduration)\n            }\n        }\n        if (weeks === 1) {\n            readableduration = weeks.toString().concat(\" Week\", readableduration)\n        } else {\n            readableduration = weeks.toString().concat(\" Weeks\", readableduration)\n        }\n//days populated\n    } else if (days !== 0) {\n        if ((minutes !== 0) && (hours !== 0)) { //If both are non-zero then 1:01 format. If only 1 then either 2 hours or 1 minute\n            if (minutes !== 0) {\n                readableduration = \":\".concat(minstr, readableduration)\n            }\n            if (hours !== 0) {\n                readableduration = \" \".concat(hours.toString(), readableduration)\n            } else {\n                readableduration = \" 0\".concat(readableduration)\n            }\n        } else {\n            if (minutes === 1) {\n                readableduration = \" 1 Minute\".concat(readableduration)\n            } else if (minutes > 1) {\n                readableduration = \" \".concat(lminstr,\" Minutes\", readableduration)\n            } else if (hours === 1) {\n                readableduration = \" 1 Hour\".concat(readableduration)\n            } else {\n                if (hours >1) {\n                    readableduration = \" \".concat(hours.toString(),\" Hours\", readableduration)\n                }\n            }\n        }\n        if (days === 1) {\n            readableduration = days.toString().concat(\" Day\", readableduration)\n        } else {\n            readableduration = days.toString().concat(\" Days\", readableduration)\n        }\n//hours populated\n    } else if (hours !== 0) {\n        if ((minutes !== 0) || (seconds !== 0)) { //End result h Hours or h:mm:ss\n            readableduration = hours.toString().concat(\":\", minstr, \":\", secstr, readableduration)\n        } else {\n            if (hours === 1) {\n                readableduration = \"1 Hour\"\n            } else {\n                readableduration = hours.toString().concat(\" Hours\", readableduration)\n            }\n        }\n//minutes populated\n    } else if (minutes !== 0) { //End result m Minutes or mm:ss.MMM\n        if (seconds !== 0 || millis !== 0) { //End result h Hours or h:mm:ss\n            readableduration = lminstr.concat(\":\", secstr, \".\", millistr, readableduration)\n        } else {\n            if (minutes === 1) {\n                readableduration = \"1 Minute\".concat( readableduration)\n            } else {\n                readableduration = lminstr.concat(\" Minutes\", readableduration)\n            }\n        }\n//seconds populated\n    } else if (seconds !== 0) {\n        if (millis !== 0) { //End result s Seconds or s.MMM\n            readableduration = lsecstr.concat(\".\", millistr, \" Seconds\", readableduration)\n        } else {\n            if (seconds === 1) {\n                readableduration = \"1 Second\".concat( readableduration)\n            } else {\n                readableduration = lsecstr.concat(\" Seconds\", readableduration)\n            }\n        }\n//milliseconds populated\n    } else if (millis !== 0) {\n        if (millis !== 1) {\n            readableduration = lmillistr.concat(\" Milliseconds\", readableduration)\n        } else {\n            readableduration = \"1 Millisecond\".concat( readableduration)\n        }\n    } else {\n        readableduration = \"0\"\n    }\n    msg.years = years\n    msg.weeks = weeks\n    msg.days = days\n    msg.hours = hours\n    msg.minutes = minutes\n    msg.seconds = seconds\n    msg.millis = millis\n    msg.payload = readableduration\n    return msg;","outputs":1,"noerr":0,"x":500,"y":1080,"wires":[["82c9edda.537d7"]]},{"id":"408b8df6.b9b044","type":"join","z":"76e3605b.0e6e7","name":"Join the failure start time with the duration for output","mode":"custom","build":"string","property":"payload","propertyType":"msg","key":"topic","joiner":"","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1070,"y":960,"wires":[[]]},{"id":"82c9edda.537d7","type":"function","z":"76e3605b.0e6e7","name":"Pad the text duration to 24 characters","func":"msg.payload = msg.payload.padStart(24)\nreturn msg;","outputs":1,"noerr":0,"x":801,"y":1080,"wires":[["408b8df6.b9b044"]]},{"id":"148d89ae.8a8376","type":"change","z":"76e3605b.0e6e7","name":"Create Log Start line with Formated Date","rules":[{"t":"set","p":"payload","pt":"msg","to":"myyear\t&\"-\"&\tmymonthn\t&\"-\"&\tmydom\t&\" \"&\tmyhourpm\t&\":\"&\tmyminute\t&\":\"&\tmysecond\t&\".\"&\tmymillis\t&\" \"&\tmypm","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":660,"y":960,"wires":[["408b8df6.b9b044"]]},{"id":"6e44be2e.917c7","type":"function","z":"76e3605b.0e6e7","name":"Include Ping Time if Successful","func":"if (isNaN(msg.pingtime)) {\n    msg.payload = msg.CurrentTime.padEnd(28,\" \") + msg.PingStatus.padEnd(20, \" \")\n} else {\nmsg.payload = msg.CurrentTime.padEnd(28,\" \") + msg.PingStatus.padEnd(9, \" \") + msg.pingtime.toString().padEnd(11,\" \") + msg.Min.toString().padEnd(11,\" \") + msg.Max.toString().padEnd(11,\" \") + msg.RollingAverage.toString().padEnd(11,\" \")\n}\nreturn msg;","outputs":1,"noerr":0,"x":950,"y":460,"wires":[["54bcf469.64fc1c"]]},{"id":"23c83a68.f57316","type":"simpletime","z":"76e3605b.0e6e7","name":"Populate Time Messages","x":1070,"y":60,"wires":[["8ac84738.ad8f18"]]},{"id":"8ac84738.ad8f18","type":"change","z":"76e3605b.0e6e7","name":"Formated Date for ping log entry","rules":[{"t":"set","p":"CurrentTime","pt":"msg","to":"myyear\t&\"-\"&\tmymonthn\t&\"-\"&\tmydom\t&\" \"&\tmyhourpm\t&\":\"&\tmyminute\t&\":\"&\tmysecond\t&\".\"&\tmymillis\t&\" \"&\tmypm","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":1050,"y":160,"wires":[["6e44be2e.917c7"]]},{"id":"833fda41.17b198","type":"rbe","z":"76e3605b.0e6e7","name":"Only write headers first time process is initiated","func":"rbe","gap":"","start":"","inout":"out","property":"filename","x":220,"y":200,"wires":[["3a6e32fc.4a089e"]]},{"id":"41c7aa38.91a0b4","type":"delay","z":"76e3605b.0e6e7","name":"","pauseType":"delay","timeout":"1","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":700,"y":60,"wires":[["f9ce45cd.70d568","48434c5b.387c44","e6f86ef9.f3af6"]]},{"id":"7c6b7df4.a02714","type":"function","z":"76e3605b.0e6e7","name":"Update Flow Results Based on Latest Input","func":"var CurrentCount = flow.get(\"Count\")\nif (!isNaN(msg.payload)) {\n    var next = Number(msg.payload)\n    if (next === 0) {\n    } else {\n        var CurrentAvg = flow.get(\"RollingAverage\")\n        var CurrentMax = flow.get(\"Max\")\n        var CurrentMin = flow.get(\"Min\")\n        var OldMax = CurrentMax\n        var OldMin = CurrentMin\n        if (CurrentCount === 0) {\n            CurrentAvg = next;\n            CurrentMin = next;\n            CurrentMax = next;\n            CurrentCount = CurrentCount + 1\n        } else {\n            oldtotal = CurrentAvg * CurrentCount\n            newtotal = next + oldtotal\n            CurrentCount = CurrentCount + 1\n            CurrentAvg = newtotal / CurrentCount\n            CurrentMax = Math.max(next, CurrentMax)\n            if (CurrentMax != OldMax) {\n                msg.NewMax = true\n            }\n            CurrentMin = Math.min(next, CurrentMin)\n            if (CurrentMin != OldMin) {\n                msg.NewMin = true\n            }\n        }\n        flow.set(\"RollingAverage\", CurrentAvg);\n        flow.set(\"Max\", CurrentMax);\n        flow.set(\"Min\", CurrentMin);\n        flow.set(\"Count\", CurrentCount);\n        msg.next = next\n        msg.RollingAverage = CurrentAvg;\n        msg.Max = CurrentMax;\n        msg.Min = CurrentMin;\n        msg.Count = CurrentCount;\n        return msg;\n    }\n}\n","outputs":1,"noerr":0,"x":230,"y":140,"wires":[["7b2187a9.5139d8"]]},{"id":"b832f02e.6f68d","type":"function","z":"76e3605b.0e6e7","name":"--Divider","func":"var a=\"-\"\na=a.padEnd(81,\"-\")\nmsg.payload = a\nreturn msg;","outputs":1,"noerr":0,"x":540,"y":280,"wires":[["54bcf469.64fc1c","11aeda74.2913e6"]]},{"id":"11aeda74.2913e6","type":"function","z":"76e3605b.0e6e7","name":"Send Header","func":"var a=\"\"\na = a + \"Date\".padEnd(28,\" \")+ \"Status\".padEnd(9,\" \")+ \"Roundtrip\".padEnd(11,\" \")+ \"Min\".padEnd(11,\" \")+ \"Max\".padEnd(11,\" \")+ \"Average\".padEnd(11,\" \")\nmsg.payload = a\nreturn msg;","outputs":1,"noerr":0,"x":530,"y":320,"wires":[["54bcf469.64fc1c"]]},{"id":"3a6e32fc.4a089e","type":"function","z":"76e3605b.0e6e7","name":"===Divider","func":"var a=\"=\"\na=a.padEnd(81,\"=\")\nmsg.payload = a\nreturn msg;","outputs":1,"noerr":0,"x":510,"y":200,"wires":[["800cd2f0.7e6fc","54bcf469.64fc1c"]]},{"id":"f97e59e9.764a98","type":"config","z":"76e3605b.0e6e7","name":"Config output directory","properties":[{"p":"OutputDirectory","pt":"flow","to":"/CS/Uptime/","tot":"str"},{"p":"Count","pt":"flow","to":"0","tot":"num"},{"p":"Min","pt":"flow","to":"None","tot":"str"},{"p":"Max","pt":"flow","to":"None","tot":"str"},{"p":"RollingAverage","pt":"flow","to":"None","tot":"str"}],"active":true,"x":140,"y":80,"wires":[],"info":"Note: by having a config node in a subflow, this sets the flow variables for when the subflow is activated. There is no way to use the click ability of a config node in a subflow, but it does do the initial population of the variable each time the subflow is triggered. In this case because the subflow is triggered via 12 different outputs, each of the 12 is a different set of the same variables."},{"id":"81c7815c.892cd","type":"config","z":"711cdb94.5b9a04","name":"Config output directory","properties":[{"p":"OutputDirectory","pt":"flow","to":"/CS/Uptime/","tot":"str"},{"p":"Count","pt":"flow","to":"0","tot":"num"},{"p":"Min","pt":"flow","to":"None","tot":"str"},{"p":"Max","pt":"flow","to":"None","tot":"str"},{"p":"RollingAverage","pt":"flow","to":"None","tot":"str"},{"p":"downcount","pt":"flow","to":"0","tot":"str"},{"p":"calculateandwriteoutage","pt":"flow","to":"false","tot":"bool"}],"active":true,"x":140,"y":240,"wires":[],"info":" * CS 192.168.86.3\r\n * G Wifi 192.168.86.1\r\n * Emby laptop 192.168.86.2\r\n * Lennox 192.168.86.101\r\n * ATT router 192.168.1.254\r\n * Cloudflare 1.1.1.1\r\n * Level 3 4.2.2.2\r\n * Google 8.8.8.8\r\n * OpenDNS 208.67.222.222\r\n * dfw25s26-in-f19.1e100.net 172.217.9.147\r\n * ghs.googlehosted.com 172.217.9.147\r\n * "},{"id":"159589d9.1135c6","type":"GSheet","z":"711cdb94.5b9a04","creds":"adb4e9b8.8beee8","method":"append","action":"","sheet":"1ZKNZWvcBqLcxkkFSrV9JN-BAeXiGoGrDjepUyD-S5Cs","cells":"Sheet1!A2:J1000","name":"","x":1137,"y":500,"wires":[[]]},{"id":"c77a0cee.02f32","type":"function","z":"711cdb94.5b9a04","name":"Examine messages for Internet vs host down","func":"if (msg.internettarget){\n    var downCount = flow.get(\"downcount\")\n    if(!isNaN(downCount)){\n        if(downCount<6){ //it would be better and more elegant to have something count the number of internet targets and pass that in, but for now it is just hardcoded to 6\n            downCount++\n            if(downCount == 6) {\n                flow.set(\"wentdownat\",Date.now())\n                flow.set(\"internetdown\", true)\n            }\n        }\n        \n    }\n    flow.set(\"downcount\", downCount);\n    return msg;}","outputs":1,"noerr":0,"x":710,"y":53,"wires":[[]],"info":"This Node is triggered by a ping response of false (i.e. more than 5 seconds to respond and thus either the network or the target host is offline)\n\n * gets how many consecutive times the ping has shown as down\n * sets internet down as true\n * Makes sure the down count is a number (belt and suspenders that could almost certainly be removed\n * If it is not a number than nothing happens\n * If it is, the it checks to see if the number of down responses has reached 6. The 6 is how many internet hosts are being examined. I assume that if we reach 6 then it is the internet and not just one or more of the total hosts that are down. If it is already at 6 then the system is treating the internet as down aleady and no further action is required.\n * If it is less than 6, then the count is incremented\n * If incrementing it has now made the count 6, it then records (in epoch time) the time the count went from 5 to 6.\n * Finally it saves the count back into a flow variable.\n"},{"id":"2286604.c0f71a","type":"function","z":"711cdb94.5b9a04","name":"Time to report outage?","func":"if (msg.internettarget){\n    var downCount = flow.get(\"downcount\")\n    var originalDownCount = downCount\n    flow.set(\"calculateandwriteoutage\",false)\n    if(!isNaN(downCount)){\n        if(downCount > 0){\n            downCount--\n            if(downCount === 0 && flow.get(\"internetdown\")) {\n                flow.set(\"internetdown\", false)\n                flow.set(\"cameupat\",Date.now())\n                flow.set(\"calculateandwriteoutage\",true)\n            }\n        }\n    }\n    flow.set(\"downcount\", downCount);\n    if(flow.get(\"calculateandwriteoutage\")){\n        return msg;\n        \n    }\n}","outputs":1,"noerr":0,"x":760,"y":100,"wires":[["8a0a15c8.5a92d8"]],"info":"This Node is triggered by a ping response of a number (i.e. between 1 and 4999 milliseconds for a ping response)\n\n * get how many nodes are down\n * save a copy of how many nodes are down\n * Set flow variable for whether to do a calculation and output to false by default\n * Makes sure the down count is a number (belt and suspenders that could almost certainly be removed)\n * Check if the count is greater than zero\n * If it is then decrement the count\n * check if the decremented count is 0 now and that the internetdown flag is true (this flag means the down count reached 6)\n * If it is, then the internet is up enough to then this record this as the time the internet came up and set the internetdown back to false and change the flag for whether to calculated and write the outage to Gsheet to true\n * Record the down count to the flow variable"},{"id":"cfec0785.b80348","type":"switch","z":"711cdb94.5b9a04","name":"","property":"pingtargetnum","propertyType":"msg","rules":[{"t":"eq","v":"1","vt":"str"},{"t":"eq","v":"2","vt":"str"},{"t":"eq","v":"3","vt":"str"},{"t":"eq","v":"4","vt":"str"},{"t":"eq","v":"5","vt":"str"},{"t":"eq","v":"6","vt":"str"},{"t":"eq","v":"7","vt":"str"},{"t":"eq","v":"8","vt":"str"},{"t":"eq","v":"9","vt":"str"},{"t":"eq","v":"10","vt":"str"},{"t":"eq","v":"11","vt":"str"},{"t":"eq","v":"12","vt":"str"}],"checkall":"false","repair":false,"outputs":12,"x":930,"y":240,"wires":[["625ab66.59d0b48"],["c5d470b0.da92f"],["469f91ba.58236"],["6caf4611.732b98"],["59014ce7.0a1b44"],["83e3d76d.17aad8"],["25747400.0795cc"],["2c8b7f98.87f3e"],["8f9ccce1.dd365"],["c8251ad6.9dcaf8"],["f54e3165.fa3b4"],["84a64174.16425"]]},{"id":"2a8bf2f.e6a000e","type":"function","z":"711cdb94.5b9a04","name":"Calculate Duration of Outage","func":"if(flow.get(\"calculateandwriteoutage\")){\n    var duration = flow.get(\"cameupat\") - flow.get(\"wentdownat\")\n    flow.set(\"calculateandwriteoutage\",false)\n    msg.payload = duration\n    return msg;\n} \n","outputs":1,"noerr":0,"x":160,"y":580,"wires":[["9a5ed7f0.5f0c68"]]},{"id":"cd0652f2.24c1b","type":"change","z":"711cdb94.5b9a04","name":"Set Ping Status Down","rules":[{"t":"set","p":"PingStatus","pt":"msg","to":"Down","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":340,"y":53,"wires":[["cfec0785.b80348","c77a0cee.02f32"]]},{"id":"625ab66.59d0b48","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","x":1150,"y":20,"wires":[]},{"id":"c5d470b0.da92f","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":60,"wires":[]},{"id":"469f91ba.58236","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":100,"wires":[]},{"id":"6caf4611.732b98","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":140,"wires":[]},{"id":"59014ce7.0a1b44","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":180,"wires":[]},{"id":"83e3d76d.17aad8","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":220,"wires":[]},{"id":"25747400.0795cc","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":260,"wires":[]},{"id":"2c8b7f98.87f3e","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":300,"wires":[]},{"id":"8f9ccce1.dd365","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":340,"wires":[]},{"id":"c8251ad6.9dcaf8","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":380,"wires":[]},{"id":"f54e3165.fa3b4","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1150,"y":420,"wires":[]},{"id":"84a64174.16425","type":"subflow:76e3605b.0e6e7","z":"711cdb94.5b9a04","name":"","x":1149,"y":460,"wires":[]},{"id":"286de803.dcf568","type":"change","z":"711cdb94.5b9a04","name":"Set Ping Status Good","rules":[{"t":"set","p":"PingStatus","pt":"msg","to":"Good","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":340,"y":100,"wires":[["cfec0785.b80348","2286604.c0f71a"]]},{"id":"3716f3a5.c360dc","type":"change","z":"711cdb94.5b9a04","name":"Set Ping Status Slow","rules":[{"t":"set","p":"PingStatus","pt":"msg","to":"Slow","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":340,"y":140,"wires":[["cfec0785.b80348","2286604.c0f71a"]]},{"id":"9a5ed7f0.5f0c68","type":"function","z":"711cdb94.5b9a04","name":"Translate Duration Function","func":"/* \n * Create Variables\n * \n */\n        var milliseconds = msg.payload;\n        var years, weeks, days, hours, minutes, seconds, millis;\n    //creating 2 string versions of each of the durations that can be in the middle of a 1:01:01.001 duration \n    //minstr is the always 2 character one\n    //lminstr is the version that can be 1 or more characers that will be used when that part is the portion of the duration\n        var minstr, secstr, millistr, lminstr, lsecstr, lmillistr;\n        var whichcomponents, readableduration;\n\n/*\n * Calculate the numbers for the subcomponents\n * \n */\n    //by getting the remainder when dividing by 1000\n    //it leaves just the fraction of milliseconds\n        millis = milliseconds % 1000;\n    //the floor function drops the decimal portion\n    //returning the non fractional seconds\n        seconds = Math.floor(milliseconds / 1000);\n    //the floor function drops the decimal portion\n    //returning the non fractional minutes\n        minutes = Math.floor(seconds / 60);\n    //Once the minutes have been calculated, then\n    //the seconds is replaced with those seconds not\n    //accounted for by the minutes\n        seconds = seconds % 60;\n    //The same sequence as used for minutes/seconds\n    //then used to calulate minutes, hours, dayss, weeks, years\n\n        hours = Math.floor(minutes / 60);\n        minutes = minutes % 60;\n        days = Math.floor(hours / 24);\n        hours = hours % 24;\n        weeks = Math.floor(days / 7)\n        days = days % 7;\n        years = Math.floor(days / 365.25)\n        weeks = weeks % 52;\n\n/*\n * Put the subcomponents into msg payloads for easy access by later nodes\n *\n */\n        msg.years = years\n        msg.weeks = weeks\n        msg.days = days\n        msg.hours = hours\n        msg.minutes = minutes\n        msg.seconds = seconds\n        msg.millis = millis\n \n\n/*\n * create the string verssion for the subcomponents\n */\n    //milliseconds\n        lmillistr = millis.toString();\n        //put padding on the milliseconds so that 1 ms shows as .001 and not .1 when concatenated after a decimal\n            millistr = millis.toString().padStart(3, \"0\");\n    //seconds\n        lsecstr = seconds.toString();\n        //put padding on the seconds so that 1 s shows as :01.000 and not :1.000 when concatenated after a dividing :\n            secstr = lsecstr.padStart(2, \"0\");\n    //minutes\n        lminstr = minutes.toString();\n        //put padding on the minutes so that 1 m shows as :01:00.000 and not :1:00.000 when concatenated after a dividing :\n            minstr = lminstr.padStart(2, \"0\");\n\n/*\n * Build output based on largest significant populated unit\n * The general rule is to include in the output the largest unit (years, weeks, days, etc) followed by the next 2\n * smaller units if the happen to be populated\n */\n    readableduration =\"\"\n//years populated\n    if (years !== 0) { \n        if (days !== 0) {\n            if (days === 1) {\n                readableduration = \" \".concat(days.toString(), \" Day\", readableduration)\n            } else {\n                readableduration = \" \".concat(days.toString(), \" Days\", readableduration)\n            }\n        }\n        if (weeks !== 0) {\n            if (weeks === 1) {\n                readableduration = \" \".concat(weeks.toString(), \" Week\", readableduration)\n            } else {\n                readableduration = \" \".concat(weeks.toString(), \" Weeks\", readableduration)\n            }\n        }\n        if (years === 1) {\n            readableduration = years.toString().concat(\" Year\", readableduration)\n        } else {\n            readableduration = years.toString().concat(\" Years\", readableduration)\n        }\n//weeks populated\n    } else if (weeks !== 0) {\n        if (hours !== 0) {\n            if (hours === 1) {\n                readableduration = \" \".concat(hours.toString(), \" Hour\", readableduration)\n            } else {\n                readableduration = \" \".concat(hours.toString(), \" Hours\", readableduration)\n            }\n        }\n        if (days !== 0) {\n            if (weeks === 1) {\n                readableduration = \" \".concat(days.toString(), \" Day\", readableduration)\n            } else {\n                readableduration = \" \".concat(days.toString(), \" Days\", readableduration)\n            }\n        }\n        if (weeks === 1) {\n            readableduration = weeks.toString().concat(\" Week\", readableduration)\n        } else {\n            readableduration = weeks.toString().concat(\" Weeks\", readableduration)\n        }\n//days populated\n    } else if (days !== 0) {\n        if ((minutes !== 0) && (hours !== 0)) { //If both are non-zero then 1:01 format. If only 1 then either 2 hours or 1 minute\n            if (minutes !== 0) {\n                readableduration = \":\".concat(minstr, readableduration)\n            }\n            if (hours !== 0) {\n                readableduration = \" \".concat(hours.toString(), readableduration)\n            } else {\n                readableduration = \" 0\".concat(readableduration)\n            }\n        } else {\n            if (minutes === 1) {\n                readableduration = \" 1 Minute\".concat(readableduration)\n            } else if (minutes > 1) {\n                readableduration = \" \".concat(lminstr,\" Minutes\", readableduration)\n            } else if (hours === 1) {\n                readableduration = \" 1 Hour\".concat(readableduration)\n            } else {\n                if (hours >1) {\n                    readableduration = \" \".concat(hours.toString(),\" Hours\", readableduration)\n                }\n            }\n        }\n        if (days === 1) {\n            readableduration = days.toString().concat(\" Day\", readableduration)\n        } else {\n            readableduration = days.toString().concat(\" Days\", readableduration)\n        }\n//hours populated\n    } else if (hours !== 0) {\n        if ((minutes !== 0) || (seconds !== 0)) { //End result h Hours or h:mm:ss\n            readableduration = hours.toString().concat(\":\", minstr, \":\", secstr, readableduration)\n        } else {\n            if (hours === 1) {\n                readableduration = \"1 Hour\"\n            } else {\n                readableduration = hours.toString().concat(\" Hours\", readableduration)\n            }\n        }\n//minutes populated\n    } else if (minutes !== 0) { //End result m Minutes or mm:ss.MMM\n        if (seconds !== 0 || millis !== 0) { //End result h Hours or h:mm:ss\n            readableduration = lminstr.concat(\":\", secstr, \".\", millistr, readableduration)\n        } else {\n            if (minutes === 1) {\n                readableduration = \"1 Minute\".concat( readableduration)\n            } else {\n                readableduration = lminstr.concat(\" Minutes\", readableduration)\n            }\n        }\n//seconds populated\n    } else if (seconds !== 0) {\n        if (millis !== 0) { //End result s Seconds or s.MMM\n            readableduration = lsecstr.concat(\".\", millistr, \" Seconds\", readableduration)\n        } else {\n            if (seconds === 1) {\n                readableduration = \"1 Second\".concat( readableduration)\n            } else {\n                readableduration = lsecstr.concat(\" Seconds\", readableduration)\n            }\n        }\n//milliseconds populated\n    } else if (millis !== 0) {\n        if (millis !== 1) {\n            readableduration = lmillistr.concat(\" Milliseconds\", readableduration)\n        } else {\n            readableduration = \"1 Millisecond\".concat( readableduration)\n        }\n    } else {\n        readableduration = \"0\"\n    }\n    msg.years = years\n    msg.weeks = weeks\n    msg.days = days\n    msg.hours = hours\n    msg.minutes = minutes\n    msg.seconds = seconds\n    msg.millis = millis\n    msg.payload = readableduration\n    return msg;","outputs":1,"noerr":0,"x":420,"y":580,"wires":[["533989e6.19aa38"]]},{"id":"5117f3ab.9484cc","type":"switch","z":"711cdb94.5b9a04","name":"Ping Status","property":"payload","propertyType":"msg","rules":[{"t":"false"},{"t":"lt","v":"goodbad","vt":"msg"},{"t":"gte","v":"goodbad","vt":"msg"}],"checkall":"false","repair":false,"outputs":3,"x":150,"y":100,"wires":[["cd0652f2.24c1b"],["286de803.dcf568"],["3716f3a5.c360dc"]]},{"id":"45d73ffd.6779d","type":"join","z":"711cdb94.5b9a04","name":"Assemble all columns and then send to Gsheet","mode":"custom","build":"array","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"num","reduceFixup":"","x":847,"y":500,"wires":[["159589d9.1135c6"]]},{"id":"8a0a15c8.5a92d8","type":"change","z":"711cdb94.5b9a04","name":"Build Column A data","rules":[{"t":"set","p":"payload","pt":"msg","to":"Outage","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":360,"y":500,"wires":[["45d73ffd.6779d","faa029b5.b65c28"]]},{"id":"faa029b5.b65c28","type":"simpletime","z":"711cdb94.5b9a04","name":"Populate Time Messages","x":150,"y":540,"wires":[["88071c08.c524"]]},{"id":"88071c08.c524","type":"change","z":"711cdb94.5b9a04","name":"Build Date/Time for Column B","rules":[{"t":"set","p":"payload","pt":"msg","to":"myyear\t&\"-\"&\tmymonthn\t&\"-\"&\tmydom\t&\" \"&\tmyhourpm\t&\":\"&\tmyminute\t&\":\"&\tmysecond\t&\".\"&\tmymillis\t&\" \"&\tmypm","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":410,"y":540,"wires":[["45d73ffd.6779d","2a8bf2f.e6a000e"]]},{"id":"533989e6.19aa38","type":"change","z":"711cdb94.5b9a04","name":"Pass Duration for Column C and send complet to Join","rules":[{"t":"set","p":"complete","pt":"msg","to":"true","tot":"bool"}],"action":"","property":"","from":"","to":"","reg":false,"x":340,"y":620,"wires":[["45d73ffd.6779d"]]},{"id":"e6f86ef9.f3af6","type":"rbe","z":"76e3605b.0e6e7","name":"New Max?","func":"rbei","gap":"","start":"","inout":"out","property":"Max","x":850,"y":20,"wires":[["23c83a68.f57316"]]},{"id":"48434c5b.387c44","type":"rbe","z":"76e3605b.0e6e7","name":"New Min?","func":"rbei","gap":"","start":"","inout":"out","property":"Min","x":850,"y":60,"wires":[["23c83a68.f57316"]]},{"id":"f6c04470.d3df38","type":"inject","z":"2b2a4010.a6b5e","name":"Start Backup of All 4 Hubitat Hubs","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":220,"y":80,"wires":[["79bd7f0.4778b8"]]},{"id":"dae3700e.3752","type":"exec","z":"c3686304.f6d31","command":"/data/bashscripts/backup4hubitats.sh","addpay":false,"append":"","useSpawn":"false","timer":"","oldrc":false,"name":"","x":290,"y":80,"wires":[["8061cf59.05783"],[],[]]},{"id":"8061cf59.05783","type":"debug","z":"c3686304.f6d31","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":250,"y":20,"wires":[]},{"id":"2808c99d.c92d26","type":"adv ping","z":"aba876af.3a45e8","name":"Ping the passed Host","host":"","x":360,"y":100,"wires":[["5992611c.d72ca","34f3f319.96490c"]]},{"id":"67721e37.f8a89","type":"inject","z":"54cae49c.6ee04c","name":"Turn Off Pinging","topic":"","payload":"stop","payloadType":"str","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":140,"y":100,"wires":[["385c5512.c9ac4a"]]},{"id":"9d8367a6.55abe8","type":"inject","z":"54cae49c.6ee04c","name":"Start Pinging","topic":"","payload":"Ping","payloadType":"str","repeat":"","crontab":"","once":true,"onceDelay":"0","x":130,"y":60,"wires":[["385c5512.c9ac4a"]]},{"id":"81b5485a.3abc58","type":"function","z":"aba876af.3a45e8","name":"Start currentNum","func":"// check to see if the current number (currentNum is equal to the number of hosts being pinged (totalNum)\n    //when it is, reset the current number (currentNum) to the startinng number (startNum)\n    //when it is not, then increment the current number (currentNum)\n    //in both cases record the new value of the current number (currentNum) to the new value (flow.set.....)\nif (flow.get(\"currentNum\") == flow.get(\"totalNum\")){\n    flow.set(\"currentNum\", flow.get(\"startNum\"))\n}else {\n    flow.set(\"currentNum\", Number(flow.get(\"currentNum\"))+1)\n}\n/*\n*   Use the current number (cNum) as the index to get the other data for this round of pings\n*/\nvar cNum = flow.get(\"currentNum\")\n    //set ip address to be used by downstream\nmsg.host = flow.get(\"PT\"+cNum)\n    //set name to be used by downstream\nmsg.pingtarget = flow.get(\"PT\"+cNum+\"Name\")\n    //set target number to be used by downstream\nmsg.pingtargetnum = cNum\n    //set the dividing line between good and bad for the host to be pinged for use by downstream\nmsg.goodbad = flow.get(\"GoodBadPT\"+cNum)\n    //set a boolean for downstream to identify if the current target is an internet host or LAN host to be used by downstream\nmsg.internettarget = flow.get(\"InternetPT\"+cNum)\n    //show via status node which host will be pinged based on the latest output from this node\nnode.status({fill:\"green\",shape:\"dot\",text:\"Ping \"+ flow.get(\"PT\"+flow.get(\"currentNum\")+\"Name\")});\nreturn msg;\n\n/* Before refactoring\n\nif (flow.get(\"currentNum\") == flow.get(\"totalNum\")){\n    flow.set(\"currentNum\", flow.get(\"startNum\"))\n}else {\n    flow.set(\"currentNum\", Number(flow.get(\"currentNum\"))+1)\n}\nmsg.host = flow.get(\"PT\"+flow.get(\"currentNum\"))\nmsg.payload = flow.get(\"currentNum\")\nnode.status({fill:\"green\",shape:\"dot\",text:\"Ping \"+ flow.get(\"PT\"+flow.get(\"currentNum\")+\"Name\")});\nmsg.pingtarget = flow.get(\"PT\"+flow.get(\"currentNum\")+\"Name\")\nmsg.pingtargetnum = flow.get(\"currentNum\")\nmsg.goodbad = flow.get(\"GoodBadPT\"+flow.get(\"currentNum\"))\nmsg.internettarget = flow.get(\"InternetPT\"+flow.get(\"currentNum\"))\nreturn msg;\n*/","outputs":1,"noerr":0,"x":150,"y":100,"wires":[["2808c99d.c92d26"]]},{"id":"385c5512.c9ac4a","type":"trigger","z":"54cae49c.6ee04c","op1":"","op2":"0","op1type":"pay","op2type":"str","duration":"-1","extend":false,"units":"s","reset":"stop","bytopic":"all","name":"Send request every 1s unless turned off","x":460,"y":60,"wires":[["eb8fea44.7fab68"]]},{"id":"eb8fea44.7fab68","type":"subflow:aba876af.3a45e8","z":"54cae49c.6ee04c","name":"","env":[],"x":550,"y":120,"wires":[]},{"id":"3ab1249d.86543c","type":"config","z":"aba876af.3a45e8","name":"Config ping targets","properties":[{"p":"PT1Name","pt":"flow","to":"Central Services","tot":"str"},{"p":"PT1","pt":"flow","to":"192.168.86.3","tot":"str"},{"p":"PT2Name","pt":"flow","to":"Google Wifi","tot":"str"},{"p":"PT2","pt":"flow","to":"192.168.86.1","tot":"str"},{"p":"PT3Name","pt":"flow","to":"Emby","tot":"str"},{"p":"PT3","pt":"flow","to":"192.168.86.2","tot":"str"},{"p":"PT4Name","pt":"flow","to":"Lennox Themostat","tot":"str"},{"p":"PT4","pt":"flow","to":"192.168.86.101","tot":"str"},{"p":"PT5Name","pt":"flow","to":"AT&T router ","tot":"str"},{"p":"PT5","pt":"flow","to":"192.168.1.254","tot":"str"},{"p":"PT6Name","pt":"flow","to":"Cloudflare ","tot":"str"},{"p":"PT6","pt":"flow","to":"1.1.1.1","tot":"str"},{"p":"PT7Name","pt":"flow","to":"Level 3","tot":"str"},{"p":"PT7","pt":"flow","to":"4.2.2.2","tot":"str"},{"p":"PT8Name","pt":"flow","to":"Google","tot":"str"},{"p":"PT8","pt":"flow","to":"8.8.8.8","tot":"str"},{"p":"PT9Name","pt":"flow","to":"OpenDNS","tot":"str"},{"p":"PT9","pt":"flow","to":"208.67.222.222","tot":"str"},{"p":"PT10Name","pt":"flow","to":"dfw25 (near google hosted)","tot":"str"},{"p":"PT10","pt":"flow","to":"172.217.9.147","tot":"str"},{"p":"PT11Name","pt":"flow","to":"ghs.googlehosted.com","tot":"str"},{"p":"PT11","pt":"flow","to":"172.217.9.179","tot":"str"},{"p":"startNum","pt":"flow","to":"1","tot":"str"},{"p":"totalNum","pt":"flow","to":"11","tot":"str"},{"p":"currentNum","pt":"flow","to":"","tot":"str"}],"active":true,"x":110,"y":140,"wires":[],"info":"Note: by having a config node in a subflow, this sets the flow variables for when the subflow is activated. There is no way to use the click ability of a config node in a subflow, but it does do the initial population of the variable each time the subflow is triggered. In this case because the subflow is triggered via 12 different outputs, each of the 12 is a different set of the same variables."},{"id":"ae97e491.065718","type":"config","z":"aba876af.3a45e8","name":"Config Good/Bad Dividing Lines by Ping Target","properties":[{"p":"GoodBadPT1","pt":"flow","to":"1","tot":"num"},{"p":"GoodBadPT2","pt":"flow","to":"500","tot":"num"},{"p":"GoodBadPT3","pt":"flow","to":"500","tot":"num"},{"p":"GoodBadPT4","pt":"flow","to":"4500","tot":"num"},{"p":"GoodBadPT5","pt":"flow","to":"2000","tot":"num"},{"p":"GoodBadPT6","pt":"flow","to":"1000","tot":"num"},{"p":"GoodBadPT7","pt":"flow","to":"1000","tot":"num"},{"p":"GoodBadPT8","pt":"flow","to":"1000","tot":"num"},{"p":"GoodBadPT9","pt":"flow","to":"1000","tot":"num"},{"p":"GoodBadPT10","pt":"flow","to":"1000","tot":"num"},{"p":"GoodBadPT11","pt":"flow","to":"1000","tot":"num"}],"active":true,"x":200,"y":180,"wires":[],"info":"Note: by having a config node in a subflow, this sets the flow variables for when the subflow is activated. There is no way to use the click ability of a config node in a subflow, but it does do the initial population of the variable each time the subflow is triggered. In this case because the subflow is triggered via 12 different outputs, each of the 12 is a different set of the same variables."},{"id":"cc5cceb1.282c3","type":"config","z":"aba876af.3a45e8","name":"Config If Target Counts toward down Internet Tracking","properties":[{"p":"InternetPT1","pt":"flow","to":"false","tot":"bool"},{"p":"InternetPT2","pt":"flow","to":"false","tot":"bool"},{"p":"InternetPT3","pt":"flow","to":"false","tot":"bool"},{"p":"InternetPT4","pt":"flow","to":"false","tot":"bool"},{"p":"InternetPT5","pt":"flow","to":"false","tot":"bool"},{"p":"InternetPT6","pt":"flow","to":"true","tot":"bool"},{"p":"InternetPT7","pt":"flow","to":"true","tot":"bool"},{"p":"InternetPT8","pt":"flow","to":"true","tot":"bool"},{"p":"InternetPT9","pt":"flow","to":"true","tot":"bool"},{"p":"InternetPT10","pt":"flow","to":"true","tot":"bool"},{"p":"InternetPT11","pt":"flow","to":"true","tot":"bool"}],"active":true,"x":220,"y":220,"wires":[],"info":"Note: by having a config node in a subflow, this sets the flow variables for when the subflow is activated. There is no way to use the click ability of a config node in a subflow, but it does do the initial population of the variable each time the subflow is triggered. In this case because the subflow is triggered via 12 different outputs, each of the 12 is a different set of the same variables."},{"id":"8c5abc2f.833c4","type":"GSheet","z":"aba876af.3a45e8","creds":"adb4e9b8.8beee8","method":"append","action":"","sheet":"1ZKNZWvcBqLcxkkFSrV9JN-BAeXiGoGrDjepUyD-S5Cs","cells":"Sheet1!A2:J1000","name":"","x":890,"y":340,"wires":[[]]},{"id":"36301876.b0d678","type":"function","z":"aba876af.3a45e8","name":"Examine messages for Internet vs host down","func":"// Conceptually the flow is keeping track of how many down internet hosts there are per the ping results.\n// This function does 2/3rds of that process whenever it is triggered. It is triggered when the ping status node recieves a false instead of a numeric quantity from the ping result.\n// The 3 things this funtion does are:\n//      1. increment the down count\n//      2. record the time/date the down count reached 6 (which indicates that all of the internet hosts did not reply to a ping)\n//      3. set the flow variable that the internet is down\n\nif (msg.internettarget){\n    var downCount = flow.get(\"downcount\")\n    if(!isNaN(downCount)){\n        if(downCount<6){ //it would be better and more elegant to have something count the number of internet targets and pass that in, but for now it is just hardcoded to 6\n            downCount++\n            if(downCount == 6) {\n                flow.set(\"wentdownat\",Date.now())\n                flow.set(\"internetdown\", true)\n            }\n        }\n    }\n    flow.set(\"downcount\", downCount);\n    return msg;}\n    \n    /* Before refactor\n    if (msg.internettarget){\n    var downCount = flow.get(\"downcount\")\n    if(!isNaN(downCount)){\n        if(downCount<6){ //it would be better and more elegant to have something count the number of internet targets and pass that in, but for now it is just hardcoded to 6\n            downCount++\n            if(downCount == 6) {\n                flow.set(\"wentdownat\",Date.now())\n                flow.set(\"internetdown\", true)\n            }\n        }\n        \n    }\n    flow.set(\"downcount\", downCount);\n    return msg;}\n    */","outputs":1,"noerr":0,"x":670,"y":20,"wires":[[]],"info":"This Node is triggered by a ping response of false (i.e. more than 5 seconds to respond and thus either the network or the target host is offline)\n\n * gets how many consecutive times the ping has shown as down\n * sets internet down as true\n * Makes sure the down count is a number (belt and suspenders that could almost certainly be removed\n * If it is not a number than nothing happens\n * If it is, the it checks to see if the number of down responses has reached 6. The 6 is how many internet hosts are being examined. I assume that if we reach 6 then it is the internet and not just one or more of the total hosts that are down. If it is already at 6 then the system is treating the internet as down aleady and no further action is required.\n * If it is less than 6, then the count is incremented\n * If incrementing it has now made the count 6, it then records (in epoch time) the time the count went from 5 to 6.\n * Finally it saves the count back into a flow variable.\n"},{"id":"a8e0ea25.6b4598","type":"function","z":"aba876af.3a45e8","name":"Time to report outage?","func":"// Conceptually the flow is keeping track of how many down internet hosts there are per the ping results.\n// This function does 1/4th of that process whenever it is triggered. It is triggered when the ping status node recieves a  numeric quantity from the ping result.\n// The 3 things this funtion does are:\n//      1. decrement the down count\n//      2. whenever the down count reaches 0 and the internet down boolean is true, then this means the internet is back up so then:\n//          a. set internet down boolean back to false\n//          b. record the time/date it came back up\n//          c. set the boolean that it is time to write the outage (to google sheet) to true\n//      3. set the flow variable that the internet is down\n\nif (msg.internettarget){\n    var downCount = flow.get(\"downcount\")\n    var originalDownCount = downCount\n    flow.set(\"calculateandwriteoutage\",false)\n    if(!isNaN(downCount)){\n        if(downCount > 0){\n            downCount--\n            if(downCount === 0 && flow.get(\"internetdown\")) {\n                flow.set(\"internetdown\", false)\n                flow.set(\"cameupat\",Date.now())\n                flow.set(\"calculateandwriteoutage\",true)\n            }\n        }\n    }\n    flow.set(\"downcount\", downCount);\n//note a msg is passed along to the write to google portion of the flow only if the calculate and write outage boolean is true\n//by note returning a msg, that portion of the flow is otherwise not triggered\n    if(flow.get(\"calculateandwriteoutage\")){\n        return msg;\n    }\n}\n\n\n/*Before refactor\nif (msg.internettarget){\n    var downCount = flow.get(\"downcount\")\n    var originalDownCount = downCount\n    flow.set(\"calculateandwriteoutage\",false)\n    if(!isNaN(downCount)){\n        if(downCount > 0){\n            downCount--\n            if(downCount === 0 && flow.get(\"internetdown\")) {\n                flow.set(\"internetdown\", false)\n                flow.set(\"cameupat\",Date.now())\n                flow.set(\"calculateandwriteoutage\",true)\n            }\n        }\n    }\n    flow.set(\"downcount\", downCount);\n    if(flow.get(\"calculateandwriteoutage\")){\n        return msg;\n        \n    }\n}\n*/","outputs":1,"noerr":0,"x":740,"y":200,"wires":[["49386f9d.e406"]],"info":"This Node is triggered by a ping response of a number (i.e. between 1 and 4999 milliseconds for a ping response)\n\n * get how many nodes are down\n * save a copy of how many nodes are down\n * Set flow variable for whether to do a calculation and output to false by default\n * Makes sure the down count is a number (belt and suspenders that could almost certainly be removed)\n * Check if the count is greater than zero\n * If it is then decrement the count\n * check if the decremented count is 0 now and that the internetdown flag is true (this flag means the down count reached 6)\n * If it is, then the internet is up enough to then this record this as the time the internet came up and set the internetdown back to false and change the flag for whether to calculated and write the outage to Gsheet to true\n * Record the down count to the flow variable"},{"id":"e23234f9.e2e198","type":"switch","z":"aba876af.3a45e8","name":"","property":"pingtargetnum","propertyType":"msg","rules":[{"t":"eq","v":"1","vt":"str"},{"t":"eq","v":"2","vt":"str"},{"t":"eq","v":"3","vt":"str"},{"t":"eq","v":"4","vt":"str"},{"t":"eq","v":"5","vt":"str"},{"t":"eq","v":"6","vt":"str"},{"t":"eq","v":"7","vt":"str"},{"t":"eq","v":"8","vt":"str"},{"t":"eq","v":"9","vt":"str"},{"t":"eq","v":"10","vt":"str"},{"t":"eq","v":"11","vt":"str"},{"t":"eq","v":"12","vt":"str"}],"checkall":"false","repair":false,"outputs":12,"x":970,"y":100,"wires":[["3838a30d.96e3ec"],["fe23a693.782e18"],["1c3e1fb5.2eb41"],["2aa59192.460dde"],["86a51f60.f66ee"],["f5b3dcb3.7054e"],["1b3bd6d1.3f1d89"],["4192675e.f2a288"],["77eed45b.16a24c"],["f527a986.c0db98"],["7d4621ff.a0f4d"],["12c58136.35d53f"]]},{"id":"31ff04f7.29ffec","type":"function","z":"aba876af.3a45e8","name":"Calculate Duration of Outage","func":"//This function makes sure it should be doing the calculate, then calculates the duration of the outage turns of the calculate flag and sends on the duration\n//This calculation could probably be moved back to the Time to report outage? node\nif(flow.get(\"calculateandwriteoutage\")){\n    var duration = flow.get(\"cameupat\") - flow.get(\"wentdownat\")\n    flow.set(\"calculateandwriteoutage\",false)\n    msg.payload = duration\n    return msg;\n}","outputs":1,"noerr":0,"x":160,"y":380,"wires":[["a927b98b.7807d8"]]},{"id":"8fa076b9.4abe38","type":"change","z":"aba876af.3a45e8","name":"Set Ping Status Down","rules":[{"t":"set","p":"PingStatus","pt":"msg","to":"Down","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":740,"y":60,"wires":[["e23234f9.e2e198","36301876.b0d678","ffcbe690.d32758"]]},{"id":"3838a30d.96e3ec","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","x":1190,"y":20,"wires":[]},{"id":"fe23a693.782e18","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":60,"wires":[]},{"id":"1c3e1fb5.2eb41","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":100,"wires":[]},{"id":"2aa59192.460dde","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":140,"wires":[]},{"id":"86a51f60.f66ee","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":180,"wires":[]},{"id":"f5b3dcb3.7054e","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":220,"wires":[]},{"id":"1b3bd6d1.3f1d89","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":260,"wires":[]},{"id":"4192675e.f2a288","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":300,"wires":[]},{"id":"77eed45b.16a24c","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":340,"wires":[]},{"id":"f527a986.c0db98","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":380,"wires":[]},{"id":"7d4621ff.a0f4d","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1190,"y":420,"wires":[]},{"id":"12c58136.35d53f","type":"subflow:76e3605b.0e6e7","z":"aba876af.3a45e8","name":"","x":1189,"y":460,"wires":[]},{"id":"121af4fc.20aceb","type":"change","z":"aba876af.3a45e8","name":"Set Ping Status Good","rules":[{"t":"set","p":"PingStatus","pt":"msg","to":"Good","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":740,"y":100,"wires":[["e23234f9.e2e198","a8e0ea25.6b4598","d9ed9f5c.50725","ffcbe690.d32758"]]},{"id":"7eadecfd.6684c4","type":"change","z":"aba876af.3a45e8","name":"Set Ping Status Slow","rules":[{"t":"set","p":"PingStatus","pt":"msg","to":"Slow","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":740,"y":140,"wires":[["e23234f9.e2e198","a8e0ea25.6b4598","d9ed9f5c.50725","ffcbe690.d32758"]]},{"id":"a927b98b.7807d8","type":"function","z":"aba876af.3a45e8","name":"Translate Duration Function","func":"//This function translates a duration into a friendly person readable format\n/* \n * Create Variables\n * \n */\n        var milliseconds = msg.payload;\n        var years, weeks, days, hours, minutes, seconds, millis;\n    //creating 2 string versions of each of the durations that can be in the middle of a 1:01:01.001 duration \n    //minstr is the always 2 character one\n    //lminstr is the version that can be 1 or more characers that will be used when that part is the portion of the duration\n        var minstr, secstr, millistr, lminstr, lsecstr, lmillistr;\n        var whichcomponents, readableduration;\n\n/*\n * Calculate the numbers for the subcomponents\n * \n */\n    //by getting the remainder when dividing by 1000\n    //it leaves just the fraction of milliseconds\n        millis = milliseconds % 1000;\n    //the floor function drops the decimal portion\n    //returning the non fractional seconds\n        seconds = Math.floor(milliseconds / 1000);\n    //the floor function drops the decimal portion\n    //returning the non fractional minutes\n        minutes = Math.floor(seconds / 60);\n    //Once the minutes have been calculated, then\n    //the seconds is replaced with those seconds not\n    //accounted for by the minutes\n        seconds = seconds % 60;\n    //The same sequence as used for minutes/seconds\n    //then used to calulate minutes, hours, dayss, weeks, years\n\n        hours = Math.floor(minutes / 60);\n        minutes = minutes % 60;\n        days = Math.floor(hours / 24);\n        hours = hours % 24;\n        weeks = Math.floor(days / 7)\n        days = days % 7;\n        years = Math.floor(days / 365.25)\n        weeks = weeks % 52;\n\n/*\n * Put the subcomponents into msg payloads for easy access by later nodes\n *\n */\n        msg.years = years\n        msg.weeks = weeks\n        msg.days = days\n        msg.hours = hours\n        msg.minutes = minutes\n        msg.seconds = seconds\n        msg.millis = millis\n \n\n/*\n * create the string verssion for the subcomponents\n */\n    //milliseconds\n        lmillistr = millis.toString();\n        //put padding on the milliseconds so that 1 ms shows as .001 and not .1 when concatenated after a decimal\n            millistr = millis.toString().padStart(3, \"0\");\n    //seconds\n        lsecstr = seconds.toString();\n        //put padding on the seconds so that 1 s shows as :01.000 and not :1.000 when concatenated after a dividing :\n            secstr = lsecstr.padStart(2, \"0\");\n    //minutes\n        lminstr = minutes.toString();\n        //put padding on the minutes so that 1 m shows as :01:00.000 and not :1:00.000 when concatenated after a dividing :\n            minstr = lminstr.padStart(2, \"0\");\n\n/*\n * Build output based on largest significant populated unit\n * The general rule is to include in the output the largest unit (years, weeks, days, etc) followed by the next 2\n * smaller units if the happen to be populated\n */\n    readableduration =\"\"\n//years populated\n    if (years !== 0) { \n        if (days !== 0) {\n            if (days === 1) {\n                readableduration = \" \".concat(days.toString(), \" Day\", readableduration)\n            } else {\n                readableduration = \" \".concat(days.toString(), \" Days\", readableduration)\n            }\n        }\n        if (weeks !== 0) {\n            if (weeks === 1) {\n                readableduration = \" \".concat(weeks.toString(), \" Week\", readableduration)\n            } else {\n                readableduration = \" \".concat(weeks.toString(), \" Weeks\", readableduration)\n            }\n        }\n        if (years === 1) {\n            readableduration = years.toString().concat(\" Year\", readableduration)\n        } else {\n            readableduration = years.toString().concat(\" Years\", readableduration)\n        }\n//weeks populated\n    } else if (weeks !== 0) {\n        if (hours !== 0) {\n            if (hours === 1) {\n                readableduration = \" \".concat(hours.toString(), \" Hour\", readableduration)\n            } else {\n                readableduration = \" \".concat(hours.toString(), \" Hours\", readableduration)\n            }\n        }\n        if (days !== 0) {\n            if (weeks === 1) {\n                readableduration = \" \".concat(days.toString(), \" Day\", readableduration)\n            } else {\n                readableduration = \" \".concat(days.toString(), \" Days\", readableduration)\n            }\n        }\n        if (weeks === 1) {\n            readableduration = weeks.toString().concat(\" Week\", readableduration)\n        } else {\n            readableduration = weeks.toString().concat(\" Weeks\", readableduration)\n        }\n//days populated\n    } else if (days !== 0) {\n        if ((minutes !== 0) && (hours !== 0)) { //If both are non-zero then 1:01 format. If only 1 then either 2 hours or 1 minute\n            if (minutes !== 0) {\n                readableduration = \":\".concat(minstr, readableduration)\n            }\n            if (hours !== 0) {\n                readableduration = \" \".concat(hours.toString(), readableduration)\n            } else {\n                readableduration = \" 0\".concat(readableduration)\n            }\n        } else {\n            if (minutes === 1) {\n                readableduration = \" 1 Minute\".concat(readableduration)\n            } else if (minutes > 1) {\n                readableduration = \" \".concat(lminstr,\" Minutes\", readableduration)\n            } else if (hours === 1) {\n                readableduration = \" 1 Hour\".concat(readableduration)\n            } else {\n                if (hours >1) {\n                    readableduration = \" \".concat(hours.toString(),\" Hours\", readableduration)\n                }\n            }\n        }\n        if (days === 1) {\n            readableduration = days.toString().concat(\" Day\", readableduration)\n        } else {\n            readableduration = days.toString().concat(\" Days\", readableduration)\n        }\n//hours populated\n    } else if (hours !== 0) {\n        if ((minutes !== 0) || (seconds !== 0)) { //End result h Hours or h:mm:ss\n            readableduration = hours.toString().concat(\":\", minstr, \":\", secstr, readableduration)\n        } else {\n            if (hours === 1) {\n                readableduration = \"1 Hour\"\n            } else {\n                readableduration = hours.toString().concat(\" Hours\", readableduration)\n            }\n        }\n//minutes populated\n    } else if (minutes !== 0) { //End result m Minutes or mm:ss.MMM\n        if (seconds !== 0 || millis !== 0) { //End result h Hours or h:mm:ss\n            readableduration = lminstr.concat(\":\", secstr, \".\", millistr, readableduration)\n        } else {\n            if (minutes === 1) {\n                readableduration = \"1 Minute\".concat( readableduration)\n            } else {\n                readableduration = lminstr.concat(\" Minutes\", readableduration)\n            }\n        }\n//seconds populated\n    } else if (seconds !== 0) {\n        if (millis !== 0) { //End result s Seconds or s.MMM\n            readableduration = lsecstr.concat(\".\", millistr, \" Seconds\", readableduration)\n        } else {\n            if (seconds === 1) {\n                readableduration = \"1 Second\".concat( readableduration)\n            } else {\n                readableduration = lsecstr.concat(\" Seconds\", readableduration)\n            }\n        }\n//milliseconds populated\n    } else if (millis !== 0) {\n        if (millis !== 1) {\n            readableduration = lmillistr.concat(\" Milliseconds\", readableduration)\n        } else {\n            readableduration = \"1 Millisecond\".concat( readableduration)\n        }\n    } else {\n        readableduration = \"0\"\n    }\n    msg.years = years\n    msg.weeks = weeks\n    msg.days = days\n    msg.hours = hours\n    msg.minutes = minutes\n    msg.seconds = seconds\n    msg.millis = millis\n    msg.payload = readableduration\n    return msg;","outputs":1,"noerr":0,"x":420,"y":380,"wires":[["10b233e9.17db8c"]]},{"id":"5992611c.d72ca","type":"switch","z":"aba876af.3a45e8","name":"Ping Status","property":"payload","propertyType":"msg","rules":[{"t":"false"},{"t":"lt","v":"goodbad","vt":"msg"},{"t":"gte","v":"goodbad","vt":"msg"}],"checkall":"false","repair":false,"outputs":3,"x":550,"y":100,"wires":[["8fa076b9.4abe38"],["121af4fc.20aceb"],["7eadecfd.6684c4"]]},{"id":"de3cd25d.34a83","type":"join","z":"aba876af.3a45e8","name":"Assemble all columns and then send to Gsheet","mode":"custom","build":"array","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"num","reduceFixup":"","x":800,"y":280,"wires":[["8c5abc2f.833c4"]]},{"id":"49386f9d.e406","type":"change","z":"aba876af.3a45e8","name":"Build Column A data","rules":[{"t":"set","p":"payload","pt":"msg","to":"Outage","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":140,"y":280,"wires":[["de3cd25d.34a83","9aa9821b.c03f1"]]},{"id":"9aa9821b.c03f1","type":"simpletime","z":"aba876af.3a45e8","name":"Populate Time Messages","x":150,"y":340,"wires":[["7e0f855b.bdf2dc"]]},{"id":"7e0f855b.bdf2dc","type":"change","z":"aba876af.3a45e8","name":"Build Date/Time for Column B","rules":[{"t":"set","p":"payload","pt":"msg","to":"myyear\t&\"-\"&\tmymonthn\t&\"-\"&\tmydom\t&\" \"&\tmyhourpm\t&\":\"&\tmyminute\t&\":\"&\tmysecond\t&\".\"&\tmymillis\t&\" \"&\tmypm","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":410,"y":340,"wires":[["de3cd25d.34a83","31ff04f7.29ffec"]]},{"id":"10b233e9.17db8c","type":"change","z":"aba876af.3a45e8","name":"Pass Duration for Column C and send complet to Join","rules":[{"t":"set","p":"complete","pt":"msg","to":"true","tot":"bool"}],"action":"","property":"","from":"","to":"","reg":false,"x":340,"y":420,"wires":[["de3cd25d.34a83"]]},{"id":"79bd7f0.4778b8","type":"subflow:c3686304.f6d31","z":"2b2a4010.a6b5e","x":560,"y":80,"wires":[]},{"id":"4ba5918f.c183f","type":"comment","z":"54cae49c.6ee04c","name":"Ping 11 IP addresses","info":"This starts automatically but can be stopped via the Turn Off Pinging injection node.","x":140,"y":20,"wires":[]},{"id":"34f3f319.96490c","type":"function","z":"aba876af.3a45e8","name":"Format Internet UpDown for InfluxDB","func":"//This function checks if the pinged target is an internet host of local to the LAN host and then only does something for internet hosts\n//Assuming it is an internet host it creates input to be sent to the InfluxDB. This includes the hostname, IP address and 2 indicators of if the pinged target responded or not\n//At least for now both a boolean and numeric are sent as Chronograf doesn't seem to know how to handle boolean, but hopefully Grafana with discrete plugin will\nvar targetIP = msg.topic\nvar targetName = msg.pingtarget\nvar pingresult = msg.payload\nif (msg.internettarget) {\n    if (pingresult) {\n        combinedObj = [\n            {\n                Connected: true,\n                ConnectedNumeric: 1\n            },\n            {\n                TargetName: targetName,\n                TargetIPAddress: targetIP\n            }\n        ];\n    } else {\n        combinedObj = [\n            {\n                Connected: false,\n                ConnectedNumeric: 0\n            },\n            {\n                TargetName: targetName,\n                TargetIPAddress: targetIP\n            }\n        ];\n    }\n    msg.payload = combinedObj\n    return msg;\n}","outputs":1,"noerr":0,"x":430,"y":600,"wires":[["eda2c0bf.ab20c"]]},{"id":"d9ed9f5c.50725","type":"function","z":"aba876af.3a45e8","name":"Prepare Ping Duration for InfluxDB","func":"//This function creates input to be sent to the InfluxDB. This includes the hostname, IP address and the roundtrip time of the ping\nvar targetIP = msg.topic\nvar duration = msg.payload\nvar targetName = msg.pingtarget\nvar combinedObj;\ncombinedObj = [\n    {\n        RountripDuration: duration\n    },\n    {\n        TargetName: targetName,\n        TargetIPAddress: targetIP\n    }\n];\nmsg.payload = combinedObj\nreturn msg;","outputs":1,"noerr":0,"x":720,"y":520,"wires":[["eda2c0bf.ab20c"]]},{"id":"eda2c0bf.ab20c","type":"influxdb out","z":"aba876af.3a45e8","influxdb":"430b7850.44c1a8","name":"","measurement":"NetworkUptime","precision":"","retentionPolicy":"","x":1030,"y":600,"wires":[]},{"id":"a7274495.9c6ac8","type":"hubitat device","z":"b2524cfd.8c346","name":"Downstairs Thermostat Cooling Set Point","server":"55e4481a.722098","deviceId":"161","attribute":"coolingSetpoint","sendEvent":true,"x":520,"y":180,"wires":[["a3c4416d.b601"]]},{"id":"9afbda05.c15e08","type":"hubitat device","z":"b2524cfd.8c346","name":"Downstairs Thermostat Heating Set Point","server":"55e4481a.722098","deviceId":"161","attribute":"heatingSetpoint","sendEvent":true,"x":520,"y":240,"wires":[["a3c4416d.b601"]]},{"id":"d1f74ee9.2a794","type":"hubitat device","z":"b2524cfd.8c346","name":"Downstairs Thermostat Humidity","server":"55e4481a.722098","deviceId":"161","attribute":"humidity","sendEvent":true,"x":490,"y":300,"wires":[["a3c4416d.b601"]]},{"id":"a7a59bd9.aaaf68","type":"hubitat device","z":"b2524cfd.8c346","name":"Downstairs Thermostat Presence","server":"55e4481a.722098","deviceId":"161","attribute":"presence","sendEvent":true,"x":500,"y":360,"wires":[["a3c4416d.b601"]]},{"id":"91dac3cf.7e813","type":"hubitat device","z":"b2524cfd.8c346","name":"Downstairs Thermostat Temperature","server":"55e4481a.722098","deviceId":"161","attribute":"temperature","sendEvent":true,"x":510,"y":420,"wires":[["a3c4416d.b601"]]},{"id":"82985f6a.4ba06","type":"hubitat device","z":"b2524cfd.8c346","name":"Downstairs Thermostat Thermostat Fan Modes","server":"55e4481a.722098","deviceId":"161","attribute":"thermostatFanMode","sendEvent":true,"x":540,"y":540,"wires":[["a3c4416d.b601"]]},{"id":"5d26669d.6cc108","type":"hubitat device","z":"b2524cfd.8c346","name":"Downstairs Thermostat Thermostat Mode","server":"55e4481a.722098","deviceId":"161","attribute":"thermostatMode","sendEvent":true,"x":520,"y":600,"wires":[["a3c4416d.b601"]]},{"id":"ebbb7a68.1e9d28","type":"hubitat device","z":"b2524cfd.8c346","name":"Downstairs Thermostat Thermostat Operating State","server":"55e4481a.722098","deviceId":"161","attribute":"thermostatOperatingState","sendEvent":true,"x":550,"y":660,"wires":[["a3c4416d.b601"]]},{"id":"36c49701.7cdc68","type":"hubitat device","z":"b2524cfd.8c346","name":"Downstairs Thermostat Thermostat Program","server":"55e4481a.722098","deviceId":"161","attribute":"thermostatProgram","sendEvent":true,"x":530,"y":480,"wires":[["a3c4416d.b601"]]},{"id":"d783e91.39a8b18","type":"config","z":"b2524cfd.8c346","name":"Lennox Thermostat Config","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"Narrow Hall","tot":"str"},{"p":"Room","pt":"flow","to":"","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Thermostat","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Lennox","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"WiFi","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"}],"active":true,"x":180,"y":40,"wires":[]},{"id":"7c8124df.c050dc","type":"influxdb out","z":"b2524cfd.8c346","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1210,"y":80,"wires":[]},{"id":"c8be3f1a.40f2c","type":"function","z":"b2524cfd.8c346","name":"Format for InfluxDB","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node which will in turn write to the InfluxDB\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return msg;\n};","outputs":1,"noerr":0,"x":910,"y":80,"wires":[["7c8124df.c050dc","c72595c7.770458"]]},{"id":"c72595c7.770458","type":"change","z":"b2524cfd.8c346","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1250,"y":120,"wires":[[]]},{"id":"910eb892.e04458","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring the Lennox Thermostat","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":220,"y":180,"wires":[["11cd7e59.f48b12"]]},{"id":"11cd7e59.f48b12","type":"subflow:b2524cfd.8c346","z":"54cae49c.6ee04c","name":"","env":[],"x":540,"y":180,"wires":[]},{"id":"88b0711.887869","type":"comment","z":"54cae49c.6ee04c","name":"Start Device Monitoring","info":"This starts automatically but can be stopped via the Turn Off Pinging injection node.","x":140,"y":140,"wires":[]},{"id":"ffcbe690.d32758","type":"function","z":"aba876af.3a45e8","name":"Populate Status Details","func":"msg.payload = \"Latest Ping Quality: \" + msg.PingStatus + \" (\"+ msg.payload+\")\"\nreturn msg;","outputs":1,"noerr":0,"x":1070,"y":520,"wires":[[]]},{"id":"e6eaf88.d778e08","type":"hubitat device","z":"1e603513.011bdb","name":"Game Room Floor Lamp level","server":"55e4481a.722098","deviceId":"357","attribute":"level","sendEvent":true,"x":410,"y":160,"wires":[["491704e9.8d4f6c"]]},{"id":"cbe74f71.94d2a","type":"hubitat device","z":"1e603513.011bdb","name":"Game Room Floor Lamp switch","server":"55e4481a.722098","deviceId":"357","attribute":"switch","sendEvent":true,"x":410,"y":200,"wires":[["491704e9.8d4f6c"]]},{"id":"5f676cb4.46f284","type":"config","z":"1e603513.011bdb","name":"Game Room Floor Lamp Config","properties":[{"p":"Floor","pt":"flow","to":"2","tot":"str"},{"p":"Location","pt":"flow","to":"Northeast Corner","tot":"str"},{"p":"Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Bulb","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Ikea","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"}],"active":true,"x":170,"y":40,"wires":[]},{"id":"8df9584a.c81878","type":"influxdb out","z":"1e603513.011bdb","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1230,"y":40,"wires":[]},{"id":"207ab7e6.a95a28","type":"function","z":"1e603513.011bdb","name":"Format for InfluxDB","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node which will in turn write to the InfluxDB\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return msg;\n};\n","outputs":1,"noerr":0,"x":930,"y":40,"wires":[["8df9584a.c81878","3ac0f3fc.89a54c"]]},{"id":"3ac0f3fc.89a54c","type":"change","z":"1e603513.011bdb","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1270,"y":80,"wires":[[]]},{"id":"d39fcb30.32dae8","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring the Game Room Floor Lamp","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":230,"y":240,"wires":[["4234bd83.16c3e4"]]},{"id":"4234bd83.16c3e4","type":"subflow:1e603513.011bdb","z":"54cae49c.6ee04c","name":"","x":560,"y":240,"wires":[]},{"id":"4273cad9.ac63d4","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring the Aqara Button","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":200,"y":300,"wires":[["a0794888.ae50c8"]]},{"id":"a0794888.ae50c8","type":"subflow:89f52889.bf1478","z":"54cae49c.6ee04c","name":"","x":520,"y":300,"wires":[]},{"id":"e81d45c9.3c4528","type":"hubitat device","z":"89f52889.bf1478","name":"Aqara button battery","server":"55e4481a.722098","deviceId":"356","attribute":"battery","sendEvent":true,"x":440,"y":140,"wires":[["28f992dc.e36bce"]]},{"id":"f49c03c7.3ee73","type":"hubitat device","z":"89f52889.bf1478","name":"Aqara button batteryLastReplaced","server":"55e4481a.722098","deviceId":"356","attribute":"batteryLastReplaced","sendEvent":true,"x":480,"y":200,"wires":[["28f992dc.e36bce"]]},{"id":"398aa44a.de4dcc","type":"hubitat device","z":"89f52889.bf1478","name":"Aqara button buttonHeldEpoch","server":"55e4481a.722098","deviceId":"356","attribute":"buttonHeldEpoch","sendEvent":true,"x":470,"y":260,"wires":[["28f992dc.e36bce"]]},{"id":"d8c87a2b.e4adc8","type":"hubitat device","z":"89f52889.bf1478","name":"Aqara button buttonHeldTime","server":"55e4481a.722098","deviceId":"356","attribute":"buttonHeldTime","sendEvent":true,"x":460,"y":320,"wires":[["28f992dc.e36bce"]]},{"id":"6c6bcb1a.e66004","type":"hubitat device","z":"89f52889.bf1478","name":"Aqara button buttonPressedEpoch","server":"55e4481a.722098","deviceId":"356","attribute":"buttonPressedEpoch","sendEvent":true,"x":480,"y":380,"wires":[["28f992dc.e36bce"]]},{"id":"bf1bd217.b157","type":"hubitat device","z":"89f52889.bf1478","name":"Aqara button buttonReleasedEpoch","server":"55e4481a.722098","deviceId":"356","attribute":"buttonReleasedEpoch","sendEvent":true,"x":480,"y":500,"wires":[["28f992dc.e36bce"]]},{"id":"a49fb0f0.3ae13","type":"hubitat device","z":"89f52889.bf1478","name":"Aqara button buttonReleasedTime","server":"55e4481a.722098","deviceId":"356","attribute":"buttonReleasedTime","sendEvent":true,"x":480,"y":560,"wires":[["28f992dc.e36bce"]]},{"id":"67ed24f9.6aaaac","type":"hubitat device","z":"89f52889.bf1478","name":"Aqara button doubleTapped","server":"55e4481a.722098","deviceId":"356","attribute":"doubleTapped","sendEvent":true,"x":460,"y":620,"wires":[["aaa9e5fe.be54c8"]]},{"id":"699e7756.6f6748","type":"hubitat device","z":"89f52889.bf1478","name":"Aqara button buttonPressedTime","server":"55e4481a.722098","deviceId":"356","attribute":"buttonPressedTime","sendEvent":true,"x":480,"y":440,"wires":[["28f992dc.e36bce"]]},{"id":"6018b0dd.77aff","type":"config","z":"89f52889.bf1478","name":"Aqara Button Config","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"Mike Bedside","tot":"str"},{"p":"Room","pt":"flow","to":"Maste rBedroom","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Button","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Aqara","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"}],"active":true,"x":200,"y":40,"wires":[]},{"id":"b8742764.2d5438","type":"influxdb out","z":"89f52889.bf1478","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1210,"y":40,"wires":[]},{"id":"a66e16fc.5f6c98","type":"function","z":"89f52889.bf1478","name":"Format for InfluxDB","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node which will in turn write to the InfluxDB\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return msg;\n};\n","outputs":1,"noerr":0,"x":910,"y":40,"wires":[["b8742764.2d5438","653bc46e.2d853c"]]},{"id":"653bc46e.2d853c","type":"change","z":"89f52889.bf1478","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1250,"y":80,"wires":[[]]},{"id":"d2605685.bc2288","type":"hubitat device","z":"89f52889.bf1478","name":"Aqara button held","server":"55e4481a.722098","deviceId":"356","attribute":"held","sendEvent":true,"x":430,"y":680,"wires":[["aaa9e5fe.be54c8"]]},{"id":"b0133e0e.e1dbb","type":"hubitat device","z":"89f52889.bf1478","name":"Aqara button lastCheckinEpoch","server":"55e4481a.722098","deviceId":"356","attribute":"lastCheckinEpoch","sendEvent":true,"x":470,"y":740,"wires":[["aaa9e5fe.be54c8"]]},{"id":"9e3eeff8.fd2dd","type":"hubitat device","z":"89f52889.bf1478","name":"Aqara button lastCheckinTime","server":"55e4481a.722098","deviceId":"356","attribute":"lastCheckinTime","sendEvent":true,"x":470,"y":800,"wires":[["aaa9e5fe.be54c8"]]},{"id":"d232abf8.6ca7c8","type":"hubitat device","z":"89f52889.bf1478","name":"Aqara button numberOfButtons","server":"55e4481a.722098","deviceId":"356","attribute":"numberOfButtons","sendEvent":true,"x":470,"y":860,"wires":[["aaa9e5fe.be54c8"]]},{"id":"5396093.64cbdf8","type":"hubitat device","z":"89f52889.bf1478","name":"Aqara button pushed","server":"55e4481a.722098","deviceId":"356","attribute":"pushed","sendEvent":true,"x":440,"y":920,"wires":[["2501a22f.6c65ce"]]},{"id":"bf8318d1.51ed58","type":"hubitat device","z":"89f52889.bf1478","name":"Aqara button released","server":"55e4481a.722098","deviceId":"356","attribute":"released","sendEvent":true,"x":440,"y":980,"wires":[["2501a22f.6c65ce"]]},{"id":"4b143d5a.e11b54","type":"hubitat command","z":"98a6e865.a02ea8","name":"Mike Bedside","server":"55e4481a.722098","deviceId":"257","command":"","commandArgs":"","x":820,"y":60,"wires":[[]]},{"id":"53de30cb.5a905","type":"hubitat device","z":"98a6e865.a02ea8","name":"Mike Bedside Currently?","server":"55e4481a.722098","deviceId":"257","attribute":"switch","sendEvent":false,"x":370,"y":60,"wires":[["8c38df2a.5984b"]]},{"id":"8c38df2a.5984b","type":"switch","z":"98a6e865.a02ea8","name":"Off/On","property":"payload.value","propertyType":"msg","rules":[{"t":"eq","v":"off","vt":"str"},{"t":"eq","v":"on","vt":"str"}],"checkall":"true","repair":false,"outputs":2,"x":550,"y":60,"wires":[["91cf3e9c.c1ae1"],["349ff253.9b9a7e"]]},{"id":"91cf3e9c.c1ae1","type":"change","z":"98a6e865.a02ea8","name":"On","rules":[{"t":"set","p":"command","pt":"msg","to":"on","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":670,"y":40,"wires":[["4b143d5a.e11b54"]]},{"id":"349ff253.9b9a7e","type":"change","z":"98a6e865.a02ea8","name":"Off","rules":[{"t":"set","p":"command","pt":"msg","to":"off","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":670,"y":80,"wires":[["4b143d5a.e11b54"]]},{"id":"323994d.e2eaa6c","type":"hubitat device","z":"98a6e865.a02ea8","name":"Aqara button pushed","server":"55e4481a.722098","deviceId":"356","attribute":"pushed","sendEvent":true,"x":120,"y":60,"wires":[["53de30cb.5a905"]]},{"id":"d430a9c7.458158","type":"comment","z":"98a6e865.a02ea8","name":"Push of Aqara button toggles the switch controlling Mike's beside lamp","info":"","x":270,"y":20,"wires":[]},{"id":"d548f87d.290958","type":"hubitat device","z":"4e2f0c22.b816c4","name":"Corner switch","server":"55e4481a.722098","deviceId":"100","attribute":"switch","sendEvent":true,"x":480,"y":140,"wires":[["377e26bc.c06f7a"]]},{"id":"a4714ecb.018c9","type":"config","z":"4e2f0c22.b816c4","name":"Corner Lamp IKEA Switch Config","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"Northeast Corner","tot":"str"},{"p":"Room","pt":"flow","to":"Living Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"IKEA","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"}],"active":true,"x":180,"y":40,"wires":[]},{"id":"1baf2031.e1a73","type":"influxdb out","z":"4e2f0c22.b816c4","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1170,"y":40,"wires":[]},{"id":"af938420.ebd6d8","type":"function","z":"4e2f0c22.b816c4","name":"Format for InfluxDB","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node which will in turn write to the InfluxDB\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return msg;\n};\n","outputs":1,"noerr":0,"x":870,"y":40,"wires":[["1baf2031.e1a73","f161e413.59a918"]]},{"id":"f161e413.59a918","type":"change","z":"4e2f0c22.b816c4","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1210,"y":80,"wires":[[]]},{"id":"e4b7ca11.ec1708","type":"subflow:4e2f0c22.b816c4","z":"54cae49c.6ee04c","name":"","x":510,"y":360,"wires":[]},{"id":"5dab24aa.6e314c","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring the Corner Lamp","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":200,"y":360,"wires":[["e4b7ca11.ec1708"]]},{"id":"5afc38b5.219b88","type":"config","z":"5364e86b.44e3a8","name":"Office Echo Config","properties":[{"p":"Floor","pt":"flow","to":"2","tot":"str"},{"p":"Location","pt":"flow","to":"Mike's Desk","tot":"str"},{"p":"Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Echo","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Amazon","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"}],"active":true,"x":130,"y":40,"wires":[]},{"id":"2506ee82.8e0622","type":"influxdb out","z":"5364e86b.44e3a8","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1210,"y":40,"wires":[]},{"id":"fc3bc907.8605b8","type":"function","z":"5364e86b.44e3a8","name":"Format for InfluxDB","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node which will in turn write to the InfluxDB\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return msg;\n};\n","outputs":1,"noerr":0,"x":910,"y":40,"wires":[["2506ee82.8e0622","8bb600f1.44256"]]},{"id":"8bb600f1.44256","type":"change","z":"5364e86b.44e3a8","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1230,"y":80,"wires":[[]]},{"id":"bf25eb2f.4b6838","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Alarm Volume","server":"55e4481a.722098","deviceId":"321","attribute":"","sendEvent":true,"x":360,"y":160,"wires":[["afde47f8.f056d8"]]},{"id":"43e8c6e4.28e978","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Alexa Playlists JSON","server":"55e4481a.722098","deviceId":"321","attribute":"alexaPlaylists","sendEvent":true,"x":380,"y":1400,"wires":[["31262558.ccab2a"]]},{"id":"f71eae73.2385a","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Audio Track Data JSON","server":"55e4481a.722098","deviceId":"321","attribute":"audioTrackData","sendEvent":true,"x":390,"y":1440,"wires":[["31262558.ccab2a"]]},{"id":"690ba9bc.922b28","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Bluetooth Device Connected","server":"55e4481a.722098","deviceId":"321","attribute":"btDeviceConnected","sendEvent":true,"x":400,"y":240,"wires":[["afde47f8.f056d8"]]},{"id":"c94902ae.ef4be","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Bluetooth Devices Paired JSON","server":"55e4481a.722098","deviceId":"321","attribute":"","sendEvent":true,"x":410,"y":1480,"wires":[["31262558.ccab2a"]]},{"id":"49e54bd4.057c54","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Current Album","server":"55e4481a.722098","deviceId":"321","attribute":"currentAlbum","sendEvent":true,"x":360,"y":280,"wires":[["6027de94.3da19"]]},{"id":"c1d4d483.2fe698","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Current Station","server":"55e4481a.722098","deviceId":"321","attribute":"currentStation","sendEvent":true,"x":360,"y":320,"wires":[["6027de94.3da19"]]},{"id":"ef6bf2ce.c4e77","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Device Family","server":"55e4481a.722098","deviceId":"321","attribute":"deviceFamily","sendEvent":true,"x":360,"y":360,"wires":[["6027de94.3da19"]]},{"id":"90d3717d.47ad3","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Device Status","server":"55e4481a.722098","deviceId":"321","attribute":"deviceStatus","sendEvent":true,"x":360,"y":400,"wires":[["6027de94.3da19"]]},{"id":"fc15e907.5e94a8","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Device Style","server":"55e4481a.722098","deviceId":"321","attribute":"deviceStyle","sendEvent":true,"x":350,"y":440,"wires":[["6027de94.3da19"]]},{"id":"99928feb.0eb1","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Device Type","server":"55e4481a.722098","deviceId":"321","attribute":"deviceType","sendEvent":true,"x":350,"y":480,"wires":[["6027de94.3da19"]]},{"id":"d8a8737a.85a67","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Do Not Disturb","server":"55e4481a.722098","deviceId":"321","attribute":"doNotDisturb","sendEvent":true,"x":360,"y":520,"wires":[["6027de94.3da19"]]},{"id":"428a9a08.1e01d4","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Firmware Version","server":"55e4481a.722098","deviceId":"321","attribute":"firmwareVer","sendEvent":true,"x":370,"y":560,"wires":[["6027de94.3da19"]]},{"id":"3aa08941.c9b9e6","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Followup Mode","server":"55e4481a.722098","deviceId":"321","attribute":"followUpMode","sendEvent":true,"x":360,"y":600,"wires":[["6027de94.3da19"]]},{"id":"7930c202.bca9ec","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Last Command Sent Date","server":"55e4481a.722098","deviceId":"321","attribute":"lastCmdSentDt","sendEvent":true,"x":400,"y":640,"wires":[["6027de94.3da19"]]},{"id":"b11a57e5.636088","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Last Speak Command","server":"55e4481a.722098","deviceId":"321","attribute":"lastSpeakCmd","sendEvent":true,"x":380,"y":680,"wires":[["ebcb834.d2a3a8"]]},{"id":"8d561c8b.6c848","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Last Spoken To Time","server":"55e4481a.722098","deviceId":"321","attribute":"lastSpokenToTime","sendEvent":true,"x":380,"y":720,"wires":[["ebcb834.d2a3a8"]]},{"id":"1a59c7c.d1ec838","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Last Updated","server":"55e4481a.722098","deviceId":"321","attribute":"lastUpdated","sendEvent":true,"x":360,"y":760,"wires":[["ebcb834.d2a3a8"]]},{"id":"39c0336b.2e2b8c","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Last Voice Activity","server":"55e4481a.722098","deviceId":"321","attribute":"lastVoiceActivity","sendEvent":true,"x":370,"y":800,"wires":[["ebcb834.d2a3a8"]]},{"id":"423202f5.6d31ac","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Level","server":"55e4481a.722098","deviceId":"321","attribute":"level","sendEvent":true,"x":330,"y":840,"wires":[["3506c761.e6a318"]]},{"id":"9ae515c2.934e48","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Media Source","server":"55e4481a.722098","deviceId":"321","attribute":"mediaSource","sendEvent":true,"x":360,"y":880,"wires":[["3506c761.e6a318"]]},{"id":"7fed2f4e.f4bb3","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Mute","server":"55e4481a.722098","deviceId":"321","attribute":"mute","sendEvent":true,"x":330,"y":920,"wires":[["3506c761.e6a318"]]},{"id":"39b8e1f7.3e140e","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Online Status","server":"55e4481a.722098","deviceId":"321","attribute":"onlineStatus","sendEvent":true,"x":360,"y":960,"wires":[["3506c761.e6a318"]]},{"id":"1966c63e.dff24a","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Permissions","server":"55e4481a.722098","deviceId":"321","attribute":"permissions","sendEvent":true,"x":350,"y":1000,"wires":[["3506c761.e6a318"]]},{"id":"b3574d27.5f9db","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Status","server":"55e4481a.722098","deviceId":"321","attribute":"status","sendEvent":true,"x":340,"y":1040,"wires":[["3506c761.e6a318"]]},{"id":"b11d6a36.a84ac8","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Supported Music","server":"55e4481a.722098","deviceId":"321","attribute":"supportedMusic","sendEvent":true,"x":370,"y":1080,"wires":[["3506c761.e6a318"]]},{"id":"e07203c4.8fd9b","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Track Data","server":"55e4481a.722098","deviceId":"321","attribute":"trackData","sendEvent":true,"x":350,"y":1520,"wires":[["f82d697d.2c2fa8"]]},{"id":"83328fa5.386b2","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Track Description","server":"55e4481a.722098","deviceId":"321","attribute":"trackDescription","sendEvent":true,"x":370,"y":1120,"wires":[["3506c761.e6a318"]]},{"id":"e0b7ff08.0dcdc","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Track Image","server":"55e4481a.722098","deviceId":"321","attribute":"trackImage","sendEvent":true,"x":350,"y":1160,"wires":[["c11947fb.7455d8"]]},{"id":"1b5224f2.93792b","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Track Image Html","server":"55e4481a.722098","deviceId":"321","attribute":"trackImageHtml","sendEvent":true,"x":370,"y":1200,"wires":[["c11947fb.7455d8"]]},{"id":"5ac48542.e781fc","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Volume","server":"55e4481a.722098","deviceId":"321","attribute":"volume","sendEvent":true,"x":340,"y":1240,"wires":[["c11947fb.7455d8"]]},{"id":"1526ccaa.4b74b3","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Alexa Wake Words","server":"55e4481a.722098","deviceId":"321","attribute":"alexaWakeWord","sendEvent":true,"x":370,"y":200,"wires":[["afde47f8.f056d8"]]},{"id":"22ea5eda.ed7722","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Was Last Spoken To Device","server":"55e4481a.722098","deviceId":"321","attribute":"wasLastSpokenToDevice","sendEvent":true,"x":400,"y":1320,"wires":[["c11947fb.7455d8"]]},{"id":"24665828.313d18","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Wifi Network","server":"55e4481a.722098","deviceId":"321","attribute":"wifiNetwork","sendEvent":true,"x":350,"y":1360,"wires":[["31262558.ccab2a"]]},{"id":"edda98a4.1fbae8","type":"hubitat device","z":"5364e86b.44e3a8","name":"Echo - Office Wake Words","server":"55e4481a.722098","deviceId":"321","attribute":"wakeWords","sendEvent":true,"x":360,"y":1280,"wires":[["c11947fb.7455d8"]]},{"id":"48244b14.f15d04","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring the Office Echo","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":190,"y":420,"wires":[["7b090cc0.2299f4"]]},{"id":"7b090cc0.2299f4","type":"subflow:5364e86b.44e3a8","z":"54cae49c.6ee04c","name":"","x":510,"y":420,"wires":[]},{"id":"c2484670.ff6178","type":"link out","z":"5364e86b.44e3a8","name":"Passthrough to enable subflow","links":["694310aa.24b6e","b88e99f7.bf3308","d6ea4559.a9e278","92f18ff9.97d71","da26393c.a17d28","67e8465f.17c138","327fcb20.315534"],"x":210,"y":80,"wires":[],"l":true},{"id":"694310aa.24b6e","type":"link in","z":"5364e86b.44e3a8","name":"From Input","links":["c2484670.ff6178"],"x":120,"y":160,"wires":[["bf25eb2f.4b6838","1526ccaa.4b74b3","690ba9bc.922b28","49e54bd4.057c54","c1d4d483.2fe698","ef6bf2ce.c4e77","90d3717d.47ad3","fc15e907.5e94a8","99928feb.0eb1","d8a8737a.85a67","428a9a08.1e01d4","3aa08941.c9b9e6"]],"l":true},{"id":"d6ea4559.a9e278","type":"link in","z":"5364e86b.44e3a8","name":"From Input","links":["c2484670.ff6178"],"x":120,"y":640,"wires":[["7930c202.bca9ec","b11a57e5.636088","8d561c8b.6c848","1a59c7c.d1ec838","39c0336b.2e2b8c","423202f5.6d31ac","9ae515c2.934e48","7fed2f4e.f4bb3","39b8e1f7.3e140e","1966c63e.dff24a","b3574d27.5f9db","b11d6a36.a84ac8","83328fa5.386b2","e0b7ff08.0dcdc","1b5224f2.93792b"]],"l":true},{"id":"67e8465f.17c138","type":"link in","z":"5364e86b.44e3a8","name":"From Input","links":["c2484670.ff6178"],"x":120,"y":1240,"wires":[["5ac48542.e781fc","edda98a4.1fbae8","22ea5eda.ed7722","24665828.313d18","43e8c6e4.28e978","f71eae73.2385a","c94902ae.ef4be","e07203c4.8fd9b"]],"l":true},{"id":"adb2bdd.7f92f4","type":"link in","z":"5364e86b.44e3a8","name":"Send to InfluxDB","links":["c11947fb.7455d8","ebcb834.d2a3a8","6027de94.3da19","afde47f8.f056d8","3506c761.e6a318","31262558.ccab2a","f82d697d.2c2fa8"],"x":500,"y":40,"wires":[["a9946eba.c74ee"]],"l":true},{"id":"c11947fb.7455d8","type":"link out","z":"5364e86b.44e3a8","name":"Gather to Send to InfluxDB","links":["adb2bdd.7f92f4"],"x":800,"y":1160,"wires":[],"l":true},{"id":"ebcb834.d2a3a8","type":"link out","z":"5364e86b.44e3a8","name":"Gather to Send to InfluxDB","links":["adb2bdd.7f92f4"],"x":800,"y":680,"wires":[],"l":true},{"id":"6027de94.3da19","type":"link out","z":"5364e86b.44e3a8","name":"Gather to Send to InfluxDB","links":["adb2bdd.7f92f4"],"x":800,"y":280,"wires":[],"l":true},{"id":"e7028df7.05f37","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Mike's Bedside Lamp","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":210,"y":480,"wires":[["3e399597.2a03ca"]]},{"id":"eb0c463e.de05b8","type":"config","z":"ae851807.40c0e8","name":"Mike Bedside Config","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"Southeast Corner","tot":"str"},{"p":"Room","pt":"flow","to":"Master Bedroom","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Wemo","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"}],"active":true,"x":160,"y":40,"wires":[]},{"id":"985ccc13.04932","type":"influxdb out","z":"ae851807.40c0e8","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1190,"y":40,"wires":[]},{"id":"5ef9bc5b.f32634","type":"function","z":"ae851807.40c0e8","name":"Format for InfluxDB","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node which will in turn write to the InfluxDB\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return msg;\n};\n","outputs":1,"noerr":0,"x":890,"y":40,"wires":[["985ccc13.04932","190b5fc0.438e"]]},{"id":"190b5fc0.438e","type":"change","z":"ae851807.40c0e8","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1230,"y":80,"wires":[[]]},{"id":"716cee6d.caeff","type":"hubitat device","z":"ae851807.40c0e8","name":"Mike Bedside switch","server":"55e4481a.722098","deviceId":"257","attribute":"switch","sendEvent":true,"x":300,"y":180,"wires":[["64b0a2fd.b82a1c"]]},{"id":"c7c61ee1.9dfe9","type":"link out","z":"ae851807.40c0e8","name":"Passthrough to enable subflow","links":["f7a5cb73.bf0668","b319e707.413b48","87b30f86.964ff","b5d38503.3d1c58","af17333b.402a1","bca1623.11908a","1396a56f.840d8b"],"x":230,"y":80,"wires":[],"l":true},{"id":"f7a5cb73.bf0668","type":"link in","z":"ae851807.40c0e8","name":"From Input","links":["c7c61ee1.9dfe9"],"x":120,"y":180,"wires":[["716cee6d.caeff"]],"l":true},{"id":"9f6b0d0e.cff9c","type":"link in","z":"ae851807.40c0e8","name":"Send to InfluxDB","links":["436be19f.e8b36","5955230b.51edec","64b0a2fd.b82a1c"],"x":480,"y":40,"wires":[["e0cf241e.5c4588"]],"l":true},{"id":"64b0a2fd.b82a1c","type":"link out","z":"ae851807.40c0e8","name":"Gather to Send to InfluxDB","links":["9f6b0d0e.cff9c"],"x":540,"y":180,"wires":[],"l":true},{"id":"3e399597.2a03ca","type":"subflow:ae851807.40c0e8","z":"54cae49c.6ee04c","name":"","x":540,"y":480,"wires":[]},{"id":"9f7a8094.d603f","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Mike's Credenza Light","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":210,"y":540,"wires":[["a0381fce.df712"]]},{"id":"e6762905.751918","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Table Lamp","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":180,"y":600,"wires":[["3d6974e2.28673c"]]},{"id":"725c13ac.01ad5c","type":"config","z":"92d72719.56bd38","name":"Mike Credenza Light Config","properties":[{"p":"Floor","pt":"flow","to":"2","tot":"str"},{"p":"Location","pt":"flow","to":"Mike's Desk","tot":"str"},{"p":"Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"IKEA","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"}],"active":true,"x":160,"y":40,"wires":[]},{"id":"828e5d03.e0a87","type":"influxdb out","z":"92d72719.56bd38","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1170,"y":40,"wires":[]},{"id":"8c881af9.27d018","type":"function","z":"92d72719.56bd38","name":"Format for InfluxDB","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node which will in turn write to the InfluxDB\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return msg;\n};\n","outputs":1,"noerr":0,"x":870,"y":40,"wires":[["828e5d03.e0a87","cf90206.f18cae"]]},{"id":"cf90206.f18cae","type":"change","z":"92d72719.56bd38","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1210,"y":80,"wires":[[]]},{"id":"7bc527f7.ed3938","type":"hubitat device","z":"92d72719.56bd38","name":"Mike Credenza Light switch","server":"55e4481a.722098","deviceId":"388","attribute":"switch","sendEvent":true,"x":360,"y":240,"wires":[["54bbce35.4e1e2"]]},{"id":"8bb21bf9.9058f8","type":"link out","z":"92d72719.56bd38","name":"Passthrough to enable subflow","links":["fe56b81c.45a158"],"x":210,"y":80,"wires":[],"l":true},{"id":"fe56b81c.45a158","type":"link in","z":"92d72719.56bd38","name":"From Input","links":["8bb21bf9.9058f8"],"x":120,"y":240,"wires":[["7bc527f7.ed3938"]],"l":true},{"id":"b0bc3d8b.008d","type":"link in","z":"92d72719.56bd38","name":"Send to InfluxDB","links":["54bbce35.4e1e2"],"x":460,"y":40,"wires":[["5e0f03d2.a6dbfc"]],"l":true},{"id":"54bbce35.4e1e2","type":"link out","z":"92d72719.56bd38","name":"Gather to Send to InfluxDB","links":["b0bc3d8b.008d"],"x":620,"y":240,"wires":[],"l":true},{"id":"a0381fce.df712","type":"subflow:92d72719.56bd38","z":"54cae49c.6ee04c","name":"","x":540,"y":540,"wires":[]},{"id":"3bdac541.4f5bfa","type":"config","z":"fd34e084.87e19","name":"Table Lamp Config","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"North Side","tot":"str"},{"p":"Room","pt":"flow","to":"Living Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Bulb","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"TP-Link","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"}],"active":true,"x":130,"y":40,"wires":[]},{"id":"27a535fa.fb546a","type":"influxdb out","z":"fd34e084.87e19","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1170,"y":40,"wires":[]},{"id":"48cf5caa.1874e4","type":"function","z":"fd34e084.87e19","name":"Format for InfluxDB","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node which will in turn write to the InfluxDB\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return msg;\n};\n","outputs":1,"noerr":0,"x":870,"y":40,"wires":[["27a535fa.fb546a","2c849688.b10c4a"]]},{"id":"2c849688.b10c4a","type":"change","z":"fd34e084.87e19","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1210,"y":80,"wires":[[]]},{"id":"2b16c09f.8f5a7","type":"hubitat device","z":"fd34e084.87e19","name":"Table Lamp commsError","server":"55e4481a.722098","deviceId":"225","attribute":"commsError","sendEvent":true,"x":350,"y":240,"wires":[["b83bc91d.ad0158"]]},{"id":"c4868b86.653628","type":"link out","z":"fd34e084.87e19","name":"Passthrough to enable subflow","links":["739a3338.a0857c"],"x":210,"y":80,"wires":[],"l":true},{"id":"739a3338.a0857c","type":"link in","z":"fd34e084.87e19","name":"From Input","links":["c4868b86.653628"],"x":120,"y":240,"wires":[["2b16c09f.8f5a7","ee5635fb.d01708","b6febe81.42d9a"]],"l":true},{"id":"45137fe4.da261","type":"link in","z":"fd34e084.87e19","name":"Send to InfluxDB","links":["b83bc91d.ad0158"],"x":460,"y":40,"wires":[["8ccd32e5.c587f"]],"l":true},{"id":"b83bc91d.ad0158","type":"link out","z":"fd34e084.87e19","name":"Gather to Send to InfluxDB","links":["45137fe4.da261"],"x":640,"y":240,"wires":[],"l":true},{"id":"ee5635fb.d01708","type":"hubitat device","z":"fd34e084.87e19","name":"Table Lamp level","server":"55e4481a.722098","deviceId":"225","attribute":"level","sendEvent":true,"x":330,"y":280,"wires":[["b83bc91d.ad0158"]]},{"id":"b6febe81.42d9a","type":"hubitat device","z":"fd34e084.87e19","name":"Table Lamp switch","server":"55e4481a.722098","deviceId":"225","attribute":"switch","sendEvent":true,"x":330,"y":320,"wires":[["b83bc91d.ad0158"]]},{"id":"3d6974e2.28673c","type":"subflow:fd34e084.87e19","z":"54cae49c.6ee04c","name":"","env":[],"x":510,"y":600,"wires":[]},{"id":"afde47f8.f056d8","type":"link out","z":"5364e86b.44e3a8","name":"Gather to Send to InfluxDB","links":["adb2bdd.7f92f4"],"x":800,"y":160,"wires":[],"l":true},{"id":"3506c761.e6a318","type":"link out","z":"5364e86b.44e3a8","name":"Gather to Send to InfluxDB","links":["adb2bdd.7f92f4"],"x":800,"y":840,"wires":[],"l":true},{"id":"31262558.ccab2a","type":"link out","z":"5364e86b.44e3a8","name":"Gather to Send to InfluxDB","links":["adb2bdd.7f92f4"],"x":780,"y":1360,"wires":[],"l":true},{"id":"427dc421.8d781c","type":"link out","z":"4e2f0c22.b816c4","name":"Passthrough to enable subflow","links":["e7935525.398708"],"x":190,"y":80,"wires":[],"l":true},{"id":"377e26bc.c06f7a","type":"link out","z":"4e2f0c22.b816c4","name":"Gather to Send to InfluxDB","links":["adeebefa.595b9"],"x":840,"y":140,"wires":[],"l":true},{"id":"e7935525.398708","type":"link in","z":"4e2f0c22.b816c4","name":"From Input","links":["427dc421.8d781c"],"x":160,"y":140,"wires":[["d548f87d.290958"]],"l":true},{"id":"adeebefa.595b9","type":"link in","z":"4e2f0c22.b816c4","name":"Send to InfluxDB","links":["377e26bc.c06f7a"],"x":460,"y":40,"wires":[["6f819c50.8d9204"]],"l":true},{"id":"6ccdb89c.8350f8","type":"link out","z":"89f52889.bf1478","name":"Passthrough to enable subflow","links":["1fe20b58.99d435","98e0ed70.2f8a2"],"x":230,"y":80,"wires":[],"l":true},{"id":"1fe20b58.99d435","type":"link in","z":"89f52889.bf1478","name":"From Input","links":["6ccdb89c.8350f8"],"x":120,"y":140,"wires":[["e81d45c9.3c4528","f49c03c7.3ee73","398aa44a.de4dcc","d8c87a2b.e4adc8","6c6bcb1a.e66004","699e7756.6f6748","bf1bd217.b157","a49fb0f0.3ae13","67ed24f9.6aaaac","d2605685.bc2288","b0133e0e.e1dbb"]],"l":true},{"id":"591d8855.0ae688","type":"link in","z":"89f52889.bf1478","name":"Send to InfluxDB","links":["28f992dc.e36bce","aaa9e5fe.be54c8","2501a22f.6c65ce"],"x":500,"y":40,"wires":[["805045fa.94f318"]],"l":true},{"id":"28f992dc.e36bce","type":"link out","z":"89f52889.bf1478","name":"Gather to Send to InfluxDB","links":["591d8855.0ae688"],"x":860,"y":140,"wires":[],"l":true},{"id":"aaa9e5fe.be54c8","type":"link out","z":"89f52889.bf1478","name":"Gather to Send to InfluxDB","links":["591d8855.0ae688"],"x":860,"y":620,"wires":[],"l":true},{"id":"98e0ed70.2f8a2","type":"link in","z":"89f52889.bf1478","name":"From Input","links":["6ccdb89c.8350f8"],"x":140,"y":800,"wires":[["9e3eeff8.fd2dd","d232abf8.6ca7c8","5396093.64cbdf8","bf8318d1.51ed58"]],"l":true},{"id":"2501a22f.6c65ce","type":"link out","z":"89f52889.bf1478","name":"Gather to Send to InfluxDB","links":["591d8855.0ae688"],"x":860,"y":920,"wires":[],"l":true},{"id":"3ddaf972.6b39b6","type":"link out","z":"1e603513.011bdb","name":"Passthrough to enable subflow","links":["d1bbb554.6ee968"],"x":230,"y":80,"wires":[],"l":true},{"id":"d1bbb554.6ee968","type":"link in","z":"1e603513.011bdb","name":"From Input","links":["3ddaf972.6b39b6"],"x":140,"y":160,"wires":[["e6eaf88.d778e08","cbe74f71.94d2a"]],"l":true},{"id":"ecc79c01.6084a","type":"link in","z":"1e603513.011bdb","name":"Send to InfluxDB","links":["491704e9.8d4f6c"],"x":520,"y":40,"wires":[["c82f747a.8bded8"]],"l":true},{"id":"491704e9.8d4f6c","type":"link out","z":"1e603513.011bdb","name":"Gather to Send to InfluxDB","links":["ecc79c01.6084a"],"x":820,"y":160,"wires":[],"l":true},{"id":"f902dc8c.c0f5","type":"link out","z":"b2524cfd.8c346","name":"Passthrough to enable subflow","links":["74ab94b8.e95e8c"],"x":210,"y":80,"wires":[],"l":true},{"id":"74ab94b8.e95e8c","type":"link in","z":"b2524cfd.8c346","name":"From Input","links":["f902dc8c.c0f5"],"x":120,"y":180,"wires":[["a7274495.9c6ac8","9afbda05.c15e08","d1f74ee9.2a794","a7a59bd9.aaaf68","91dac3cf.7e813","36c49701.7cdc68","82985f6a.4ba06","5d26669d.6cc108","ebbb7a68.1e9d28"]],"l":true},{"id":"61c33dd9.72a304","type":"link in","z":"b2524cfd.8c346","name":"Send to InfluxDB","links":["a3c4416d.b601"],"x":500,"y":80,"wires":[["431b4185.0978a"]],"l":true},{"id":"a3c4416d.b601","type":"link out","z":"b2524cfd.8c346","name":"Gather to Send to InfluxDB","links":["61c33dd9.72a304"],"x":1000,"y":180,"wires":[],"l":true},{"id":"f5d8d551.ede008","type":"config","z":"e58eb536.40cf18","name":"Mike iPad Config","properties":[{"p":"Floor","pt":"flow","to":"","tot":"str"},{"p":"Location","pt":"flow","to":"","tot":"str"},{"p":"Room","pt":"flow","to":"","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Tablet","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Apple","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"}],"active":true,"x":130,"y":40,"wires":[]},{"id":"2dc21.a965c3df6","type":"influxdb out","z":"e58eb536.40cf18","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1170,"y":40,"wires":[]},{"id":"67f9a724.dfafc8","type":"function","z":"e58eb536.40cf18","name":"Format for InfluxDB","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node which will in turn write to the InfluxDB\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return msg;\n};\n","outputs":1,"noerr":0,"x":870,"y":40,"wires":[["2dc21.a965c3df6","7f324c1.08e51b4"]]},{"id":"7f324c1.08e51b4","type":"change","z":"e58eb536.40cf18","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1210,"y":80,"wires":[[]]},{"id":"8e7397dd.63d4d8","type":"hubitat device","z":"e58eb536.40cf18","name":"Mike's iPad notification Text","server":"55e4481a.722098","deviceId":"129","attribute":"notificationText","sendEvent":true,"x":360,"y":240,"wires":[["b1aa9e10.607bc"]]},{"id":"e52e72d9.77dbd","type":"link out","z":"e58eb536.40cf18","name":"Passthrough to enable subflow","links":["c370db50.96a6a8"],"x":210,"y":80,"wires":[],"l":true},{"id":"c370db50.96a6a8","type":"link in","z":"e58eb536.40cf18","name":"From Input","links":["e52e72d9.77dbd"],"x":120,"y":240,"wires":[["8e7397dd.63d4d8","a1e244e0.5c8358"]],"l":true},{"id":"7ad30ab9.a08d44","type":"link in","z":"e58eb536.40cf18","name":"Send to InfluxDB","links":["b1aa9e10.607bc"],"x":460,"y":40,"wires":[["e517bc6f.c6b07"]],"l":true},{"id":"b1aa9e10.607bc","type":"link out","z":"e58eb536.40cf18","name":"Gather to Send to InfluxDB","links":["7ad30ab9.a08d44"],"x":660,"y":240,"wires":[],"l":true},{"id":"a1e244e0.5c8358","type":"hubitat device","z":"e58eb536.40cf18","name":"Mike's iPad presence","server":"55e4481a.722098","deviceId":"129","attribute":"presence","sendEvent":true,"x":340,"y":280,"wires":[["b1aa9e10.607bc"]]},{"id":"21dc7bb1.3018c4","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Mike's iPad","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":180,"y":660,"wires":[["4382ab65.32d5c4"]]},{"id":"4382ab65.32d5c4","type":"subflow:e58eb536.40cf18","z":"54cae49c.6ee04c","name":"","x":510,"y":660,"wires":[]},{"id":"b220b27f.74863","type":"config","z":"390b8414.317d5c","name":"Mike Watch Uverse","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"TV Cabinet","tot":"str"},{"p":"Room","pt":"flow","to":"Living Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Harmony Activity","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Logitech","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"WIFI","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Virtual","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"}],"active":true,"x":130,"y":40,"wires":[]},{"id":"c66e8dba.e2b98","type":"influxdb out","z":"390b8414.317d5c","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1170,"y":40,"wires":[]},{"id":"9951a7da.a5f268","type":"function","z":"390b8414.317d5c","name":"Format for InfluxDB","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node which will in turn write to the InfluxDB\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return msg;\n};\n","outputs":1,"noerr":0,"x":870,"y":40,"wires":[["c66e8dba.e2b98","e41ff176.5dc96"]]},{"id":"e41ff176.5dc96","type":"change","z":"390b8414.317d5c","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1210,"y":80,"wires":[[]]},{"id":"69b18c2a.9616a4","type":"hubitat device","z":"390b8414.317d5c","name":"Watch Uverse switch","server":"55e4481a.722098","deviceId":"262","attribute":"switch","sendEvent":true,"x":340,"y":240,"wires":[["5b1f1ef2.33108"]]},{"id":"85febe11.1b0c4","type":"link out","z":"390b8414.317d5c","name":"Passthrough to enable subflow","links":["2e04bd85.69eeb2"],"x":210,"y":80,"wires":[],"l":true},{"id":"2e04bd85.69eeb2","type":"link in","z":"390b8414.317d5c","name":"From Input","links":["85febe11.1b0c4"],"x":120,"y":240,"wires":[["69b18c2a.9616a4"]],"l":true},{"id":"ddca54d.4009aa8","type":"link in","z":"390b8414.317d5c","name":"Send to InfluxDB","links":["5b1f1ef2.33108"],"x":460,"y":40,"wires":[["1a8414e7.a2d95b"]],"l":true},{"id":"5b1f1ef2.33108","type":"link out","z":"390b8414.317d5c","name":"Gather to Send to InfluxDB","links":["ddca54d.4009aa8"],"x":660,"y":240,"wires":[],"l":true},{"id":"4cda22a0.3e144c","type":"config","z":"9d03767a.9b0288","name":"Master Fan Config","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"North","tot":"str"},{"p":"Room","pt":"flow","to":"Master Bedroom","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"GE/Jasco","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Z-Wave","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"}],"active":true,"x":130,"y":40,"wires":[]},{"id":"b65b1212.fbcd","type":"influxdb out","z":"9d03767a.9b0288","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1170,"y":40,"wires":[]},{"id":"b214f491.795de8","type":"function","z":"9d03767a.9b0288","name":"Format for InfluxDB","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node which will in turn write to the InfluxDB\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return msg;\n};\n","outputs":1,"noerr":0,"x":870,"y":40,"wires":[["b65b1212.fbcd","ab3cb55f.3b66e8"]]},{"id":"ab3cb55f.3b66e8","type":"change","z":"9d03767a.9b0288","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1210,"y":80,"wires":[[]]},{"id":"83492f35.3f7b5","type":"hubitat device","z":"9d03767a.9b0288","name":"Master Fan double Tapped","server":"55e4481a.722098","deviceId":"65","attribute":"doubleTapped","sendEvent":true,"x":360,"y":240,"wires":[["a77c2f86.c3de8"]]},{"id":"2cf48409.d5206c","type":"link out","z":"9d03767a.9b0288","name":"Passthrough to enable subflow","links":["85367e55.91cef"],"x":210,"y":80,"wires":[],"l":true},{"id":"85367e55.91cef","type":"link in","z":"9d03767a.9b0288","name":"From Input","links":["2cf48409.d5206c"],"x":120,"y":240,"wires":[["83492f35.3f7b5","edf5c557.fe1908","4a2a99c5.a3d5c8","feae96e2.fa5298","5213d1cd.dcf55","bca1b620.7cacc8"]],"l":true},{"id":"e17fce91.99404","type":"link in","z":"9d03767a.9b0288","name":"Send to InfluxDB","links":["a77c2f86.c3de8","a4b882d4.0cdf1"],"x":460,"y":40,"wires":[["880f4eef.b124"]],"l":true},{"id":"a77c2f86.c3de8","type":"link out","z":"9d03767a.9b0288","name":"Gather to Send to InfluxDB","links":["e17fce91.99404"],"x":660,"y":240,"wires":[],"l":true},{"id":"edf5c557.fe1908","type":"hubitat device","z":"9d03767a.9b0288","name":"Master Fan level","server":"55e4481a.722098","deviceId":"65","attribute":"level","sendEvent":true,"x":320,"y":280,"wires":[["a77c2f86.c3de8"]]},{"id":"4a2a99c5.a3d5c8","type":"hubitat device","z":"9d03767a.9b0288","name":"Master Fan number Of Buttons","server":"55e4481a.722098","deviceId":"65","attribute":"numberOfButtons","sendEvent":true,"x":370,"y":320,"wires":[["a77c2f86.c3de8"]]},{"id":"feae96e2.fa5298","type":"hubitat device","z":"9d03767a.9b0288","name":"Master Fan pushed","server":"55e4481a.722098","deviceId":"65","attribute":"pushed","sendEvent":true,"x":330,"y":360,"wires":[["a4b882d4.0cdf1"]]},{"id":"5213d1cd.dcf55","type":"hubitat device","z":"9d03767a.9b0288","name":"Master Fan speed","server":"55e4481a.722098","deviceId":"65","attribute":"speed","sendEvent":true,"x":330,"y":400,"wires":[["a4b882d4.0cdf1"]]},{"id":"bca1b620.7cacc8","type":"hubitat device","z":"9d03767a.9b0288","name":"Master Fan switch","server":"55e4481a.722098","deviceId":"65","attribute":"switch","sendEvent":true,"x":330,"y":440,"wires":[["a4b882d4.0cdf1"]]},{"id":"a4b882d4.0cdf1","type":"link out","z":"9d03767a.9b0288","name":"Gather to Send to InfluxDB","links":["e17fce91.99404"],"x":660,"y":360,"wires":[],"l":true},{"id":"bbe4778d.717418","type":"hubitat device","z":"f6aca0d2.59336","name":"Master Light Overhead switch","server":"55e4481a.722098","deviceId":"33","attribute":"switch","sendEvent":true,"x":370,"y":360,"wires":[["84a32ed6.63e07"]]},{"id":"3358554c.1795aa","type":"config","z":"f6aca0d2.59336","name":"Master Light Config","properties":[{"p":"Floor","pt":"flow","to":"1","tot":"str"},{"p":"Location","pt":"flow","to":"North","tot":"str"},{"p":"Room","pt":"flow","to":"Master Bedroom","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Switch","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"GE/Jasco","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Z-Wave","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"}],"active":true,"x":130,"y":40,"wires":[]},{"id":"a3105257.b5593","type":"influxdb out","z":"f6aca0d2.59336","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1170,"y":40,"wires":[]},{"id":"c3a4c2a8.1576a","type":"function","z":"f6aca0d2.59336","name":"Format for InfluxDB","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node which will in turn write to the InfluxDB\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return msg;\n};\n","outputs":1,"noerr":0,"x":870,"y":40,"wires":[["a3105257.b5593","faada734.3761a8"]]},{"id":"faada734.3761a8","type":"change","z":"f6aca0d2.59336","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1210,"y":80,"wires":[[]]},{"id":"edb80da9.7530f","type":"hubitat device","z":"f6aca0d2.59336","name":"Master Light Overhead double Tapped","server":"55e4481a.722098","deviceId":"33","attribute":"doubleTapped","sendEvent":true,"x":390,"y":240,"wires":[["c119142f.cb8b98"]]},{"id":"5170d88d.798268","type":"link out","z":"f6aca0d2.59336","name":"Passthrough to enable subflow","links":["b8b14809.3ad568"],"x":210,"y":80,"wires":[],"l":true},{"id":"b8b14809.3ad568","type":"link in","z":"f6aca0d2.59336","name":"From Input","links":["5170d88d.798268"],"x":120,"y":240,"wires":[["edb80da9.7530f","540a3df7.a62c74","d0dbfc8b.c0639","bbe4778d.717418"]],"l":true},{"id":"6e6e650f.f0941c","type":"link in","z":"f6aca0d2.59336","name":"Send to InfluxDB","links":["c119142f.cb8b98","84a32ed6.63e07"],"x":460,"y":40,"wires":[["82225621.d06838"]],"l":true},{"id":"c119142f.cb8b98","type":"link out","z":"f6aca0d2.59336","name":"Gather to Send to InfluxDB","links":["6e6e650f.f0941c"],"x":740,"y":240,"wires":[],"l":true},{"id":"540a3df7.a62c74","type":"hubitat device","z":"f6aca0d2.59336","name":"Master Light Overhead number Of Buttons","server":"55e4481a.722098","deviceId":"33","attribute":"numberOfButtons","sendEvent":true,"x":410,"y":280,"wires":[["c119142f.cb8b98"]]},{"id":"d0dbfc8b.c0639","type":"hubitat device","z":"f6aca0d2.59336","name":"Master Light Overhead pushed","server":"55e4481a.722098","deviceId":"33","attribute":"pushed","sendEvent":true,"x":370,"y":320,"wires":[["84a32ed6.63e07"]]},{"id":"84a32ed6.63e07","type":"link out","z":"f6aca0d2.59336","name":"Gather to Send to InfluxDB","links":["6e6e650f.f0941c"],"x":740,"y":320,"wires":[],"l":true},{"id":"2a26cc26.73d424","type":"config","z":"d2615560.b868a8","name":"Cube 1 Config","properties":[{"p":"Floor","pt":"flow","to":"2","tot":"str"},{"p":"Location","pt":"flow","to":"Mike's Desk","tot":"str"},{"p":"Room","pt":"flow","to":"Game Room","tot":"str"},{"p":"DeviceType","pt":"flow","to":"Cube","tot":"str"},{"p":"Manufacturer","pt":"flow","to":"Aqara","tot":"str"},{"p":"AccessProtocol","pt":"flow","to":"Zigbee","tot":"str"},{"p":"PhysicalVirtualType","pt":"flow","to":"Physical","tot":"str"},{"p":"PhysicalDigitalRegular","pt":"flow","to":"","tot":"str"},{"p":"House","pt":"flow","to":"Ashmont","tot":"str"}],"active":true,"x":120,"y":40,"wires":[]},{"id":"94009e86.51c0e","type":"influxdb out","z":"d2615560.b868a8","influxdb":"b862b36a.1a11d","name":"","measurement":"Smarthome","precision":"","retentionPolicy":"","x":1170,"y":40,"wires":[]},{"id":"8dd02668.5e87b8","type":"function","z":"d2615560.b868a8","name":"Format for InfluxDB","func":"/* This function takes input from a hubitat device node and data stored in config node which holds details about the device\n * and creates an properly formated object to be sent to InfluxDB node which will in turn write to the InfluxDB\n * \n * \n */\n//gather the name of the device which had a reading that triggered the flow to be included as a tag (index) sent to InfluxDB\n//note: this is the hubitat device ID\nvar deviceID = msg.payload.deviceId;\n\n//gather the name of the measurement that was sent by the device to be included as a tag (index) for invalid measurements and as the fieldname for valid measurements sent to InfluxDB\nvar typeOfMeasurement = msg.payload.name;\n\n//gather the actual measurement value that was sent by the device to be included as the data for the field (when the measurement is valid) sent to InfluxDB\nvar theData = msg.payload.value;\n\n//initialize the measurements object\nvar measurementsObj = {};\n\n//initialize the tags (indices) object\nvar tagsObj = {};\n\n//create the object that will later be used to combine the measurementsObj and tagsObj\nvar combinedObj;\n\n//create the boolean that will be used to hold the evaluation of whether the measurement is valid or not\nvar validMeasurement;\n\n//create the booleans that will be used to hold whether the reason a measurement is invalid is because it is a non-standard type or\n// if the type of the measurement and the type passed from the device differ or\n// if the value (data) is null\nvar nonStandardType = false;\nvar measurementTypeMismatch = false;\nvar nullData = false;\n\n//create a boolean to keep track of if there are any tags (indices) that should be sent to the InfluxDB \n// it starts false but if any tag is valid then will become true. See below for what to send to InfluxDB based on valid measures and tags\nvar validTag = false;\n\n\n\nif ((typeof theData == msg.payload.dataType.toLowerCase()) || (msg.payload.dataType == 'ENUM') || (theData === null)) {\n    if (typeof theData == 'number') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched number\" });\n\n        if (!theData.isNaN) {\n            validMeasurement = true;\n        }\n    } else if (typeof theData == 'string') {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched string\" });\n        if (theData.length >= 0) {\n            validMeasurement = true;\n        }\n    } else if (msg.payload.dataType == 'ENUM') { //This is checking to make sure the value matches one of the values in the ENUM from the device \n        node.status({ fill: \"red\", shape: \"ring\", text: msg.payload.dataType + \" matched ENUM\" });\n\n        msg.payload.values.forEach(element => {\n            if (flow.get(element) == theData) {\n                validMeasurement = true;\n            }\n        })\n    } else if (theData === null) {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched null data\" });\n        nullData = true;\n    } else {\n        node.status({ fill: \"red\", shape: \"ring\", text: \"matched nonstandardtype\" });\n        nonStandardType = true;\n    }\n} else {\n    node.status({ fill: \"red\", shape: \"ring\", text: \"measurement type mismatch\" });\n    measurementTypeMismatch = true;\n}\n\n\n\n\n\n//scanning all of the tags from the config node and creating a tag for that item if the entry on the config node has info\ncommonTags = [\"House\", \"Floor\", \"Room\", \"Location\", \"DeviceType\", \"Manufacturer\", \"AccessProtocol\", \"PhysicalVirtualType\", \"PhysicalDigitalRegular\"]\ncommonTags.forEach(element => {\n    if (flow.get(element).length > 0) {\n        tagsObj[element] = flow.get(element)\n        validTag = true\n    }\n});\n\n//Based on whether or not the measurement is \"valid\" it either adds the device id to the tags or it goes to the else portion\nif (validMeasurement) {\n    measurementsObj[typeOfMeasurement] = theData;\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID;\n        validTag = true;\n    }\n    if (validTag) {\n        combinedObj = [measurementsObj, tagsObj]\n    } else {\n        //skip tags if none would be valid\n        combinedObj = [measurementsObj]\n    }\n} else {\n\n    //if the measeurement was not \"valid\", then it puts in a Generic measurement of true and tag it as either Non-Standard Type of Measurement Type Mismatch\n    if (nonStandardType) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Non-Standard Type\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    if (measurementTypeMismatch) {\n        measurementsObj[\"Generic\"] = true\n        tagsObj[\"ReasonGeneric\"] = \"Measurement Type Mismatch\"\n        tagsObj[\"Measure\"] = typeOfMeasurement\n    }\n    if (deviceID.length > 0) {\n        tagsObj[\"DeviceID\"] = deviceID\n        validTag = true\n    }\n    combinedObj = [measurementsObj, tagsObj]\n}\n\n//put the object into the payload\nmsg.payload = combinedObj;\n\n//build the status to be shown on the status of the subnode\nmsg.status = typeOfMeasurement + \": \" + theData;\n\n//send the created combinedObj downstream (to the InfluxDB node), but only if the measurement is not null\nif (!nullData) {\n    return msg;\n};\n","outputs":1,"noerr":0,"x":870,"y":40,"wires":[["94009e86.51c0e","d559f199.3d317"]]},{"id":"d559f199.3d317","type":"change","z":"d2615560.b868a8","name":"Move Status to Payload for Consumption by Status Node","rules":[{"t":"set","p":"payload","pt":"msg","to":"status","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1210,"y":80,"wires":[[]]},{"id":"4ccd4829.3c99f8","type":"hubitat device","z":"d2615560.b868a8","name":"Cube 1 angle","server":"55e4481a.722098","deviceId":"360","attribute":"angle","sendEvent":true,"x":310,"y":160,"wires":[["826a0842.643058"]]},{"id":"bec0b04e.e9c99","type":"link out","z":"d2615560.b868a8","name":"Passthrough to enable subflow","links":["fbb03213.7fb68"],"x":210,"y":80,"wires":[],"l":true},{"id":"fbb03213.7fb68","type":"link in","z":"d2615560.b868a8","name":"From Input","links":["bec0b04e.e9c99"],"x":120,"y":160,"wires":[["4ccd4829.3c99f8","3eda457f.06a33a","f93c6c50.3039a","f636ba63.abaa48","c5302f94.b0cc","1cb79660.457c9a","c35ec035.eecbb","48ffc52e.e4f93c","48a06786.b9ae48"]],"l":true},{"id":"59292639.59e498","type":"link in","z":"d2615560.b868a8","name":"Send to InfluxDB","links":["826a0842.643058","cab50e7b.3eeb2","abf5b2a7.c1a6d"],"x":460,"y":40,"wires":[["eaa835c1.1fa838"]],"l":true},{"id":"826a0842.643058","type":"link out","z":"d2615560.b868a8","name":"Gather to Send to InfluxDB","links":["59292639.59e498"],"x":740,"y":160,"wires":[],"l":true},{"id":"cab50e7b.3eeb2","type":"link out","z":"d2615560.b868a8","name":"Gather to Send to InfluxDB","links":["59292639.59e498"],"x":740,"y":280,"wires":[],"l":true},{"id":"3eda457f.06a33a","type":"hubitat device","z":"d2615560.b868a8","name":"Cube 1 battery","server":"55e4481a.722098","deviceId":"360","attribute":"battery","sendEvent":true,"x":320,"y":200,"wires":[["826a0842.643058"]]},{"id":"f93c6c50.3039a","type":"hubitat device","z":"d2615560.b868a8","name":"Cube 1 battery Last Replaced","server":"55e4481a.722098","deviceId":"360","attribute":"batteryLastReplaced","sendEvent":true,"x":370,"y":240,"wires":[["826a0842.643058"]]},{"id":"f636ba63.abaa48","type":"hubitat device","z":"d2615560.b868a8","name":"Cube 1 face","server":"55e4481a.722098","deviceId":"360","attribute":"face","sendEvent":true,"x":310,"y":280,"wires":[["cab50e7b.3eeb2"]]},{"id":"c5302f94.b0cc","type":"hubitat device","z":"d2615560.b868a8","name":"Cube 1 last Checkin Epoch","server":"55e4481a.722098","deviceId":"360","attribute":"lastCheckinEpoch","sendEvent":true,"x":360,"y":320,"wires":[["cab50e7b.3eeb2"]]},{"id":"1cb79660.457c9a","type":"hubitat device","z":"d2615560.b868a8","name":"Cube 1 last Checkin Time","server":"55e4481a.722098","deviceId":"360","attribute":"lastCheckinTime","sendEvent":true,"x":350,"y":360,"wires":[["cab50e7b.3eeb2"]]},{"id":"c35ec035.eecbb","type":"hubitat device","z":"d2615560.b868a8","name":"Cube 1 number of Buttons","server":"55e4481a.722098","deviceId":"360","attribute":"numberOfButtons","sendEvent":true,"x":350,"y":400,"wires":[["cab50e7b.3eeb2"]]},{"id":"48ffc52e.e4f93c","type":"hubitat device","z":"d2615560.b868a8","name":"Cube 1 pushed","server":"55e4481a.722098","deviceId":"360","attribute":"pushed","sendEvent":true,"x":320,"y":440,"wires":[["abf5b2a7.c1a6d"]]},{"id":"48a06786.b9ae48","type":"hubitat device","z":"d2615560.b868a8","name":"Cube 1 three Axis","server":"55e4481a.722098","deviceId":"360","attribute":"threeAxis","sendEvent":true,"x":330,"y":480,"wires":[["abf5b2a7.c1a6d"]]},{"id":"abf5b2a7.c1a6d","type":"link out","z":"d2615560.b868a8","name":"Gather to Send to InfluxDB","links":["59292639.59e498"],"x":740,"y":440,"wires":[],"l":true},{"id":"4a287e32.ab679","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Watch Uverse","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":190,"y":720,"wires":[["aab73ad2.720dd8"]]},{"id":"6420300d.1687a","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Master Fan","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":180,"y":780,"wires":[["36caa5b4.f40baa"]]},{"id":"59cc8cf0.2fdf04","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Light Overhead","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":190,"y":840,"wires":[["c5668637.28d518"]]},{"id":"9a75b54f.97b8d8","type":"inject","z":"54cae49c.6ee04c","name":"Start Monitoring Cube 1","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":170,"y":900,"wires":[["bacfddc1.92e44"]]},{"id":"aab73ad2.720dd8","type":"subflow:390b8414.317d5c","z":"54cae49c.6ee04c","name":"","x":520,"y":720,"wires":[]},{"id":"36caa5b4.f40baa","type":"subflow:9d03767a.9b0288","z":"54cae49c.6ee04c","name":"","x":510,"y":780,"wires":[]},{"id":"c5668637.28d518","type":"subflow:f6aca0d2.59336","z":"54cae49c.6ee04c","name":"","x":520,"y":840,"wires":[]},{"id":"bacfddc1.92e44","type":"subflow:d2615560.b868a8","z":"54cae49c.6ee04c","name":"","x":500,"y":900,"wires":[]},{"id":"a9946eba.c74ee","type":"function","z":"5364e86b.44e3a8","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":700,"y":40,"wires":[["fc3bc907.8605b8"]]},{"id":"f82d697d.2c2fa8","type":"link out","z":"5364e86b.44e3a8","name":"Gather to Send to InfluxDB","links":["adb2bdd.7f92f4"],"x":780,"y":1520,"wires":[],"l":true},{"id":"431b4185.0978a","type":"function","z":"b2524cfd.8c346","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":700,"y":80,"wires":[["c8be3f1a.40f2c"]]},{"id":"c82f747a.8bded8","type":"function","z":"1e603513.011bdb","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":720,"y":40,"wires":[["207ab7e6.a95a28"]]},{"id":"805045fa.94f318","type":"function","z":"89f52889.bf1478","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":700,"y":40,"wires":[["a66e16fc.5f6c98"]]},{"id":"6f819c50.8d9204","type":"function","z":"4e2f0c22.b816c4","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":660,"y":40,"wires":[["af938420.ebd6d8"]]},{"id":"e0cf241e.5c4588","type":"function","z":"ae851807.40c0e8","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":680,"y":40,"wires":[["5ef9bc5b.f32634"]]},{"id":"5e0f03d2.a6dbfc","type":"function","z":"92d72719.56bd38","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":660,"y":40,"wires":[["8c881af9.27d018"]]},{"id":"8ccd32e5.c587f","type":"function","z":"fd34e084.87e19","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":660,"y":40,"wires":[["48cf5caa.1874e4"]]},{"id":"e517bc6f.c6b07","type":"function","z":"e58eb536.40cf18","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":660,"y":40,"wires":[["67f9a724.dfafc8"]]},{"id":"1a8414e7.a2d95b","type":"function","z":"390b8414.317d5c","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":660,"y":40,"wires":[["9951a7da.a5f268"]]},{"id":"880f4eef.b124","type":"function","z":"9d03767a.9b0288","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":660,"y":40,"wires":[["b214f491.795de8"]]},{"id":"82225621.d06838","type":"function","z":"f6aca0d2.59336","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":660,"y":40,"wires":[["c3a4c2a8.1576a"]]},{"id":"eaa835c1.1fa838","type":"function","z":"d2615560.b868a8","name":"JSON Preprocessor","func":"/*\n * Main function node code \n * \n */\n//Check if there is any data. If not, stop processing. At the time this was created, the trackData sent from a Hubitat Elevation device node was always null\nif (msg.payload.value === null) {\n    return null;\n}\n//make downstream troubleshooting easier by removing the deprecated currentValue if it exists\ndelete msg.payload.currentValue;\n//send the msg to the recursive function\nSplitJSON(msg)\n//return nothing as any valid messages are send via node.send in the recursive function\nreturn;\n\n/*\n *The recursive function that takes in a msg and if it is JSON, sends out multiple msgs each with the msg.dataType STRING, the JSON key concatenated\n * to the msg.name and the JSON value moved to the msg.value.\n * \n * This is a recursive function so if the JSON value is more JSON, then it will decompose it as well.\n */\nfunction SplitJSON(latestMsg) {\n    //Only evaluate objects labelled as JSON Object\n    if (latestMsg.payload.dataType == 'JSON_OBJECT') {\n        //make sure the messages value is valid JSON and contains a colon (:)\n        //The check for a colon is that a string like \"example\" is \"valid\" JSON, but this function assumes the JSON is made up of key:value pairs\n        if ((IsValidJSONString(latestMsg.payload.value)) && (latestMsg.payload.value.includes(\":\"))) {\n            //turn the message value inot an array of key:value pairs\n            var valueJSON = JSON.parse(latestMsg.payload.value);\n            //set aside the original name to become the leading part of the concatenation\n            var name = msg.payload.name;\n            // Loop through the arry of ke:value pairs\n            Object.keys(valueJSON).forEach(function (key) {\n                //concatenate the original name, a colon and the key from the pair\n                latestMsg.payload.name = name + \":\" + key;\n                //move the value from the pair to payload.value\n                latestMsg.payload.value = valueJSON[key];\n                //recursively call this function in case the value is itself JSON\n                SplitJSON(latestMsg)\n            })\n        } else {\n            //Since the dataType was labelled as JSON_OBJECT even though it was not made up of key:value pairs, then changed the type to STRING and sent it along\n            //This is encountered both if the initial input is mislabelled, but more often from the recursive call to this function\n            latestMsg.payload.dataType = \"STRING\"\n            node.send(latestMsg);\n        }\n    } else {\n        //This node is only for JSON splitting so if the object type is something else, then it just passes along the input\n        node.send(latestMsg);\n    }\n}\n\n/*\n * This function was found on the internet to check if an input is valid JSON\n * There seems to be a belief that there should be some more elegant method that trying parse and the catching the error,\n * but no one seems to have demonstrated what that more elegant way would be\n */\nfunction IsValidJSONString(str) {\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}","outputs":1,"noerr":0,"x":660,"y":40,"wires":[["8dd02668.5e87b8"]]},{"id":"6946ae88.732c6","type":"hubitat device","z":"ba901384.9c229","name":"Master Light Overhead","server":"55e4481a.722098","deviceId":"33","attribute":"doubleTapped","sendEvent":true,"x":120,"y":60,"wires":[["ee5b8cbd.d0bd5","e23f0b0e.9cc3c8","72259207.bf918c"]]},{"id":"e23f0b0e.9cc3c8","type":"debug","z":"ba901384.9c229","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":430,"y":80,"wires":[]},{"id":"ee5b8cbd.d0bd5","type":"debug","z":"ba901384.9c229","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":410,"y":20,"wires":[]},{"id":"72259207.bf918c","type":"hubitat command","z":"ba901384.9c229","name":"Table Lamp","server":"55e4481a.722098","deviceId":"225","command":"setLevel","commandArgs":"10,0","x":360,"y":180,"wires":[[]]},{"id":"48280e6.4b5f8f","type":"hubitat command","z":"ba901384.9c229","name":"Gtest G means Off","server":"55e4481a.722098","deviceId":"643","command":"on","commandArgs":"","x":290,"y":480,"wires":[[]]},{"id":"c9f6059f.e379f8","type":"hubitat command","z":"ba901384.9c229","name":"Mike Credenza Light","server":"55e4481a.722098","deviceId":"388","command":"on","commandArgs":"","x":300,"y":540,"wires":[[]]},{"id":"e8b687a1.a42138","type":"hubitat command","z":"ba901384.9c229","name":"Game Room Floor Lamp","server":"55e4481a.722098","deviceId":"357","command":"on","commandArgs":"","x":310,"y":600,"wires":[[]]},{"id":"500c0a87.ae1054","type":"hubitat command","z":"ba901384.9c229","name":"Office Desk Lamp","server":"55e4481a.722098","deviceId":"550","command":"on","commandArgs":"","x":290,"y":660,"wires":[[]]},{"id":"b6b2303f.101b","type":"hubitat command","z":"ba901384.9c229","name":"Gtest Gdev Means On","server":"55e4481a.722098","deviceId":"642","command":"on","commandArgs":"","x":300,"y":420,"wires":[[]]},{"id":"aaa0339f.cdded","type":"hubitat command","z":"ba901384.9c229","name":"Gtest No GDev","server":"55e4481a.722098","deviceId":"641","command":"on","commandArgs":"","x":280,"y":360,"wires":[[]]},{"id":"f87d4745.b81a38","type":"inject","z":"ba901384.9c229","name":"On","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":90,"y":360,"wires":[["aaa0339f.cdded"]]},{"id":"9df82d1c.36624","type":"inject","z":"ba901384.9c229","name":"On","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":90,"y":420,"wires":[["b6b2303f.101b"]]},{"id":"9c9af3ef.6f736","type":"inject","z":"ba901384.9c229","name":"On","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":90,"y":480,"wires":[["48280e6.4b5f8f"]]},{"id":"56aab2b0.3a2edc","type":"inject","z":"ba901384.9c229","name":"On","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":90,"y":540,"wires":[["c9f6059f.e379f8"]]},{"id":"93590ab3.3f04e8","type":"inject","z":"ba901384.9c229","name":"On","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":90,"y":600,"wires":[["e8b687a1.a42138"]]},{"id":"18ad49bb.a479a6","type":"inject","z":"ba901384.9c229","name":"On","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":90,"y":660,"wires":[["500c0a87.ae1054"]]},{"id":"200f6f58.d6c3d","type":"hubitat device","z":"ba901384.9c229","name":"Gtest No GDev","server":"55e4481a.722098","deviceId":"641","attribute":"switch","sendEvent":true,"x":1080,"y":360,"wires":[["212b934f.1dc90c"]]},{"id":"147578c5.a0eea7","type":"hubitat device","z":"ba901384.9c229","name":"Gtest Gdev Means On","server":"55e4481a.722098","deviceId":"642","attribute":"switch","sendEvent":true,"x":1100,"y":420,"wires":[["212b934f.1dc90c"]]},{"id":"866808c.99164f8","type":"hubitat device","z":"ba901384.9c229","name":"Gtest G means Off","server":"55e4481a.722098","deviceId":"643","attribute":"switch","sendEvent":true,"x":1090,"y":480,"wires":[["212b934f.1dc90c"]]},{"id":"5188f00d.25866","type":"hubitat device","z":"ba901384.9c229","name":"Mike Credenza Light","server":"55e4481a.722098","deviceId":"388","attribute":"switch","sendEvent":true,"x":1100,"y":540,"wires":[["212b934f.1dc90c"]]},{"id":"212b934f.1dc90c","type":"debug","z":"ba901384.9c229","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":1390,"y":520,"wires":[]},{"id":"9bf8d69c.f7b118","type":"hubitat device","z":"ba901384.9c229","name":"Game Room Floor Lamp","server":"55e4481a.722098","deviceId":"357","attribute":"switch","sendEvent":true,"x":1110,"y":600,"wires":[["212b934f.1dc90c"]]},{"id":"4b466402.b3558c","type":"hubitat device","z":"ba901384.9c229","name":"Office Desk Lamp","server":"55e4481a.722098","deviceId":"550","attribute":"switch","sendEvent":true,"x":1090,"y":660,"wires":[["212b934f.1dc90c"]]},{"id":"dbc5b992.333ab8","type":"hubitat command","z":"ba901384.9c229","name":"Gtest G means Off","server":"55e4481a.722098","deviceId":"643","command":"off","commandArgs":"","x":790,"y":480,"wires":[[]]},{"id":"3da8e023.86b37","type":"hubitat command","z":"ba901384.9c229","name":"Mike Credenza Light","server":"55e4481a.722098","deviceId":"388","command":"off","commandArgs":"","x":800,"y":540,"wires":[[]]},{"id":"8c313ad5.2bef78","type":"hubitat command","z":"ba901384.9c229","name":"Game Room Floor Lamp","server":"55e4481a.722098","deviceId":"357","command":"off","commandArgs":"","x":810,"y":600,"wires":[[]]},{"id":"1f061d5e.203863","type":"hubitat command","z":"ba901384.9c229","name":"Office Desk Lamp","server":"55e4481a.722098","deviceId":"550","command":"off","commandArgs":"","x":790,"y":660,"wires":[[]]},{"id":"7eaf27db.b1e468","type":"hubitat command","z":"ba901384.9c229","name":"Gtest Gdev Means On","server":"55e4481a.722098","deviceId":"642","command":"off","commandArgs":"","x":800,"y":420,"wires":[[]]},{"id":"db856b74.7d3d08","type":"hubitat command","z":"ba901384.9c229","name":"Gtest No GDev","server":"55e4481a.722098","deviceId":"641","command":"off","commandArgs":"","x":780,"y":360,"wires":[[]]},{"id":"ff3158b4.375c18","type":"inject","z":"ba901384.9c229","name":"Off","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":590,"y":360,"wires":[["db856b74.7d3d08"]]},{"id":"b93c45f.44382b8","type":"inject","z":"ba901384.9c229","name":"Off","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":590,"y":420,"wires":[["7eaf27db.b1e468"]]},{"id":"71cad30b.5ea08c","type":"inject","z":"ba901384.9c229","name":"Off","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":590,"y":480,"wires":[["dbc5b992.333ab8"]]},{"id":"d3ad3954.147928","type":"inject","z":"ba901384.9c229","name":"Off","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":590,"y":540,"wires":[["3da8e023.86b37"]]},{"id":"1bdcad74.5a4fa3","type":"inject","z":"ba901384.9c229","name":"Off","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":590,"y":600,"wires":[["8c313ad5.2bef78"]]},{"id":"4f5fa70f.0d4e78","type":"inject","z":"ba901384.9c229","name":"Off","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":590,"y":660,"wires":[["1f061d5e.203863"]]},{"id":"db5d9766.57c9f8","type":"inject","z":"1a0aa13a.9d7b8f","name":"Initiate Check every 5 sec","topic":"","payload":"1","payloadType":"num","repeat":"5","crontab":"","once":true,"onceDelay":0.1,"x":180,"y":100,"wires":[["da8cbc87.ae3a5"]]},{"id":"de53fc38.e8dfb","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Start/Restart","group":"18f340fe.a70a3f","order":1,"width":3,"height":1,"passthru":false,"label":"Start/Restart","tooltip":"","color":"","bgcolor":"Green","icon":"","payload":"1","payloadType":"num","topic":"","x":110,"y":140,"wires":[["92dd4796.6f9b78"]]},{"id":"876a7f0f.97ec","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Manual Update Frisco","group":"18f340fe.a70a3f","order":3,"width":3,"height":1,"passthru":false,"label":"Update Frisco","tooltip":"","color":"","bgcolor":"#163e80","icon":"","payload":"1","payloadType":"num","topic":"","x":140,"y":300,"wires":[["cb24235e.8e734"]]},{"id":"92dd4796.6f9b78","type":"function","z":"1a0aa13a.9d7b8f","name":"flow.set(\"status\",\"run\");","func":"flow.set(\"status\",\"run\");\nreturn msg;","outputs":1,"noerr":0,"x":300,"y":140,"wires":[[]]},{"id":"b95d43d.3a36dc","type":"function","z":"1a0aa13a.9d7b8f","name":"flow.set(\"status\",\"stopped\");","func":"flow.set(\"status\",\"stopped\");\nreturn msg;","outputs":1,"noerr":0,"x":320,"y":220,"wires":[[]]},{"id":"da8cbc87.ae3a5","type":"function","z":"1a0aa13a.9d7b8f","name":"Pass request if status is run","func":"var status = flow.get(\"status\")||\"stopped\";\n\nif (status==\"run\") {\n   msg.payload = 1;\n   return msg;\n}","outputs":1,"noerr":0,"x":440,"y":100,"wires":[["cb24235e.8e734","1bb63a9a.228e25","8231f6f8.f19dc8"]]},{"id":"cccb923b.d858e","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"No filter","group":"4baf1468.abb01c","order":1,"width":0,"height":0,"passthru":false,"label":"No filter","tooltip":"","color":"","bgcolor":"","icon":"","payload":"1","payloadType":"num","topic":"none","x":80,"y":580,"wires":[["d5ba20b1.2a352"]]},{"id":"aa86cd79.d94ad","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"DFW","group":"4baf1468.abb01c","order":2,"width":3,"height":1,"passthru":false,"label":"DFW","tooltip":"Dallas/Fort Worth","color":"","bgcolor":"#163e80","icon":"","payload":"1","payloadType":"num","topic":"DFW","x":70,"y":620,"wires":[["d5ba20b1.2a352"]]},{"id":"27435c82.f51e34","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"DAL","group":"4baf1468.abb01c","order":3,"width":3,"height":1,"passthru":false,"label":"DAL","tooltip":"Love Field","color":"","bgcolor":"#dec733","icon":"","payload":"1","payloadType":"num","topic":"DAL","x":70,"y":660,"wires":[["d5ba20b1.2a352"]]},{"id":"d5ba20b1.2a352","type":"function","z":"1a0aa13a.9d7b8f","name":"","func":"flow.set(\"filter\",msg.topic);\nreturn msg;","outputs":1,"noerr":0,"x":250,"y":580,"wires":[["93bd58c2.f4fe18"]]},{"id":"93bd58c2.f4fe18","type":"function","z":"1a0aa13a.9d7b8f","name":"Clear the map","func":"var command = {clear :(\"Planes\")};\nmsg.payload ={command};\nreturn msg;","outputs":1,"noerr":0,"x":440,"y":540,"wires":[["be318435.10d8b8"]]},{"id":"caee0f1a.07ba8","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"AUS","group":"4baf1468.abb01c","order":4,"width":3,"height":1,"passthru":false,"label":"AUS","tooltip":"Austin","color":"","bgcolor":"#e3a209","icon":"","payload":"1","payloadType":"num","topic":"AUS","x":70,"y":700,"wires":[["d5ba20b1.2a352"]]},{"id":"f9d66341.1059a","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"ADK","group":"4baf1468.abb01c","order":5,"width":3,"height":1,"passthru":false,"label":"ADK","tooltip":"Adak","color":"black","bgcolor":"#03fff2","icon":"","payload":"1","payloadType":"num","topic":"ADK","x":70,"y":740,"wires":[["d5ba20b1.2a352"]]},{"id":"8e440b7b.6ab8f8","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Clear Map","group":"18f340fe.a70a3f","order":6,"width":3,"height":1,"passthru":false,"label":"Clear Map","tooltip":"","color":"","bgcolor":"","icon":"","payload":"unknown","payloadType":"str","topic":"","x":90,"y":540,"wires":[["93bd58c2.f4fe18"]]},{"id":"4140806e.6466f","type":"function","z":"1a0aa13a.9d7b8f","name":"","func":"flow.set(\"filter_ac_type\",msg.topic);\nreturn msg;","outputs":1,"noerr":0,"x":250,"y":780,"wires":[["93bd58c2.f4fe18"]]},{"id":"ba4470ea.c6f46","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"No filter","group":"9cbb54f5.392db8","order":1,"width":"0","height":"0","passthru":false,"label":"No filter","tooltip":"","color":"","bgcolor":"","icon":"","payload":"1","payloadType":"num","topic":"none","x":80,"y":780,"wires":[["4140806e.6466f"]]},{"id":"f7bd0619.7b5958","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"A320","group":"9cbb54f5.392db8","order":5,"width":3,"height":1,"passthru":false,"label":"A320","tooltip":"A320","color":"","bgcolor":"tan","icon":"","payload":"1","payloadType":"num","topic":"A320","x":70,"y":900,"wires":[["4140806e.6466f"]]},{"id":"cd272b01.efcf38","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"A319","group":"9cbb54f5.392db8","order":4,"width":3,"height":1,"passthru":false,"label":"A319","tooltip":"A319","color":"","bgcolor":"tan","icon":"","payload":"1","payloadType":"num","topic":"A319","x":70,"y":860,"wires":[["4140806e.6466f"]]},{"id":"6ac93ca1.3b5044","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"E190","group":"9cbb54f5.392db8","order":11,"width":3,"height":1,"passthru":false,"label":"E190","tooltip":"E190","color":"","bgcolor":"tan","icon":"","payload":"1","payloadType":"num","topic":"E190","x":70,"y":820,"wires":[["4140806e.6466f"]]},{"id":"2069470f.ed9d38","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"A321","group":"9cbb54f5.392db8","order":6,"width":3,"height":1,"passthru":false,"label":"A321","tooltip":"A321","color":"","bgcolor":"tan","icon":"","payload":"1","payloadType":"num","topic":"A321","x":70,"y":940,"wires":[["4140806e.6466f"]]},{"id":"70e6c475.1c4e3c","type":"inject","z":"1a0aa13a.9d7b8f","name":"Starutp","topic":"","payload":"1","payloadType":"num","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":120,"y":60,"wires":[["6a58e276.4439bc"]]},{"id":"6a58e276.4439bc","type":"function","z":"1a0aa13a.9d7b8f","name":"Set Initial Conditions","func":"flow.set(\"status\",\"stopped\");\nflow.set(\"filter\",\"none\");\nflow.set(\"filter_ac_type\",\"none\");\nflow.set(\"Flights\",0);\nflow.set(\"Unnamed\",0);\nreturn msg;","outputs":1,"noerr":0,"x":420,"y":60,"wires":[[]]},{"id":"e0dbb5f4.ea61a8","type":"inject","z":"1a0aa13a.9d7b8f","name":"Put static items","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":400,"y":1260,"wires":[["ae3e0ad9.38d3d8","40300d96.260ec4","f8753462.d6e958","df986dbb.427e1","f4d88d0e.bab43","b79ed39b.475ae"]]},{"id":"40300d96.260ec4","type":"change","z":"1a0aa13a.9d7b8f","name":"Ashmont 5 mile Ring","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"name\":\"Ashmont 5 Mile Ring\",\"lat\":33.110554,\"lon\":-96.790415,\"radius\":8047,\"layer\":\"Guides\",\"stroke\":true,\"fill\":false,\"color\":\"#163e80\"}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":660,"y":1340,"wires":[["65c68644.d9f5f8"]]},{"id":"df986dbb.427e1","type":"change","z":"1a0aa13a.9d7b8f","name":"Courmayeur Ct 5 mile ring","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"name\":\"Courmayeur Ct 5 Mile Ring\",\"lat\":30.580425,\"lon\":-97.6687,\"radius\":8047,\"layer\":\"Guides\",\"color\":\"#e3a209\",\"stroke\":true,\"fill\":false}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":670,"y":1420,"wires":[["65c68644.d9f5f8"]]},{"id":"ae3e0ad9.38d3d8","type":"change","z":"1a0aa13a.9d7b8f","name":"Ashmont +-1degree box","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"name\":\"Ashmont 2 degree box\",\"area\":[[34.110554,-95.790415],[32.110554,-97.790415]],\"layer\":\"Guides\",\"color\":\"#163e80\",\"stroke\":true,\"fill\":false}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":670,"y":1300,"wires":[["65c68644.d9f5f8"]]},{"id":"a707bbad.9cc0a8","type":"inject","z":"1a0aa13a.9d7b8f","name":"","topic":"","payload":"ExMike","payloadType":"flow","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":2710,"y":100,"wires":[["60e36d76.c72234"]]},{"id":"24139e5b.304392","type":"inject","z":"1a0aa13a.9d7b8f","name":"","topic":"","payload":"ExMike2","payloadType":"flow","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":2710,"y":140,"wires":[["60e36d76.c72234"]]},{"id":"eef451c.e7538b","type":"change","z":"1a0aa13a.9d7b8f","name":"","rules":[{"t":"delete","p":"payload","pt":"msg"},{"t":"set","p":"payload.id","pt":"msg","to":"\"Mike ID 1\"","tot":"str"},{"t":"set","p":"payload.registration","pt":"msg","to":"\"Mike Registration 1\"","tot":"str"},{"t":"set","p":"payload.flight","pt":"msg","to":"\"MK1210\"","tot":"str"},{"t":"set","p":"payload.callsign","pt":"msg","to":"\"M70\"","tot":"str"},{"t":"set","p":"payload.origin","pt":"msg","to":"DFW","tot":"str"},{"t":"set","p":"payload.destination","pt":"msg","to":"DAL","tot":"str"},{"t":"set","p":"payload.altitude","pt":"msg","to":"12000","tot":"num"},{"t":"set","p":"payload.bearing","pt":"msg","to":"180","tot":"num"},{"t":"set","p":"payload.speed","pt":"msg","to":"500","tot":"num"},{"t":"set","p":"payload.rateOfClimb","pt":"msg","to":"100","tot":"str"},{"t":"set","p":"payload.isOnGround","pt":"msg","to":"false","tot":"bool"},{"t":"set","p":"payload.squakCode","pt":"msg","to":"7700","tot":"str"},{"t":"set","p":"payload.model","pt":"msg","to":"F15","tot":"str"},{"t":"set","p":"payload.modelSCode","pt":"msg","to":"TMS123","tot":"str"},{"t":"set","p":"payload.radar","pt":"msg","to":"F-KERV1","tot":"str"},{"t":"set","p":"payload.isGlider","pt":"msg","to":"false","tot":"bool"},{"t":"set","p":"payload.timestamp","pt":"msg","to":"1587418302","tot":"str"},{"t":"set","p":"payload.lat","pt":"msg","to":"30.596","tot":"num"},{"t":"set","p":"payload.lon","pt":"msg","to":"-97.5165","tot":"str"},{"t":"set","p":"payload.name","pt":"msg","to":"Mike","tot":"str"},{"t":"set","p":"payload.icon","pt":"msg","to":"plane","tot":"str"},{"t":"set","p":"payload.iconColor","pt":"msg","to":"green","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":3050,"y":80,"wires":[["ac2d129.1dad3f"]]},{"id":"9039e375.fa20b","type":"inject","z":"1a0aa13a.9d7b8f","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":2880,"y":80,"wires":[["eef451c.e7538b"]]},{"id":"ac2d129.1dad3f","type":"function","z":"1a0aa13a.9d7b8f","name":"","func":"flow.set(\"ExMike\", msg.payload)\nreturn msg;","outputs":1,"noerr":0,"x":3210,"y":80,"wires":[["98d7608c.72f61"]]},{"id":"ece3b8ec.44abd8","type":"change","z":"1a0aa13a.9d7b8f","name":"","rules":[{"t":"delete","p":"payload","pt":"msg"},{"t":"set","p":"payload.id","pt":"msg","to":"\"Mike ID 1\"","tot":"str"},{"t":"set","p":"payload.registration","pt":"msg","to":"\"Mike Registration 2\"","tot":"str"},{"t":"set","p":"payload.flight","pt":"msg","to":"\"MK1211\"","tot":"str"},{"t":"set","p":"payload.callsign","pt":"msg","to":"\"M71\"","tot":"str"},{"t":"set","p":"payload.origin","pt":"msg","to":"HOU","tot":"str"},{"t":"set","p":"payload.destination","pt":"msg","to":"ADK","tot":"str"},{"t":"set","p":"payload.altitude","pt":"msg","to":"12010","tot":"num"},{"t":"set","p":"payload.bearing","pt":"msg","to":"90","tot":"num"},{"t":"set","p":"payload.speed","pt":"msg","to":"200","tot":"num"},{"t":"set","p":"payload.rateOfClimb","pt":"msg","to":"600","tot":"str"},{"t":"set","p":"payload.isOnGround","pt":"msg","to":"true","tot":"bool"},{"t":"set","p":"payload.squakCode","pt":"msg","to":"7701","tot":"str"},{"t":"set","p":"payload.model","pt":"msg","to":"F16","tot":"str"},{"t":"set","p":"payload.modelSCode","pt":"msg","to":"TMS124","tot":"str"},{"t":"set","p":"payload.radar","pt":"msg","to":"F-KERV2","tot":"str"},{"t":"set","p":"payload.isGlider","pt":"msg","to":"true","tot":"bool"},{"t":"set","p":"payload.timestamp","pt":"msg","to":"1587418999","tot":"str"},{"t":"set","p":"payload.lat","pt":"msg","to":"30.596","tot":"num"},{"t":"set","p":"payload.lon","pt":"msg","to":"-97.53","tot":"str"},{"t":"set","p":"payload.name","pt":"msg","to":"Mike2","tot":"str"},{"t":"set","p":"payload.icon","pt":"msg","to":"plane","tot":"str"},{"t":"set","p":"payload.iconColor","pt":"msg","to":"blue","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":3050,"y":160,"wires":[["961e9df.788476"]]},{"id":"961e9df.788476","type":"function","z":"1a0aa13a.9d7b8f","name":"","func":"flow.set(\"ExMike2\", msg.payload)\nreturn msg;","outputs":1,"noerr":0,"x":3210,"y":160,"wires":[["98d7608c.72f61"]]},{"id":"c073164c.21f858","type":"inject","z":"1a0aa13a.9d7b8f","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":2880,"y":160,"wires":[["ece3b8ec.44abd8"]]},{"id":"f8753462.d6e958","type":"change","z":"1a0aa13a.9d7b8f","name":"Courmayeur +-1degree box","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"name\":\"Courmayeur 2 degree box\",\"area\":[[31.580425,-96.6687],[29.580425,-98.6687]],\"layer\":\"Guides\",\"color\":\"#e3a209\",\"stroke\":true,\"fill\":false}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":680,"y":1380,"wires":[["65c68644.d9f5f8"]]},{"id":"f4d88d0e.bab43","type":"change","z":"1a0aa13a.9d7b8f","name":"Adak +-1degree box","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"name\":\"Adak 2 degree box\",\"area\":[[52.881211,-175.645945],[50.881211,-177.645945]],\"layer\":\"Guides\",\"color\":\"#42e6f5\",\"stroke\":true,\"fill\":false}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":660,"y":1460,"wires":[["65c68644.d9f5f8"]]},{"id":"8649aebd.474bf","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Manual Update Round Rock","group":"18f340fe.a70a3f","order":4,"width":3,"height":1,"passthru":false,"label":"Update Round Rock","tooltip":"","color":"","bgcolor":"#e3a209","icon":"","payload":"2","payloadType":"num","topic":"","x":160,"y":380,"wires":[["1bb63a9a.228e25"]]},{"id":"c190d566.420e98","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Manual Update Adak","group":"18f340fe.a70a3f","order":5,"width":3,"height":1,"passthru":false,"label":"Update Adak","tooltip":"","color":"black","bgcolor":"#03fff2","icon":"","payload":"3","payloadType":"num","topic":"","x":140,"y":460,"wires":[["8231f6f8.f19dc8"]]},{"id":"65c68644.d9f5f8","type":"link out","z":"1a0aa13a.9d7b8f","name":"","links":["1d42282.fe857d8","ee484184.496fc"],"x":915,"y":1380,"wires":[]},{"id":"be318435.10d8b8","type":"link out","z":"1a0aa13a.9d7b8f","name":"","links":["ee484184.496fc"],"x":575,"y":380,"wires":[]},{"id":"60e36d76.c72234","type":"link out","z":"1a0aa13a.9d7b8f","name":"","links":["1d42282.fe857d8"],"x":2835,"y":120,"wires":[]},{"id":"98d7608c.72f61","type":"link out","z":"1a0aa13a.9d7b8f","name":"","links":["1d42282.fe857d8"],"x":3215,"y":120,"wires":[]},{"id":"e087c831.86ec18","type":"worldmap in","z":"1a0aa13a.9d7b8f","name":"","path":"/worldmapF","events":"","x":80,"y":1460,"wires":[["f30ac03a.0ad73","55d1fab6.fc8df4"]]},{"id":"cb7f3d05.97917","type":"ui_worldmap","z":"1a0aa13a.9d7b8f","group":"c7810244.5e40a","order":1,"width":"17","height":"14","name":"Common Map","lat":"33.110554","lon":"-96.790415","zoom":"7","layer":"OSM grey","cluster":"","maxage":"","usermenu":"hide","layers":"show","panit":"false","panlock":"false","zoomlock":"false","hiderightclick":"true","coords":"none","showgrid":"false","path":"/worldmapF","x":1260,"y":280,"wires":[]},{"id":"c2404805.adc308","type":"link in","z":"1a0aa13a.9d7b8f","name":"","links":["180e3c96.5dcc73"],"x":515,"y":980,"wires":[["1007803a.19083","ea06efdd.4e9a3","d2aafef.4a4fb","dfa46271.30ff4","e463fba.82f0608","b68e76cf.21f968","6f7f90ae.4a87b","149d3d39.bb4d83"]]},{"id":"149d3d39.bb4d83","type":"function","z":"1a0aa13a.9d7b8f","name":"","func":"\nreturn msg;","outputs":1,"noerr":0,"x":630,"y":740,"wires":[[]]},{"id":"1007803a.19083","type":"function","z":"1a0aa13a.9d7b8f","name":"Named","func":"\nreturn msg;","outputs":1,"noerr":0,"x":640,"y":800,"wires":[[]]},{"id":"ea06efdd.4e9a3","type":"function","z":"1a0aa13a.9d7b8f","name":"Added Layer","func":"msg.payload.layer = \"Planes\"\nreturn msg;","outputs":1,"noerr":0,"x":650,"y":860,"wires":[[]]},{"id":"d2aafef.4a4fb","type":"function","z":"1a0aa13a.9d7b8f","name":"Added Layer, Default Color","func":"msg.payload.layer = \"Planes\"\nmsg.payload.iconColor = \"#111212\"\n\nreturn msg;","outputs":1,"noerr":0,"x":700,"y":920,"wires":[[]]},{"id":"dfa46271.30ff4","type":"function","z":"1a0aa13a.9d7b8f","name":"Added Layer, Default Color, Unnamed Fix","func":"msg.payload.layer = \"Planes\"\nmsg.payload.iconColor = \"#111212\"\nif (msg.payload.name === null){\n    msg.payload.name = \"Call Sign \" + msg.payload.callsign\n//    msg.payload.iconColor = \"yellow\"\n}\n\nreturn msg;","outputs":1,"noerr":0,"x":740,"y":980,"wires":[[]]},{"id":"e463fba.82f0608","type":"function","z":"1a0aa13a.9d7b8f","name":"Added Layer, Default Color, Unnamed Fix, Airport coloring","func":"msg.payload.layer = \"Planes\"\nmsg.payload.iconColor = \"#111212\"\nif (msg.payload.name === null){\n    msg.payload.name = \"Call Sign \" + msg.payload.callsign\n}\nif (msg.payload.destination == \"DFW\") {\n    msg.payload.iconColor = \"#4287f5\";\n} else if (msg.payload.destination == \"DAL\") {\n    msg.payload.iconColor = \"#dec733\";\n} else if (msg.payload.origin == \"DFW\") {\n    msg.payload.iconColor = \"#163e80\";\n} else if (msg.payload.origin == \"DAL\") {\n    msg.payload.iconColor = \"#6b6015\";\n} else if (msg.payload.destination == \"AUS\") {\n    msg.payload.iconColor = \"#e3a209\";\n} else if (msg.payload.origin == \"AUS\") {\n    msg.payload.iconColor = \"#6e520f\";\n} else if (msg.payload.destination == \"ADK\") {\n    msg.payload.iconColor = \"#03fff2\";\n} else if (msg.payload.origin == \"ADK\") {\n    msg.payload.iconColor = \"#026e68\";\n}\n\nreturn msg;","outputs":1,"noerr":0,"x":790,"y":1040,"wires":[[]]},{"id":"b68e76cf.21f968","type":"function","z":"1a0aa13a.9d7b8f","name":"Added Layer, Default Color, Unnamed Fix, Airport coloring, Count Flights","func":"msg.payload.layer = \"Planes\"\nmsg.payload.iconColor = \"#111212\"\nif (msg.payload.name === null){\n    msg.payload.name = \"Call Sign \" + msg.payload.callsign\n}\nif (msg.payload.destination == \"DFW\") {\n    msg.payload.iconColor = \"#4287f5\";\n} else if (msg.payload.destination == \"DAL\") {\n    msg.payload.iconColor = \"#dec733\";\n} else if (msg.payload.origin == \"DFW\") {\n    msg.payload.iconColor = \"#163e80\";\n} else if (msg.payload.origin == \"DAL\") {\n    msg.payload.iconColor = \"#6b6015\";\n} else if (msg.payload.destination == \"AUS\") {\n    msg.payload.iconColor = \"#e3a209\";\n} else if (msg.payload.origin == \"AUS\") {\n    msg.payload.iconColor = \"#6e520f\";\n} else if (msg.payload.destination == \"ADK\") {\n    msg.payload.iconColor = \"#03fff2\";\n} else if (msg.payload.origin == \"ADK\") {\n    msg.payload.iconColor = \"#026e68\";\n}\nvar flightcount = flow.get(\"Flights\")\nflightcount++\nflow.set(\"Flights\", flightcount)\nreturn msg;","outputs":1,"noerr":0,"x":840,"y":1100,"wires":[[]]},{"id":"ffbec31e.59c3e","type":"worldmap","z":"1a0aa13a.9d7b8f","name":"","lat":"","lon":"","zoom":"9","layer":"","cluster":"9","maxage":"10","usermenu":"hide","layers":"hide","panit":"false","panlock":"false","zoomlock":"false","hiderightclick":"false","coords":"none","showgrid":"false","path":"/worldmapF","x":1270,"y":400,"wires":[]},{"id":"6f7f90ae.4a87b","type":"function","z":"1a0aa13a.9d7b8f","name":"Added Layer, Default Color, Unnamed Fix, Airport coloring, Count Flights, layer per name","func":"msg.payload.layer = \"Planes\"\nmsg.payload.iconColor = \"#111212\"\nif (msg.payload.name === null){\n    msg.payload.name = \"Call Sign \" + msg.payload.callsign\n}\nif (msg.payload.destination == \"DFW\") {\n    msg.payload.iconColor = \"#4287f5\";\n} else if (msg.payload.destination == \"DAL\") {\n    msg.payload.iconColor = \"#dec733\";\n} else if (msg.payload.origin == \"DFW\") {\n    msg.payload.iconColor = \"#163e80\";\n} else if (msg.payload.origin == \"DAL\") {\n    msg.payload.iconColor = \"#6b6015\";\n} else if (msg.payload.destination == \"AUS\") {\n    msg.payload.iconColor = \"#e3a209\";\n} else if (msg.payload.origin == \"AUS\") {\n    msg.payload.iconColor = \"#6e520f\";\n} else if (msg.payload.destination == \"ADK\") {\n    msg.payload.iconColor = \"#03fff2\";\n} else if (msg.payload.origin == \"ADK\") {\n    msg.payload.iconColor = \"#026e68\";\n}\nvar flightcount = flow.get(\"Flights\")\nflightcount++\nflow.set(\"Flights\", flightcount)\nmsg.payload.layer = msg.payload.name\nreturn msg;","outputs":1,"noerr":0,"x":890,"y":1160,"wires":[[]]},{"id":"80419bfc.5b1768","type":"change","z":"1a0aa13a.9d7b8f","name":"Adak","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"command\":{\"zoom\":9,\"lat\":51.881211,\"lon\":-176.645945}}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":350,"y":2360,"wires":[["64dacd09.3027b4"]]},{"id":"190bf318.1a650d","type":"inject","z":"1a0aa13a.9d7b8f","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":275,"y":2340,"wires":[["80419bfc.5b1768"]],"l":false},{"id":"fa8f9937.f27ee8","type":"change","z":"1a0aa13a.9d7b8f","name":"Round Rock","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"command\":{\"zoom\":9,\"lat\":30.580425,\"lon\":-97.6687}}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":370,"y":2440,"wires":[["64dacd09.3027b4"]]},{"id":"1a1fa532.ab215b","type":"inject","z":"1a0aa13a.9d7b8f","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":275,"y":2420,"wires":[["fa8f9937.f27ee8"]],"l":false},{"id":"64dacd09.3027b4","type":"worldmap","z":"1a0aa13a.9d7b8f","name":"","lat":"","lon":"","zoom":"","layer":"","cluster":"","maxage":"","usermenu":"show","layers":"show","panit":"false","panlock":"false","zoomlock":"false","hiderightclick":"false","coords":"none","showgrid":"false","path":"/worldmapF","x":590,"y":2480,"wires":[]},{"id":"b4b2bf95.3b1ee","type":"change","z":"1a0aa13a.9d7b8f","name":"Frisco","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"command\":{\"zoom\":9,\"lat\":33.110554,\"lon\":-96.790415}}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":350,"y":2520,"wires":[["64dacd09.3027b4"]]},{"id":"bf385b8.2b4ada8","type":"inject","z":"1a0aa13a.9d7b8f","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":275,"y":2500,"wires":[["b4b2bf95.3b1ee"]],"l":false},{"id":"e407c2b6.a946a","type":"comment","z":"1a0aa13a.9d7b8f","name":"Manual Center Map with Injection Nodes","info":"","x":180,"y":2260,"wires":[]},{"id":"f30ac03a.0ad73","type":"switch","z":"1a0aa13a.9d7b8f","name":"Put Static Items upon connection","property":"payload.action","propertyType":"msg","rules":[{"t":"eq","v":"other","vt":"str"},{"t":"eq","v":"connected","vt":"str"},{"t":"eq","v":"blah","vt":"str"}],"checkall":"true","repair":false,"outputs":3,"x":340,"y":1460,"wires":[[],["ae3e0ad9.38d3d8","40300d96.260ec4","f8753462.d6e958","df986dbb.427e1","f4d88d0e.bab43","f597fefe.493b4","b79ed39b.475ae"],[]]},{"id":"3c198e04.951cf2","type":"comment","z":"1a0aa13a.9d7b8f","name":"Static Items","info":"","x":110,"y":1260,"wires":[]},{"id":"d9c4756d.4912a8","type":"function","z":"1a0aa13a.9d7b8f","name":"","func":"msg.payload.layer = \"Planes\"\nmsg.payload.iconColor = \"#111212\"\nif (msg.payload.name === null){\n    msg.payload.name = \"Call Sign \" + msg.payload.callsign\n}\nif (msg.payload.destination == \"DFW\") {\n    msg.payload.iconColor = \"#4287f5\";\n} else if (msg.payload.destination == \"DAL\") {\n    msg.payload.iconColor = \"#dec733\";\n} else if (msg.payload.origin == \"DFW\") {\n    msg.payload.iconColor = \"#163e80\";\n} else if (msg.payload.origin == \"DAL\") {\n    msg.payload.iconColor = \"#6b6015\";\n} else if (msg.payload.destination == \"AUS\") {\n    msg.payload.iconColor = \"#e3a209\";\n} else if (msg.payload.origin == \"AUS\") {\n    msg.payload.iconColor = \"#6e520f\";\n} else if (msg.payload.destination == \"ADK\") {\n    msg.payload.iconColor = \"#03fff2\";\n} else if (msg.payload.origin == \"ADK\") {\n    msg.payload.iconColor = \"#026e68\";\n}\nvar flightcount = flow.get(\"Flights\")\nflightcount++\nflow.set(\"Flights\", flightcount)\nreturn msg;","outputs":1,"noerr":0,"x":930,"y":260,"wires":[["35c05549.6bfb8a","ffbec31e.59c3e"]]},{"id":"f597fefe.493b4","type":"change","z":"1a0aa13a.9d7b8f","name":"Adak Ct 1 meter ring","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"name\":\"Courmayeur Ct 5 Mile Ring\",\"lat\":51.8812115,\"lon\":-176.645945,\"radius\":1,\"layer\":\"Guides\",\"color\":\"#42e6f5\",\"stroke\":true,\"fill\":false}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":660,"y":1500,"wires":[["65c68644.d9f5f8"]]},{"id":"ee484184.496fc","type":"link in","z":"1a0aa13a.9d7b8f","name":"","links":["65c68644.d9f5f8","90f4b0b2.d61cb","be318435.10d8b8"],"x":1075,"y":400,"wires":[["ffbec31e.59c3e"]]},{"id":"c1a95748.60dee8","type":"inject","z":"1a0aa13a.9d7b8f","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":360,"y":180,"wires":[["cb24235e.8e734","1bb63a9a.228e25","8231f6f8.f19dc8"]]},{"id":"deb62833.319248","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Pause","group":"18f340fe.a70a3f","order":2,"width":3,"height":1,"passthru":false,"label":"Pause","tooltip":"","color":"black","bgcolor":"Yellow","icon":"","payload":"1","payloadType":"num","topic":"","x":90,"y":220,"wires":[["b95d43d.3a36dc"]]},{"id":"68a71860.f8c088","type":"ui_ui_control","z":"1a0aa13a.9d7b8f","name":"Watch for tab change","events":"change","x":120,"y":2740,"wires":[[]]},{"id":"d2b548d0.9c1888","type":"switch","z":"1a0aa13a.9d7b8f","name":"Identify which tab was selected","property":"name","propertyType":"msg","rules":[{"t":"eq","v":"Control Page","vt":"str"},{"t":"eq","v":"Frisco Console","vt":"str"},{"t":"eq","v":"Ashmont Close Radar Console","vt":"str"},{"t":"eq","v":"Round Rock Console","vt":"str"},{"t":"eq","v":"Adak Console","vt":"str"},{"t":"eq","v":"Table Holder","vt":"str"}],"checkall":"true","repair":false,"outputs":6,"x":370,"y":2740,"wires":[[],["e6046c5d.94ad6"],["29e87dec.9770d2"],["d6e9f9eb.6be028"],["ada93296.c3fe8"],[]]},{"id":"e6046c5d.94ad6","type":"link out","z":"1a0aa13a.9d7b8f","name":"Switched to Frisco Map","links":["ae75446a.5c9038"],"x":650,"y":2720,"wires":[],"l":true},{"id":"d6e9f9eb.6be028","type":"link out","z":"1a0aa13a.9d7b8f","name":"Switched to Round Rock Map","links":["2cb61460.48fdac"],"x":670,"y":2800,"wires":[],"l":true},{"id":"ada93296.c3fe8","type":"link out","z":"1a0aa13a.9d7b8f","name":"Switched to Adak Map","links":["3e563cdf.bf8d64"],"x":640,"y":2840,"wires":[],"l":true},{"id":"3e563cdf.bf8d64","type":"link in","z":"1a0aa13a.9d7b8f","name":"","links":["ada93296.c3fe8"],"x":275,"y":2380,"wires":[["80419bfc.5b1768"]]},{"id":"2cb61460.48fdac","type":"link in","z":"1a0aa13a.9d7b8f","name":"","links":["d6e9f9eb.6be028"],"x":275,"y":2460,"wires":[["fa8f9937.f27ee8"]]},{"id":"ae75446a.5c9038","type":"link in","z":"1a0aa13a.9d7b8f","name":"","links":["e6046c5d.94ad6"],"x":275,"y":2540,"wires":[["b4b2bf95.3b1ee"]]},{"id":"22f4e35c.8f5abc","type":"comment","z":"1a0aa13a.9d7b8f","name":"Change Map Center to the Focus of the Tab","info":"","x":190,"y":2660,"wires":[]},{"id":"23f14bb4.2a9524","type":"change","z":"1a0aa13a.9d7b8f","name":"Frisco Close","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"command\":{\"zoom\":12,\"lat\":33.110554,\"lon\":-96.790415}}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":370,"y":2600,"wires":[["64dacd09.3027b4"]]},{"id":"29e87dec.9770d2","type":"link out","z":"1a0aa13a.9d7b8f","name":"Switched to Ashmont Close Radar","links":["65f24c6b.258234"],"x":680,"y":2760,"wires":[],"l":true},{"id":"65f24c6b.258234","type":"link in","z":"1a0aa13a.9d7b8f","name":"","links":["29e87dec.9770d2"],"x":275,"y":2620,"wires":[["23f14bb4.2a9524"]]},{"id":"32ca5c62.a67e44","type":"inject","z":"1a0aa13a.9d7b8f","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":275,"y":2580,"wires":[["23f14bb4.2a9524"]],"l":false},{"id":"b79ed39b.475ae","type":"change","z":"1a0aa13a.9d7b8f","name":"Ashmont Home","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"name\":\"Home\",\"lat\":33.110555,\"lon\":-96.790415,\"radius\":0,\"layer\":\"House\",\"stroke\":true,\"fill\":false,\"color\":\"red\",\"icon\":\"home\"}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":640,"y":1260,"wires":[["65c68644.d9f5f8"]]},{"id":"9ab8f275.a4c7b","type":"inject","z":"65feaf2a.1fb8f","name":"","topic":"","payload":"[{\"Name\":\"Kazuhito Yokoi\",\"Age\":\"35\",\"Favourite Color\":\"red\",\"Date Of Birth\":\"12/09/1983\"},{\"Name\":\"Oli Bob\",\"Age\":\"12\",\"Favourite Color\":\"red\",\"Date Of Birth\":\"12/08/2017\"}]","payloadType":"json","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":350,"y":180,"wires":[[]]},{"id":"cabe63b8.a0c3","type":"comment","z":"65feaf2a.1fb8f","name":"Normal table","info":"","x":350,"y":140,"wires":[]},{"id":"2426de50.7e80b2","type":"inject","z":"65feaf2a.1fb8f","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":140,"y":400,"wires":[["363d600a.fecad"]]},{"id":"363d600a.fecad","type":"change","z":"65feaf2a.1fb8f","name":"","rules":[{"t":"set","p":"payload.name","pt":"msg","to":"ABC","tot":"str"},{"t":"set","p":"payload.title","pt":"msg","to":"flaksdjfl","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":340,"y":420,"wires":[["651cc3c0.b4798c"]]},{"id":"651cc3c0.b4798c","type":"join","z":"65feaf2a.1fb8f","name":"","mode":"custom","build":"array","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":530,"y":420,"wires":[[]]},{"id":"b7d336e3.07e088","type":"join","z":"1a0aa13a.9d7b8f","name":"","mode":"custom","build":"array","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"3","count":"","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1130,"y":159,"wires":[["6837dde8.0c0a64"]]},{"id":"6837dde8.0c0a64","type":"ui_table","z":"1a0aa13a.9d7b8f","group":"e298b809.c3c2f8","name":"Before mod","order":1,"width":"22","height":"7","columns":[{"field":"name","title":"Name","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"iconColor","title":"Icon Color","width":"105","align":"left","formatter":"color","formatterParams":{"target":"_blank"}},{"field":"id","title":"ID","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"registration","title":"Reg","width":"70","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"flight","title":"Flight","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"callsign","title":"Call Sign","width":"95","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"origin","title":"Origin","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"destination","title":"Destination","width":"110","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"altitude","title":"Altitude","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"bearing","title":"Bearing","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"speed","title":"Speed","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"rateOfClimb","title":"Rate of Climb","width":"125","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"isOnGround","title":"On Ground","width":"110","align":"left","formatter":"tickCross","formatterParams":{"target":"_blank"}},{"field":"squawkCode","title":"Squawk","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"model","title":"Model","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"modeSCode","title":"Mode S","width":"95","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"radar","title":"Radar","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"timestamp","title":"Timestamp","width":"110","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"lat","title":"Latitude","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"lon","title":"Longitude","width":"110","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}}],"outputs":0,"cts":false,"x":1290,"y":160,"wires":[]},{"id":"35c05549.6bfb8a","type":"join","z":"1a0aa13a.9d7b8f","name":"","mode":"custom","build":"array","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"3","count":"","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1130,"y":200,"wires":[["cf54cd13.c8b4c"]]},{"id":"cf54cd13.c8b4c","type":"ui_table","z":"1a0aa13a.9d7b8f","group":"2a128af6.d72c46","name":"After Mod","order":2,"width":"22","height":"7","columns":[{"field":"name","title":"Name","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"iconColor","title":"Icon Color","width":"105","align":"left","formatter":"color","formatterParams":{"target":"_blank"}},{"field":"id","title":"ID","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"registration","title":"Reg","width":"70","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"flight","title":"Flight","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"callsign","title":"Call Sign","width":"95","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"origin","title":"Origin","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"destination","title":"Destination","width":"110","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"altitude","title":"Altitude","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"bearing","title":"Bearing","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"speed","title":"Speed","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"rateOfClimb","title":"Rate of Climb","width":"125","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"isOnGround","title":"On Ground","width":"110","align":"left","formatter":"tickCross","formatterParams":{"target":"_blank"}},{"field":"squawkCode","title":"Squawk","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"model","title":"Model","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"modeSCode","title":"Mode S","width":"95","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"radar","title":"Radar","width":"80","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"timestamp","title":"Timestamp","width":"110","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"lat","title":"Latitude","width":"90","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}},{"field":"lon","title":"Longitude","width":"110","align":"left","formatter":"plaintext","formatterParams":{"target":"_blank"}}],"outputs":0,"cts":false,"x":1280,"y":200,"wires":[]},{"id":"cb24235e.8e734","type":"flightradar24","z":"1a0aa13a.9d7b8f","lat":"33.110554","latType":"num","lon":"-96.790415","lonType":"num","name":"Frisco","x":630,"y":240,"wires":[["74960930.4c9f68","bff6514.ec089b","4fb4f787.825de8"]]},{"id":"1bb63a9a.228e25","type":"flightradar24","z":"1a0aa13a.9d7b8f","lat":"30.580425","latType":"num","lon":"-97.6687","lonType":"num","name":"Round Rock","x":650,"y":280,"wires":[["74960930.4c9f68","bff6514.ec089b","4fb4f787.825de8"]]},{"id":"8231f6f8.f19dc8","type":"flightradar24","z":"1a0aa13a.9d7b8f","lat":"51.881211","latType":"num","lon":"-176.645945","lonType":"num","name":"Adak","x":630,"y":320,"wires":[["74960930.4c9f68","bff6514.ec089b","4fb4f787.825de8"]]},{"id":"55d1fab6.fc8df4","type":"debug","z":"1a0aa13a.9d7b8f","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":1180,"y":520,"wires":[]},{"id":"ddcdc7a9.5ce8e8","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Frisco","group":"602d7c75.e52ed4","order":1,"width":3,"height":1,"passthru":false,"label":"Frisco","tooltip":"","color":"","bgcolor":"#163e80","icon":"","payload":"1","payloadType":"num","topic":"","x":70,"y":2520,"wires":[["b4b2bf95.3b1ee"]]},{"id":"643b8a51.1824d4","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Ashmont","group":"602d7c75.e52ed4","order":1,"width":3,"height":1,"passthru":false,"label":"Ashmont","tooltip":"","color":"","bgcolor":"#163e80","icon":"","payload":"1","payloadType":"num","topic":"","x":80,"y":2600,"wires":[["23f14bb4.2a9524"]]},{"id":"275ee96d.2d18c6","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Round Rock","group":"602d7c75.e52ed4","order":1,"width":3,"height":1,"passthru":false,"label":"Round Rock","tooltip":"","color":"","bgcolor":"#e3a209","icon":"","payload":"1","payloadType":"num","topic":"","x":90,"y":2440,"wires":[["fa8f9937.f27ee8"]]},{"id":"8a0cf593.496128","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Adak","group":"602d7c75.e52ed4","order":1,"width":3,"height":1,"passthru":false,"label":"Adak","tooltip":"","color":"black","bgcolor":"#03fff2","icon":"","payload":"1","payloadType":"num","topic":"","x":70,"y":2360,"wires":[["80419bfc.5b1768"]]},{"id":"74960930.4c9f68","type":"delay","z":"1a0aa13a.9d7b8f","name":"","pauseType":"delay","timeout":"5","timeoutUnits":"milliseconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":930,"y":140,"wires":[[]]},{"id":"bff6514.ec089b","type":"debug","z":"1a0aa13a.9d7b8f","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":840,"y":60,"wires":[]},{"id":"e7d8ec72.7f72c","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Start/Restart","group":"a4570963.5547f8","order":1,"width":3,"height":1,"passthru":false,"label":"Start/Restart","tooltip":"","color":"","bgcolor":"Green","icon":"","payload":"1","payloadType":"num","topic":"","x":110,"y":180,"wires":[["92dd4796.6f9b78"]]},{"id":"f2f3203e.fb7b3","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Pause","group":"a4570963.5547f8","order":2,"width":3,"height":1,"passthru":false,"label":"Pause","tooltip":"","color":"black","bgcolor":"Yellow","icon":"","payload":"1","payloadType":"num","topic":"","x":90,"y":260,"wires":[["b95d43d.3a36dc"]]},{"id":"b80a6cf0.92a58","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Manual Update Frisco","group":"a4570963.5547f8","order":3,"width":3,"height":1,"passthru":false,"label":"Update Frisco","tooltip":"","color":"","bgcolor":"#163e80","icon":"","payload":"1","payloadType":"num","topic":"","x":140,"y":340,"wires":[["cb24235e.8e734"]]},{"id":"d499fa12.02bb28","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Manual Update Round Rock","group":"a4570963.5547f8","order":4,"width":3,"height":1,"passthru":false,"label":"Update Round Rock","tooltip":"","color":"","bgcolor":"#e3a209","icon":"","payload":"2","payloadType":"num","topic":"","x":160,"y":420,"wires":[["1bb63a9a.228e25"]]},{"id":"9b0185ef.894958","type":"ui_button","z":"1a0aa13a.9d7b8f","name":"Manual Update Adak","group":"a4570963.5547f8","order":5,"width":3,"height":1,"passthru":false,"label":"Update Adak","tooltip":"","color":"black","bgcolor":"#03fff2","icon":"","payload":"3","payloadType":"num","topic":"","x":140,"y":500,"wires":[["8231f6f8.f19dc8"]]},{"id":"4fb4f787.825de8","type":"delay","z":"1a0aa13a.9d7b8f","name":"","pauseType":"delay","timeout":"10","timeoutUnits":"milliseconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":870,"y":320,"wires":[["d9c4756d.4912a8","b7d336e3.07e088"]]}]